diff --git a/.gitignore b/.gitignore
deleted file mode 100644
index 850614ad..00000000
--- a/.gitignore
+++ /dev/null
@@ -1,50 +0,0 @@
-aclocal.m4
-autom4te.cache
-compile
-config.guess
-config.h
-config.h.in
-config.log
-config.status
-config.sub
-configure
-depcomp
-.deps
-.libs
-free
-INSTALL
-install-sh
-kill
-libtool
-*.lo
-ltmain.sh
-m4/
-Makefile
-Makefile.in
-missing
-*.o
-pgrep
-pkill
-pmap
-procps-ng-*.tar.gz
-proc/.depend
-proc/libproc-ng.la
-proc/Makefile
-proc/Makefile.in
-ps/Makefile
-ps/Makefile.in
-ps/pscommand
-pwdx
-skill
-slabtop
-snice
-*.so
-stamp-h1
-sysctl
-tload
-top
-uptime
-vmstat
-w
-watch
-*~
diff --git a/AUTHORS b/AUTHORS
deleted file mode 100644
index 0860b244..00000000
--- a/AUTHORS
+++ /dev/null
@@ -1,50 +0,0 @@
-free:
-Brian Edmonds
-
-oldps:
-Branko Lankester <lankeste@fwi.uva.nl>
-Michael K. Johnson <johnsonm@redhat.com>
-Michael Shields <mjshield@nyx.cs.du.edu>
-Charles Blake <cblake@bbn.com>
-David Mossberger-Tang
-
-ps:
-Albert Cahalan <albert@users.sf.net>
-
-skill/kill/snice:
-Albert Cahalan <albert@users.sf.net>
-
-tload:
-Branko Lankester
-David Engel <david@ods.com>
-Michael K. Johnson <johnsonm@redhat.com>
-
-top:
-Jim Warner <warnerjc@worldnet.att.net>
-
-oldtop:
-Branko Lankester <lankeste@fwi.uva.nl>
-Roger Binns
-Robert Nation <nation@rocket.sanders.lockheed.com>
-Michael K. Johnson <johnsonm@redhat.com>
-Michael Shields <mjshield@nyx.cs.du.edu>
-Tim Janik <timj@gtk.org>
-Helmut Geyer <Helmut.Geyer@iwr.uni-heidelberg.de>
-George Bonser <george@captech.com>
-
-uptime:
-Larry Greenfield <greenfie@gauss.rutgers.edu>
-Michael K. Johnson <johnsonm@sunsite.unc.edu>
-
-vmstat:
-Henry Ware <al172@yfn.ysu.edu>. 
-
-w:
-Larry Greenfield <greenfie@gauss.rutgers.edu>
-Michael K. Johnson <johnsonm@redhat.com>
-Charles Blake
-
-watch:
-Tony Rems <rembo@unisoft.com>
-Mike Coleman <mkc@acm.org>
-
diff --git a/BUGS b/BUGS
deleted file mode 100644
index 49722d9f..00000000
--- a/BUGS
+++ /dev/null
@@ -1,74 +0,0 @@
-BUG REPORTS
-
-Please read this file before sending in a bug report or patch.
-
-Also, PLEASE read the documentation first.  90% of the mail I get
-complaining about procps-ng is due to the sender not having read the
-documentation!
-
-
-Where to send
-=============
-Send comments, bug reports, patches, etc., to albert@users.sf.net
-
-
-What to send
-============
-It is much more useful to me if a program really crashes to recompile it
-with make "CFLAGS=-ggdb -O", run it with "gdb prog" and "run" and send
-me a stack trace ('bt' command).  That said, any bug report is still
-better than none.
-
-strace and ltrace output are very helpful:
-
-        strace -o output-file ps --blah
-        bzip2 output-file
-
-I also like "ps --info" output, even if there isn't a ps problem.
-
-Kernel-Dependent Patches
-========================
-If you send me patches which are specific to *running* with a particular
-kernel version of /proc, please condition them with the runtime determined
-variable 'linux_version_code' from libproc/version.c.  It is the same
-number as the macro LINUX_VERSION_CODE for which the kernel /proc fs
-code was compiled.
-
-A macro is provide in libproc/version.h to construct the code from its
-components, e.g.
-  if (linux_version_code < LINUX_VERSION(2,5,41))
-     /* blah blah blah */
-A startup call to set_linux_version may also be necessary.
-
-Of course, if a bug is due to a change in kernel file formats, it would
-be best to first try to generalize the parsing, since the code is then
-more resilient against future change.
-
-Also unified diffs (diff -u) are my preference, context diffs (diff -c )
-are kind of usable, and standard diffs (diff) are more useless than a
-generic text description of what you did.  Just use
-	diff -Naurd oldfile newfile
-or
-	diff -Naurd old-procps-ng-dir new-procps-ng-dir
-to create your diffs and you will make me happy.  Also make sure to
-include a description of what the diff is for or I'm likely to ignore
-it because of general lack of time...
-
-It might be nice to get rid of miscellaneous compiler warnings, but
-don't bend over backwards to do it.
-
-
-Code Structure
-==============
-
-A goal is to encapsulate *all* parsing dependent on /proc
-file formats into the libproc library.  If the API is general enough
-it can hopefully stabilize and then /proc changes might only require
-updating libproc.so.  Beyond that having the set of utilities be simple
-command lines parsers and output formatters and encapsulating all kernel
-divergence in libproc is the way to go.
-
-Hence if you are submitting a new program or are fixing an old one, keep
-in mind that adding files to libproc which encapsulate such things is
-more desirable than patching the actual driver program.  (well, except
-to move it toward the API of the library).
diff --git a/CMakeLists.txt b/CMakeLists.txt
new file mode 100644
index 00000000..0e310174
--- /dev/null
+++ b/CMakeLists.txt
@@ -0,0 +1,30 @@
+cmake_minimum_required(VERSION 3.10)
+
+project(procps VERSION 1.0 LANGUAGES C)
+
+set(PROCPS_SRC
+    alloc.c
+    devname.c
+    escape.c
+    ksym.c
+    pwcache.c
+    readproc.c
+    sig.c
+    slab.c
+    smaps.c
+    sysinfo.c
+    version.c
+    whattime.c
+)
+
+include_directories(${CMAKE_SOURCE_DIR})
+
+add_library(procps_static STATIC ${PROCPS_SRC})
+
+install(TARGETS procps_static 
+        LIBRARY DESTINATION lib
+        ARCHIVE DESTINATION lib
+        RUNTIME DESTINATION bin)
+
+install(FILES alloc.h devname.h escape.h pwcache.h readproc.h sig.h slab.h sysinfo.h version.h whattime.h wchan.h
+        DESTINATION include/procps)
diff --git a/COPYING b/COPYING
index 60549be5..92b8903f 100644
--- a/COPYING
+++ b/COPYING
@@ -1,22 +1,25 @@
-		    GNU GENERAL PUBLIC LICENSE
+		  GNU LIBRARY GENERAL PUBLIC LICENSE
 		       Version 2, June 1991
 
- Copyright (C) 1989, 1991 Free Software Foundation, Inc.
-                       59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Copyright (C) 1991 Free Software Foundation, Inc.
+    		    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  Everyone is permitted to copy and distribute verbatim copies
  of this license document, but changing it is not allowed.
 
+[This is the first released version of the library GPL.  It is
+ numbered 2 because it goes with version 2 of the ordinary GPL.]
+
 			    Preamble
 
   The licenses for most software are designed to take away your
 freedom to share and change it.  By contrast, the GNU General Public
-License is intended to guarantee your freedom to share and change free
-software--to make sure the software is free for all its users.  This
-General Public License applies to most of the Free Software
-Foundation's software and to any other program whose authors commit to
-using it.  (Some other Free Software Foundation software is covered by
-the GNU Library General Public License instead.)  You can apply it to
-your programs, too.
+Licenses are intended to guarantee your freedom to share and change
+free software--to make sure the software is free for all its users.
+
+  This license, the Library General Public License, applies to some
+specially designated Free Software Foundation software, and to any
+other libraries whose authors decide to use it.  You can use it for
+your libraries, too.
 
   When we speak of free software, we are referring to freedom, not
 price.  Our General Public Licenses are designed to make sure that you
@@ -27,195 +30,347 @@ in new free programs; and that you know you can do these things.
 
   To protect your rights, we need to make restrictions that forbid
 anyone to deny you these rights or to ask you to surrender the rights.
-These restrictions translate to certain responsibilities for you if you
-distribute copies of the software, or if you modify it.
-
-  For example, if you distribute copies of such a program, whether
-gratis or for a fee, you must give the recipients all the rights that
-you have.  You must make sure that they, too, receive or can get the
-source code.  And you must show them these terms so they know their
-rights.
-
-  We protect your rights with two steps: (1) copyright the software, and
-(2) offer you this license which gives you legal permission to copy,
-distribute and/or modify the software.
-
-  Also, for each author's protection and ours, we want to make certain
+These restrictions translate to certain responsibilities for you if
+you distribute copies of the library, or if you modify it.
+
+  For example, if you distribute copies of the library, whether gratis
+or for a fee, you must give the recipients all the rights that we gave
+you.  You must make sure that they, too, receive or can get the source
+code.  If you link a program with the library, you must provide
+complete object files to the recipients so that they can relink them
+with the library, after making changes to the library and recompiling
+it.  And you must show them these terms so they know their rights.
+
+  Our method of protecting your rights has two steps: (1) copyright
+the library, and (2) offer you this license which gives you legal
+permission to copy, distribute and/or modify the library.
+
+  Also, for each distributor's protection, we want to make certain
 that everyone understands that there is no warranty for this free
-software.  If the software is modified by someone else and passed on, we
-want its recipients to know that what they have is not the original, so
-that any problems introduced by others will not reflect on the original
-authors' reputations.
-
+library.  If the library is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original
+version, so that any problems introduced by others will not reflect on
+the original authors' reputations.
+
   Finally, any free program is threatened constantly by software
-patents.  We wish to avoid the danger that redistributors of a free
-program will individually obtain patent licenses, in effect making the
-program proprietary.  To prevent this, we have made it clear that any
-patent must be licensed for everyone's free use or not licensed at all.
+patents.  We wish to avoid the danger that companies distributing free
+software will individually obtain patent licenses, thus in effect
+transforming the program into proprietary software.  To prevent this,
+we have made it clear that any patent must be licensed for everyone's
+free use or not licensed at all.
+
+  Most GNU software, including some libraries, is covered by the ordinary
+GNU General Public License, which was designed for utility programs.  This
+license, the GNU Library General Public License, applies to certain
+designated libraries.  This license is quite different from the ordinary
+one; be sure to read it in full, and don't assume that anything in it is
+the same as in the ordinary license.
+
+  The reason we have a separate public license for some libraries is that
+they blur the distinction we usually make between modifying or adding to a
+program and simply using it.  Linking a program with a library, without
+changing the library, is in some sense simply using the library, and is
+analogous to running a utility program or application program.  However, in
+a textual and legal sense, the linked executable is a combined work, a
+derivative of the original library, and the ordinary General Public License
+treats it as such.
+
+  Because of this blurred distinction, using the ordinary General
+Public License for libraries did not effectively promote software
+sharing, because most developers did not use the libraries.  We
+concluded that weaker conditions might promote sharing better.
+
+  However, unrestricted linking of non-free programs would deprive the
+users of those programs of all benefit from the free status of the
+libraries themselves.  This Library General Public License is intended to
+permit developers of non-free programs to use free libraries, while
+preserving your freedom as a user of such programs to change the free
+libraries that are incorporated in them.  (We have not seen how to achieve
+this as regards changes in header files, but we have achieved it as regards
+changes in the actual functions of the Library.)  The hope is that this
+will lead to faster development of free libraries.
 
   The precise terms and conditions for copying, distribution and
-modification follow.
+modification follow.  Pay close attention to the difference between a
+"work based on the library" and a "work that uses the library".  The
+former contains code derived from the library, while the latter only
+works together with the library.
+
+  Note that it is possible for a library to be covered by the ordinary
+General Public License rather than by this special one.
 
-		    GNU GENERAL PUBLIC LICENSE
+		  GNU LIBRARY GENERAL PUBLIC LICENSE
    TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
 
-  0. This License applies to any program or other work which contains
-a notice placed by the copyright holder saying it may be distributed
-under the terms of this General Public License.  The "Program", below,
-refers to any such program or work, and a "work based on the Program"
-means either the Program or any derivative work under copyright law:
-that is to say, a work containing the Program or a portion of it,
-either verbatim or with modifications and/or translated into another
-language.  (Hereinafter, translation is included without limitation in
-the term "modification".)  Each licensee is addressed as "you".
-
-Activities other than copying, distribution and modification are not
+  0. This License Agreement applies to any software library which
+contains a notice placed by the copyright holder or other authorized
+party saying it may be distributed under the terms of this Library
+General Public License (also called "this License").  Each licensee is
+addressed as "you".
+
+  A "library" means a collection of software functions and/or data
+prepared so as to be conveniently linked with application programs
+(which use some of those functions and data) to form executables.
+
+  The "Library", below, refers to any such software library or work
+which has been distributed under these terms.  A "work based on the
+Library" means either the Library or any derivative work under
+copyright law: that is to say, a work containing the Library or a
+portion of it, either verbatim or with modifications and/or translated
+straightforwardly into another language.  (Hereinafter, translation is
+included without limitation in the term "modification".)
+
+  "Source code" for a work means the preferred form of the work for
+making modifications to it.  For a library, complete source code means
+all the source code for all modules it contains, plus any associated
+interface definition files, plus the scripts used to control compilation
+and installation of the library.
+
+  Activities other than copying, distribution and modification are not
 covered by this License; they are outside its scope.  The act of
-running the Program is not restricted, and the output from the Program
-is covered only if its contents constitute a work based on the
-Program (independent of having been made by running the Program).
-Whether that is true depends on what the Program does.
-
-  1. You may copy and distribute verbatim copies of the Program's
-source code as you receive it, in any medium, provided that you
-conspicuously and appropriately publish on each copy an appropriate
-copyright notice and disclaimer of warranty; keep intact all the
-notices that refer to this License and to the absence of any warranty;
-and give any other recipients of the Program a copy of this License
-along with the Program.
-
-You may charge a fee for the physical act of transferring a copy, and
-you may at your option offer warranty protection in exchange for a fee.
-
-  2. You may modify your copy or copies of the Program or any portion
-of it, thus forming a work based on the Program, and copy and
+running a program using the Library is not restricted, and output from
+such a program is covered only if its contents constitute a work based
+on the Library (independent of the use of the Library in a tool for
+writing it).  Whether that is true depends on what the Library does
+and what the program that uses the Library does.
+  
+  1. You may copy and distribute verbatim copies of the Library's
+complete source code as you receive it, in any medium, provided that
+you conspicuously and appropriately publish on each copy an
+appropriate copyright notice and disclaimer of warranty; keep intact
+all the notices that refer to this License and to the absence of any
+warranty; and distribute a copy of this License along with the
+Library.
+
+  You may charge a fee for the physical act of transferring a copy,
+and you may at your option offer warranty protection in exchange for a
+fee.
+
+  2. You may modify your copy or copies of the Library or any portion
+of it, thus forming a work based on the Library, and copy and
 distribute such modifications or work under the terms of Section 1
 above, provided that you also meet all of these conditions:
 
-    a) You must cause the modified files to carry prominent notices
+    a) The modified work must itself be a software library.
+
+    b) You must cause the files modified to carry prominent notices
     stating that you changed the files and the date of any change.
 
-    b) You must cause any work that you distribute or publish, that in
-    whole or in part contains or is derived from the Program or any
-    part thereof, to be licensed as a whole at no charge to all third
-    parties under the terms of this License.
-
-    c) If the modified program normally reads commands interactively
-    when run, you must cause it, when started running for such
-    interactive use in the most ordinary way, to print or display an
-    announcement including an appropriate copyright notice and a
-    notice that there is no warranty (or else, saying that you provide
-    a warranty) and that users may redistribute the program under
-    these conditions, and telling the user how to view a copy of this
-    License.  (Exception: if the Program itself is interactive but
-    does not normally print such an announcement, your work based on
-    the Program is not required to print an announcement.)
-
+    c) You must cause the whole of the work to be licensed at no
+    charge to all third parties under the terms of this License.
+
+    d) If a facility in the modified Library refers to a function or a
+    table of data to be supplied by an application program that uses
+    the facility, other than as an argument passed when the facility
+    is invoked, then you must make a good faith effort to ensure that,
+    in the event an application does not supply such function or
+    table, the facility still operates, and performs whatever part of
+    its purpose remains meaningful.
+
+    (For example, a function in a library to compute square roots has
+    a purpose that is entirely well-defined independent of the
+    application.  Therefore, Subsection 2d requires that any
+    application-supplied function or table used by this function must
+    be optional: if the application does not supply it, the square
+    root function must still compute square roots.)
+
 These requirements apply to the modified work as a whole.  If
-identifiable sections of that work are not derived from the Program,
+identifiable sections of that work are not derived from the Library,
 and can be reasonably considered independent and separate works in
 themselves, then this License, and its terms, do not apply to those
 sections when you distribute them as separate works.  But when you
 distribute the same sections as part of a whole which is a work based
-on the Program, the distribution of the whole must be on the terms of
+on the Library, the distribution of the whole must be on the terms of
 this License, whose permissions for other licensees extend to the
-entire whole, and thus to each and every part regardless of who wrote it.
+entire whole, and thus to each and every part regardless of who wrote
+it.
 
 Thus, it is not the intent of this section to claim rights or contest
 your rights to work written entirely by you; rather, the intent is to
 exercise the right to control the distribution of derivative or
-collective works based on the Program.
+collective works based on the Library.
 
-In addition, mere aggregation of another work not based on the Program
-with the Program (or with a work based on the Program) on a volume of
+In addition, mere aggregation of another work not based on the Library
+with the Library (or with a work based on the Library) on a volume of
 a storage or distribution medium does not bring the other work under
 the scope of this License.
 
-  3. You may copy and distribute the Program (or a work based on it,
-under Section 2) in object code or executable form under the terms of
-Sections 1 and 2 above provided that you also do one of the following:
-
-    a) Accompany it with the complete corresponding machine-readable
-    source code, which must be distributed under the terms of Sections
-    1 and 2 above on a medium customarily used for software interchange; or,
-
-    b) Accompany it with a written offer, valid for at least three
-    years, to give any third party, for a charge no more than your
-    cost of physically performing source distribution, a complete
-    machine-readable copy of the corresponding source code, to be
-    distributed under the terms of Sections 1 and 2 above on a medium
-    customarily used for software interchange; or,
-
-    c) Accompany it with the information you received as to the offer
-    to distribute corresponding source code.  (This alternative is
-    allowed only for noncommercial distribution and only if you
-    received the program in object code or executable form with such
-    an offer, in accord with Subsection b above.)
-
-The source code for a work means the preferred form of the work for
-making modifications to it.  For an executable work, complete source
-code means all the source code for all modules it contains, plus any
-associated interface definition files, plus the scripts used to
-control compilation and installation of the executable.  However, as a
-special exception, the source code distributed need not include
-anything that is normally distributed (in either source or binary
-form) with the major components (compiler, kernel, and so on) of the
-operating system on which the executable runs, unless that component
-itself accompanies the executable.
-
-If distribution of executable or object code is made by offering
-access to copy from a designated place, then offering equivalent
-access to copy the source code from the same place counts as
-distribution of the source code, even though third parties are not
+  3. You may opt to apply the terms of the ordinary GNU General Public
+License instead of this License to a given copy of the Library.  To do
+this, you must alter all the notices that refer to this License, so
+that they refer to the ordinary GNU General Public License, version 2,
+instead of to this License.  (If a newer version than version 2 of the
+ordinary GNU General Public License has appeared, then you can specify
+that version instead if you wish.)  Do not make any other change in
+these notices.
+
+  Once this change is made in a given copy, it is irreversible for
+that copy, so the ordinary GNU General Public License applies to all
+subsequent copies and derivative works made from that copy.
+
+  This option is useful when you wish to copy part of the code of
+the Library into a program that is not a library.
+
+  4. You may copy and distribute the Library (or a portion or
+derivative of it, under Section 2) in object code or executable form
+under the terms of Sections 1 and 2 above provided that you accompany
+it with the complete corresponding machine-readable source code, which
+must be distributed under the terms of Sections 1 and 2 above on a
+medium customarily used for software interchange.
+
+  If distribution of object code is made by offering access to copy
+from a designated place, then offering equivalent access to copy the
+source code from the same place satisfies the requirement to
+distribute the source code, even though third parties are not
 compelled to copy the source along with the object code.
+
+  5. A program that contains no derivative of any portion of the
+Library, but is designed to work with the Library by being compiled or
+linked with it, is called a "work that uses the Library".  Such a
+work, in isolation, is not a derivative work of the Library, and
+therefore falls outside the scope of this License.
+
+  However, linking a "work that uses the Library" with the Library
+creates an executable that is a derivative of the Library (because it
+contains portions of the Library), rather than a "work that uses the
+library".  The executable is therefore covered by this License.
+Section 6 states terms for distribution of such executables.
+
+  When a "work that uses the Library" uses material from a header file
+that is part of the Library, the object code for the work may be a
+derivative work of the Library even though the source code is not.
+Whether this is true is especially significant if the work can be
+linked without the Library, or if the work is itself a library.  The
+threshold for this to be true is not precisely defined by law.
+
+  If such an object file uses only numerical parameters, data
+structure layouts and accessors, and small macros and small inline
+functions (ten lines or less in length), then the use of the object
+file is unrestricted, regardless of whether it is legally a derivative
+work.  (Executables containing this object code plus portions of the
+Library will still fall under Section 6.)
+
+  Otherwise, if the work is a derivative of the Library, you may
+distribute the object code for the work under the terms of Section 6.
+Any executables containing that work also fall under Section 6,
+whether or not they are linked directly with the Library itself.
+
+  6. As an exception to the Sections above, you may also compile or
+link a "work that uses the Library" with the Library to produce a
+work containing portions of the Library, and distribute that work
+under terms of your choice, provided that the terms permit
+modification of the work for the customer's own use and reverse
+engineering for debugging such modifications.
+
+  You must give prominent notice with each copy of the work that the
+Library is used in it and that the Library and its use are covered by
+this License.  You must supply a copy of this License.  If the work
+during execution displays copyright notices, you must include the
+copyright notice for the Library among them, as well as a reference
+directing the user to the copy of this License.  Also, you must do one
+of these things:
+
+    a) Accompany the work with the complete corresponding
+    machine-readable source code for the Library including whatever
+    changes were used in the work (which must be distributed under
+    Sections 1 and 2 above); and, if the work is an executable linked
+    with the Library, with the complete machine-readable "work that
+    uses the Library", as object code and/or source code, so that the
+    user can modify the Library and then relink to produce a modified
+    executable containing the modified Library.  (It is understood
+    that the user who changes the contents of definitions files in the
+    Library will not necessarily be able to recompile the application
+    to use the modified definitions.)
+
+    b) Accompany the work with a written offer, valid for at
+    least three years, to give the same user the materials
+    specified in Subsection 6a, above, for a charge no more
+    than the cost of performing this distribution.
+
+    c) If distribution of the work is made by offering access to copy
+    from a designated place, offer equivalent access to copy the above
+    specified materials from the same place.
+
+    d) Verify that the user has already received a copy of these
+    materials or that you have already sent this user a copy.
+
+  For an executable, the required form of the "work that uses the
+Library" must include any data and utility programs needed for
+reproducing the executable from it.  However, as a special exception,
+the source code distributed need not include anything that is normally
+distributed (in either source or binary form) with the major
+components (compiler, kernel, and so on) of the operating system on
+which the executable runs, unless that component itself accompanies
+the executable.
+
+  It may happen that this requirement contradicts the license
+restrictions of other proprietary libraries that do not normally
+accompany the operating system.  Such a contradiction means you cannot
+use both them and the Library together in an executable that you
+distribute.
 
-  4. You may not copy, modify, sublicense, or distribute the Program
-except as expressly provided under this License.  Any attempt
-otherwise to copy, modify, sublicense or distribute the Program is
-void, and will automatically terminate your rights under this License.
-However, parties who have received copies, or rights, from you under
-this License will not have their licenses terminated so long as such
-parties remain in full compliance.
-
-  5. You are not required to accept this License, since you have not
+  7. You may place library facilities that are a work based on the
+Library side-by-side in a single library together with other library
+facilities not covered by this License, and distribute such a combined
+library, provided that the separate distribution of the work based on
+the Library and of the other library facilities is otherwise
+permitted, and provided that you do these two things:
+
+    a) Accompany the combined library with a copy of the same work
+    based on the Library, uncombined with any other library
+    facilities.  This must be distributed under the terms of the
+    Sections above.
+
+    b) Give prominent notice with the combined library of the fact
+    that part of it is a work based on the Library, and explaining
+    where to find the accompanying uncombined form of the same work.
+
+  8. You may not copy, modify, sublicense, link with, or distribute
+the Library except as expressly provided under this License.  Any
+attempt otherwise to copy, modify, sublicense, link with, or
+distribute the Library is void, and will automatically terminate your
+rights under this License.  However, parties who have received copies,
+or rights, from you under this License will not have their licenses
+terminated so long as such parties remain in full compliance.
+
+  9. You are not required to accept this License, since you have not
 signed it.  However, nothing else grants you permission to modify or
-distribute the Program or its derivative works.  These actions are
+distribute the Library or its derivative works.  These actions are
 prohibited by law if you do not accept this License.  Therefore, by
-modifying or distributing the Program (or any work based on the
-Program), you indicate your acceptance of this License to do so, and
+modifying or distributing the Library (or any work based on the
+Library), you indicate your acceptance of this License to do so, and
 all its terms and conditions for copying, distributing or modifying
-the Program or works based on it.
+the Library or works based on it.
 
-  6. Each time you redistribute the Program (or any work based on the
-Program), the recipient automatically receives a license from the
-original licensor to copy, distribute or modify the Program subject to
-these terms and conditions.  You may not impose any further
+  10. Each time you redistribute the Library (or any work based on the
+Library), the recipient automatically receives a license from the
+original licensor to copy, distribute, link with or modify the Library
+subject to these terms and conditions.  You may not impose any further
 restrictions on the recipients' exercise of the rights granted herein.
 You are not responsible for enforcing compliance by third parties to
 this License.
-
-  7. If, as a consequence of a court judgment or allegation of patent
+
+  11. If, as a consequence of a court judgment or allegation of patent
 infringement or for any other reason (not limited to patent issues),
 conditions are imposed on you (whether by court order, agreement or
 otherwise) that contradict the conditions of this License, they do not
 excuse you from the conditions of this License.  If you cannot
 distribute so as to satisfy simultaneously your obligations under this
 License and any other pertinent obligations, then as a consequence you
-may not distribute the Program at all.  For example, if a patent
-license would not permit royalty-free redistribution of the Program by
+may not distribute the Library at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Library by
 all those who receive copies directly or indirectly through you, then
 the only way you could satisfy both it and this License would be to
-refrain entirely from distribution of the Program.
+refrain entirely from distribution of the Library.
 
-If any portion of this section is held invalid or unenforceable under
-any particular circumstance, the balance of the section is intended to
-apply and the section as a whole is intended to apply in other
-circumstances.
+If any portion of this section is held invalid or unenforceable under any
+particular circumstance, the balance of the section is intended to apply,
+and the section as a whole is intended to apply in other circumstances.
 
 It is not the purpose of this section to induce you to infringe any
 patents or other property right claims or to contest validity of any
 such claims; this section has the sole purpose of protecting the
-integrity of the free software distribution system, which is
+integrity of the free software distribution system which is
 implemented by public license practices.  Many people have made
 generous contributions to the wide range of software distributed
 through that system in reliance on consistent application of that
@@ -225,116 +380,102 @@ impose that choice.
 
 This section is intended to make thoroughly clear what is believed to
 be a consequence of the rest of this License.
-
-  8. If the distribution and/or use of the Program is restricted in
+
+  12. If the distribution and/or use of the Library is restricted in
 certain countries either by patents or by copyrighted interfaces, the
-original copyright holder who places the Program under this License
-may add an explicit geographical distribution limitation excluding
-those countries, so that distribution is permitted only in or among
-countries not thus excluded.  In such case, this License incorporates
-the limitation as if written in the body of this License.
-
-  9. The Free Software Foundation may publish revised and/or new versions
-of the General Public License from time to time.  Such new versions will
-be similar in spirit to the present version, but may differ in detail to
-address new problems or concerns.
-
-Each version is given a distinguishing version number.  If the Program
-specifies a version number of this License which applies to it and "any
-later version", you have the option of following the terms and conditions
-either of that version or of any later version published by the Free
-Software Foundation.  If the Program does not specify a version number of
-this License, you may choose any version ever published by the Free Software
-Foundation.
-
-  10. If you wish to incorporate parts of the Program into other free
-programs whose distribution conditions are different, write to the author
-to ask for permission.  For software which is copyrighted by the Free
-Software Foundation, write to the Free Software Foundation; we sometimes
-make exceptions for this.  Our decision will be guided by the two goals
-of preserving the free status of all derivatives of our free software and
-of promoting the sharing and reuse of software generally.
+original copyright holder who places the Library under this License may add
+an explicit geographical distribution limitation excluding those countries,
+so that distribution is permitted only in or among countries not thus
+excluded.  In such case, this License incorporates the limitation as if
+written in the body of this License.
+
+  13. The Free Software Foundation may publish revised and/or new
+versions of the Library General Public License from time to time.
+Such new versions will be similar in spirit to the present version,
+but may differ in detail to address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Library
+specifies a version number of this License which applies to it and
+"any later version", you have the option of following the terms and
+conditions either of that version or of any later version published by
+the Free Software Foundation.  If the Library does not specify a
+license version number, you may choose any version ever published by
+the Free Software Foundation.
+
+  14. If you wish to incorporate parts of the Library into other free
+programs whose distribution conditions are incompatible with these,
+write to the author to ask for permission.  For software which is
+copyrighted by the Free Software Foundation, write to the Free
+Software Foundation; we sometimes make exceptions for this.  Our
+decision will be guided by the two goals of preserving the free status
+of all derivatives of our free software and of promoting the sharing
+and reuse of software generally.
 
 			    NO WARRANTY
 
-  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
-FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
-OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
-PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
-OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
-TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
-PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
-REPAIR OR CORRECTION.
-
-  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
-REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
-INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
-OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
-TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
-YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
-PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGES.
+  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
+WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
+EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
+OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
+KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
+LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
+THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
+WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
+AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
+FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
+CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
+LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
+RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
+FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
+SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+DAMAGES.
 
 		     END OF TERMS AND CONDITIONS
 
-	    How to Apply These Terms to Your New Programs
+           How to Apply These Terms to Your New Libraries
 
-  If you develop a new program, and you want it to be of the greatest
-possible use to the public, the best way to achieve this is to make it
-free software which everyone can redistribute and change under these terms.
+  If you develop a new library, and you want it to be of the greatest
+possible use to the public, we recommend making it free software that
+everyone can redistribute and change.  You can do so by permitting
+redistribution under these terms (or, alternatively, under the terms of the
+ordinary General Public License).
 
-  To do so, attach the following notices to the program.  It is safest
-to attach them to the start of each source file to most effectively
-convey the exclusion of warranty; and each file should have at least
-the "copyright" line and a pointer to where the full notice is found.
+  To apply these terms, attach the following notices to the library.  It is
+safest to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least the
+"copyright" line and a pointer to where the full notice is found.
 
-    <one line to give the program's name and a brief idea of what it does.>
-    Copyright (C) 19yy  <name of author>
+    <one line to give the library's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
 
-    This program is distributed in the hope that it will be useful,
+    This library is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 
-
 Also add information on how to contact you by electronic and paper mail.
 
-If the program is interactive, make it output a short notice like this
-when it starts in an interactive mode:
-
-    Gnomovision version 69, Copyright (C) 19yy name of author
-    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
-    This is free software, and you are welcome to redistribute it
-    under certain conditions; type `show c' for details.
-
-The hypothetical commands `show w' and `show c' should show the appropriate
-parts of the General Public License.  Of course, the commands you use may
-be called something other than `show w' and `show c'; they could even be
-mouse-clicks or menu items--whatever suits your program.
-
 You should also get your employer (if you work as a programmer) or your
-school, if any, to sign a "copyright disclaimer" for the program, if
+school, if any, to sign a "copyright disclaimer" for the library, if
 necessary.  Here is a sample; alter the names:
 
-  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
-  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the
+  library `Frob' (a library for tweaking knobs) written by James Random Hacker.
 
-  <signature of Ty Coon>, 1 April 1989
+  <signature of Ty Coon>, 1 April 1990
   Ty Coon, President of Vice
 
-This General Public License does not permit incorporating your program into
-proprietary programs.  If your program is a subroutine library, you may
-consider it more useful to permit linking proprietary applications with the
-library.  If this is what you want to do, use the GNU Library General
-Public License instead of this License.
+That's all there is to it!
diff --git a/COPYING.LIB b/COPYING.LIB
deleted file mode 100644
index 92b8903f..00000000
--- a/COPYING.LIB
+++ /dev/null
@@ -1,481 +0,0 @@
-		  GNU LIBRARY GENERAL PUBLIC LICENSE
-		       Version 2, June 1991
-
- Copyright (C) 1991 Free Software Foundation, Inc.
-    		    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-[This is the first released version of the library GPL.  It is
- numbered 2 because it goes with version 2 of the ordinary GPL.]
-
-			    Preamble
-
-  The licenses for most software are designed to take away your
-freedom to share and change it.  By contrast, the GNU General Public
-Licenses are intended to guarantee your freedom to share and change
-free software--to make sure the software is free for all its users.
-
-  This license, the Library General Public License, applies to some
-specially designated Free Software Foundation software, and to any
-other libraries whose authors decide to use it.  You can use it for
-your libraries, too.
-
-  When we speak of free software, we are referring to freedom, not
-price.  Our General Public Licenses are designed to make sure that you
-have the freedom to distribute copies of free software (and charge for
-this service if you wish), that you receive source code or can get it
-if you want it, that you can change the software or use pieces of it
-in new free programs; and that you know you can do these things.
-
-  To protect your rights, we need to make restrictions that forbid
-anyone to deny you these rights or to ask you to surrender the rights.
-These restrictions translate to certain responsibilities for you if
-you distribute copies of the library, or if you modify it.
-
-  For example, if you distribute copies of the library, whether gratis
-or for a fee, you must give the recipients all the rights that we gave
-you.  You must make sure that they, too, receive or can get the source
-code.  If you link a program with the library, you must provide
-complete object files to the recipients so that they can relink them
-with the library, after making changes to the library and recompiling
-it.  And you must show them these terms so they know their rights.
-
-  Our method of protecting your rights has two steps: (1) copyright
-the library, and (2) offer you this license which gives you legal
-permission to copy, distribute and/or modify the library.
-
-  Also, for each distributor's protection, we want to make certain
-that everyone understands that there is no warranty for this free
-library.  If the library is modified by someone else and passed on, we
-want its recipients to know that what they have is not the original
-version, so that any problems introduced by others will not reflect on
-the original authors' reputations.
-
-  Finally, any free program is threatened constantly by software
-patents.  We wish to avoid the danger that companies distributing free
-software will individually obtain patent licenses, thus in effect
-transforming the program into proprietary software.  To prevent this,
-we have made it clear that any patent must be licensed for everyone's
-free use or not licensed at all.
-
-  Most GNU software, including some libraries, is covered by the ordinary
-GNU General Public License, which was designed for utility programs.  This
-license, the GNU Library General Public License, applies to certain
-designated libraries.  This license is quite different from the ordinary
-one; be sure to read it in full, and don't assume that anything in it is
-the same as in the ordinary license.
-
-  The reason we have a separate public license for some libraries is that
-they blur the distinction we usually make between modifying or adding to a
-program and simply using it.  Linking a program with a library, without
-changing the library, is in some sense simply using the library, and is
-analogous to running a utility program or application program.  However, in
-a textual and legal sense, the linked executable is a combined work, a
-derivative of the original library, and the ordinary General Public License
-treats it as such.
-
-  Because of this blurred distinction, using the ordinary General
-Public License for libraries did not effectively promote software
-sharing, because most developers did not use the libraries.  We
-concluded that weaker conditions might promote sharing better.
-
-  However, unrestricted linking of non-free programs would deprive the
-users of those programs of all benefit from the free status of the
-libraries themselves.  This Library General Public License is intended to
-permit developers of non-free programs to use free libraries, while
-preserving your freedom as a user of such programs to change the free
-libraries that are incorporated in them.  (We have not seen how to achieve
-this as regards changes in header files, but we have achieved it as regards
-changes in the actual functions of the Library.)  The hope is that this
-will lead to faster development of free libraries.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.  Pay close attention to the difference between a
-"work based on the library" and a "work that uses the library".  The
-former contains code derived from the library, while the latter only
-works together with the library.
-
-  Note that it is possible for a library to be covered by the ordinary
-General Public License rather than by this special one.
-
-		  GNU LIBRARY GENERAL PUBLIC LICENSE
-   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
-
-  0. This License Agreement applies to any software library which
-contains a notice placed by the copyright holder or other authorized
-party saying it may be distributed under the terms of this Library
-General Public License (also called "this License").  Each licensee is
-addressed as "you".
-
-  A "library" means a collection of software functions and/or data
-prepared so as to be conveniently linked with application programs
-(which use some of those functions and data) to form executables.
-
-  The "Library", below, refers to any such software library or work
-which has been distributed under these terms.  A "work based on the
-Library" means either the Library or any derivative work under
-copyright law: that is to say, a work containing the Library or a
-portion of it, either verbatim or with modifications and/or translated
-straightforwardly into another language.  (Hereinafter, translation is
-included without limitation in the term "modification".)
-
-  "Source code" for a work means the preferred form of the work for
-making modifications to it.  For a library, complete source code means
-all the source code for all modules it contains, plus any associated
-interface definition files, plus the scripts used to control compilation
-and installation of the library.
-
-  Activities other than copying, distribution and modification are not
-covered by this License; they are outside its scope.  The act of
-running a program using the Library is not restricted, and output from
-such a program is covered only if its contents constitute a work based
-on the Library (independent of the use of the Library in a tool for
-writing it).  Whether that is true depends on what the Library does
-and what the program that uses the Library does.
-  
-  1. You may copy and distribute verbatim copies of the Library's
-complete source code as you receive it, in any medium, provided that
-you conspicuously and appropriately publish on each copy an
-appropriate copyright notice and disclaimer of warranty; keep intact
-all the notices that refer to this License and to the absence of any
-warranty; and distribute a copy of this License along with the
-Library.
-
-  You may charge a fee for the physical act of transferring a copy,
-and you may at your option offer warranty protection in exchange for a
-fee.
-
-  2. You may modify your copy or copies of the Library or any portion
-of it, thus forming a work based on the Library, and copy and
-distribute such modifications or work under the terms of Section 1
-above, provided that you also meet all of these conditions:
-
-    a) The modified work must itself be a software library.
-
-    b) You must cause the files modified to carry prominent notices
-    stating that you changed the files and the date of any change.
-
-    c) You must cause the whole of the work to be licensed at no
-    charge to all third parties under the terms of this License.
-
-    d) If a facility in the modified Library refers to a function or a
-    table of data to be supplied by an application program that uses
-    the facility, other than as an argument passed when the facility
-    is invoked, then you must make a good faith effort to ensure that,
-    in the event an application does not supply such function or
-    table, the facility still operates, and performs whatever part of
-    its purpose remains meaningful.
-
-    (For example, a function in a library to compute square roots has
-    a purpose that is entirely well-defined independent of the
-    application.  Therefore, Subsection 2d requires that any
-    application-supplied function or table used by this function must
-    be optional: if the application does not supply it, the square
-    root function must still compute square roots.)
-
-These requirements apply to the modified work as a whole.  If
-identifiable sections of that work are not derived from the Library,
-and can be reasonably considered independent and separate works in
-themselves, then this License, and its terms, do not apply to those
-sections when you distribute them as separate works.  But when you
-distribute the same sections as part of a whole which is a work based
-on the Library, the distribution of the whole must be on the terms of
-this License, whose permissions for other licensees extend to the
-entire whole, and thus to each and every part regardless of who wrote
-it.
-
-Thus, it is not the intent of this section to claim rights or contest
-your rights to work written entirely by you; rather, the intent is to
-exercise the right to control the distribution of derivative or
-collective works based on the Library.
-
-In addition, mere aggregation of another work not based on the Library
-with the Library (or with a work based on the Library) on a volume of
-a storage or distribution medium does not bring the other work under
-the scope of this License.
-
-  3. You may opt to apply the terms of the ordinary GNU General Public
-License instead of this License to a given copy of the Library.  To do
-this, you must alter all the notices that refer to this License, so
-that they refer to the ordinary GNU General Public License, version 2,
-instead of to this License.  (If a newer version than version 2 of the
-ordinary GNU General Public License has appeared, then you can specify
-that version instead if you wish.)  Do not make any other change in
-these notices.
-
-  Once this change is made in a given copy, it is irreversible for
-that copy, so the ordinary GNU General Public License applies to all
-subsequent copies and derivative works made from that copy.
-
-  This option is useful when you wish to copy part of the code of
-the Library into a program that is not a library.
-
-  4. You may copy and distribute the Library (or a portion or
-derivative of it, under Section 2) in object code or executable form
-under the terms of Sections 1 and 2 above provided that you accompany
-it with the complete corresponding machine-readable source code, which
-must be distributed under the terms of Sections 1 and 2 above on a
-medium customarily used for software interchange.
-
-  If distribution of object code is made by offering access to copy
-from a designated place, then offering equivalent access to copy the
-source code from the same place satisfies the requirement to
-distribute the source code, even though third parties are not
-compelled to copy the source along with the object code.
-
-  5. A program that contains no derivative of any portion of the
-Library, but is designed to work with the Library by being compiled or
-linked with it, is called a "work that uses the Library".  Such a
-work, in isolation, is not a derivative work of the Library, and
-therefore falls outside the scope of this License.
-
-  However, linking a "work that uses the Library" with the Library
-creates an executable that is a derivative of the Library (because it
-contains portions of the Library), rather than a "work that uses the
-library".  The executable is therefore covered by this License.
-Section 6 states terms for distribution of such executables.
-
-  When a "work that uses the Library" uses material from a header file
-that is part of the Library, the object code for the work may be a
-derivative work of the Library even though the source code is not.
-Whether this is true is especially significant if the work can be
-linked without the Library, or if the work is itself a library.  The
-threshold for this to be true is not precisely defined by law.
-
-  If such an object file uses only numerical parameters, data
-structure layouts and accessors, and small macros and small inline
-functions (ten lines or less in length), then the use of the object
-file is unrestricted, regardless of whether it is legally a derivative
-work.  (Executables containing this object code plus portions of the
-Library will still fall under Section 6.)
-
-  Otherwise, if the work is a derivative of the Library, you may
-distribute the object code for the work under the terms of Section 6.
-Any executables containing that work also fall under Section 6,
-whether or not they are linked directly with the Library itself.
-
-  6. As an exception to the Sections above, you may also compile or
-link a "work that uses the Library" with the Library to produce a
-work containing portions of the Library, and distribute that work
-under terms of your choice, provided that the terms permit
-modification of the work for the customer's own use and reverse
-engineering for debugging such modifications.
-
-  You must give prominent notice with each copy of the work that the
-Library is used in it and that the Library and its use are covered by
-this License.  You must supply a copy of this License.  If the work
-during execution displays copyright notices, you must include the
-copyright notice for the Library among them, as well as a reference
-directing the user to the copy of this License.  Also, you must do one
-of these things:
-
-    a) Accompany the work with the complete corresponding
-    machine-readable source code for the Library including whatever
-    changes were used in the work (which must be distributed under
-    Sections 1 and 2 above); and, if the work is an executable linked
-    with the Library, with the complete machine-readable "work that
-    uses the Library", as object code and/or source code, so that the
-    user can modify the Library and then relink to produce a modified
-    executable containing the modified Library.  (It is understood
-    that the user who changes the contents of definitions files in the
-    Library will not necessarily be able to recompile the application
-    to use the modified definitions.)
-
-    b) Accompany the work with a written offer, valid for at
-    least three years, to give the same user the materials
-    specified in Subsection 6a, above, for a charge no more
-    than the cost of performing this distribution.
-
-    c) If distribution of the work is made by offering access to copy
-    from a designated place, offer equivalent access to copy the above
-    specified materials from the same place.
-
-    d) Verify that the user has already received a copy of these
-    materials or that you have already sent this user a copy.
-
-  For an executable, the required form of the "work that uses the
-Library" must include any data and utility programs needed for
-reproducing the executable from it.  However, as a special exception,
-the source code distributed need not include anything that is normally
-distributed (in either source or binary form) with the major
-components (compiler, kernel, and so on) of the operating system on
-which the executable runs, unless that component itself accompanies
-the executable.
-
-  It may happen that this requirement contradicts the license
-restrictions of other proprietary libraries that do not normally
-accompany the operating system.  Such a contradiction means you cannot
-use both them and the Library together in an executable that you
-distribute.
-
-  7. You may place library facilities that are a work based on the
-Library side-by-side in a single library together with other library
-facilities not covered by this License, and distribute such a combined
-library, provided that the separate distribution of the work based on
-the Library and of the other library facilities is otherwise
-permitted, and provided that you do these two things:
-
-    a) Accompany the combined library with a copy of the same work
-    based on the Library, uncombined with any other library
-    facilities.  This must be distributed under the terms of the
-    Sections above.
-
-    b) Give prominent notice with the combined library of the fact
-    that part of it is a work based on the Library, and explaining
-    where to find the accompanying uncombined form of the same work.
-
-  8. You may not copy, modify, sublicense, link with, or distribute
-the Library except as expressly provided under this License.  Any
-attempt otherwise to copy, modify, sublicense, link with, or
-distribute the Library is void, and will automatically terminate your
-rights under this License.  However, parties who have received copies,
-or rights, from you under this License will not have their licenses
-terminated so long as such parties remain in full compliance.
-
-  9. You are not required to accept this License, since you have not
-signed it.  However, nothing else grants you permission to modify or
-distribute the Library or its derivative works.  These actions are
-prohibited by law if you do not accept this License.  Therefore, by
-modifying or distributing the Library (or any work based on the
-Library), you indicate your acceptance of this License to do so, and
-all its terms and conditions for copying, distributing or modifying
-the Library or works based on it.
-
-  10. Each time you redistribute the Library (or any work based on the
-Library), the recipient automatically receives a license from the
-original licensor to copy, distribute, link with or modify the Library
-subject to these terms and conditions.  You may not impose any further
-restrictions on the recipients' exercise of the rights granted herein.
-You are not responsible for enforcing compliance by third parties to
-this License.
-
-  11. If, as a consequence of a court judgment or allegation of patent
-infringement or for any other reason (not limited to patent issues),
-conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot
-distribute so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you
-may not distribute the Library at all.  For example, if a patent
-license would not permit royalty-free redistribution of the Library by
-all those who receive copies directly or indirectly through you, then
-the only way you could satisfy both it and this License would be to
-refrain entirely from distribution of the Library.
-
-If any portion of this section is held invalid or unenforceable under any
-particular circumstance, the balance of the section is intended to apply,
-and the section as a whole is intended to apply in other circumstances.
-
-It is not the purpose of this section to induce you to infringe any
-patents or other property right claims or to contest validity of any
-such claims; this section has the sole purpose of protecting the
-integrity of the free software distribution system which is
-implemented by public license practices.  Many people have made
-generous contributions to the wide range of software distributed
-through that system in reliance on consistent application of that
-system; it is up to the author/donor to decide if he or she is willing
-to distribute software through any other system and a licensee cannot
-impose that choice.
-
-This section is intended to make thoroughly clear what is believed to
-be a consequence of the rest of this License.
-
-  12. If the distribution and/or use of the Library is restricted in
-certain countries either by patents or by copyrighted interfaces, the
-original copyright holder who places the Library under this License may add
-an explicit geographical distribution limitation excluding those countries,
-so that distribution is permitted only in or among countries not thus
-excluded.  In such case, this License incorporates the limitation as if
-written in the body of this License.
-
-  13. The Free Software Foundation may publish revised and/or new
-versions of the Library General Public License from time to time.
-Such new versions will be similar in spirit to the present version,
-but may differ in detail to address new problems or concerns.
-
-Each version is given a distinguishing version number.  If the Library
-specifies a version number of this License which applies to it and
-"any later version", you have the option of following the terms and
-conditions either of that version or of any later version published by
-the Free Software Foundation.  If the Library does not specify a
-license version number, you may choose any version ever published by
-the Free Software Foundation.
-
-  14. If you wish to incorporate parts of the Library into other free
-programs whose distribution conditions are incompatible with these,
-write to the author to ask for permission.  For software which is
-copyrighted by the Free Software Foundation, write to the Free
-Software Foundation; we sometimes make exceptions for this.  Our
-decision will be guided by the two goals of preserving the free status
-of all derivatives of our free software and of promoting the sharing
-and reuse of software generally.
-
-			    NO WARRANTY
-
-  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
-WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
-EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
-OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
-KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
-LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
-THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
-
-  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
-WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
-AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
-FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
-CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
-LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
-RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
-FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
-SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
-DAMAGES.
-
-		     END OF TERMS AND CONDITIONS
-
-           How to Apply These Terms to Your New Libraries
-
-  If you develop a new library, and you want it to be of the greatest
-possible use to the public, we recommend making it free software that
-everyone can redistribute and change.  You can do so by permitting
-redistribution under these terms (or, alternatively, under the terms of the
-ordinary General Public License).
-
-  To apply these terms, attach the following notices to the library.  It is
-safest to attach them to the start of each source file to most effectively
-convey the exclusion of warranty; and each file should have at least the
-"copyright" line and a pointer to where the full notice is found.
-
-    <one line to give the library's name and a brief idea of what it does.>
-    Copyright (C) <year>  <name of author>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Library General Public
-    License as published by the Free Software Foundation; either
-    version 2 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Library General Public License for more details.
-
-    You should have received a copy of the GNU Library General Public
-    License along with this library; if not, write to the Free
-    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-
-Also add information on how to contact you by electronic and paper mail.
-
-You should also get your employer (if you work as a programmer) or your
-school, if any, to sign a "copyright disclaimer" for the library, if
-necessary.  Here is a sample; alter the names:
-
-  Yoyodyne, Inc., hereby disclaims all copyright interest in the
-  library `Frob' (a library for tweaking knobs) written by James Random Hacker.
-
-  <signature of Ty Coon>, 1 April 1990
-  Ty Coon, President of Vice
-
-That's all there is to it!
diff --git a/ChangeLog b/ChangeLog
deleted file mode 100644
index e69de29b..00000000
diff --git a/CodingStyle b/CodingStyle
deleted file mode 100644
index 962207de..00000000
--- a/CodingStyle
+++ /dev/null
@@ -1,101 +0,0 @@
-If you start a new file, you get to choose the style.
-If you change an existing file, follow the existing style.
-
-Hard tabs are OK, as long as you consider the tab stops to
-be every 8 characters. You can also use 2, 3, or 4 spaces.
-Tabs are kind of yucky, since cut-and-paste mangles them
-sometimes and they make "diff -Naurd old new" output less
-readable.
-
-Spaces within a line don't matter much, and won't be
-considered part of the style. Just make it readable:
-
-if(x){            // OK
-if( x ){           // OK
-if (x) {            // OK
-if(x==y && a==b){     // OK
-if(x == y && a == b){ // poor
-if(x==y&&a==b){       // poor
-
-This is evil:
-
-szWinStallman
-FoulCodingStyle (int iInsanity)
-  {
-     if (iInsanity)
-       {
-          GoHackEmacs () ;
-       }
-          else
-       {
-          SeekHelpForYourLisp () ;
-       }
-  }
-
-
-Curly braces belong at the end of a line. If you must, go ahead
-and make function bodies an exception to that rule. (as Linus does)
-
-Big fprintf() calls and similar go like this:
-
-fprintf(fd, "%d %d %d %d %d %d\n",
-  sdfsdf_sdfsdf + sdfs_iii,     // not an example of good names!
-  iijjij,
-  kjfkkj_sdfssss_sfff,
-  sdflkjfdskj + sdf - sfds,
-  jksss,
-  sfssss + wwwwfwfw
-);
-
-Keep these distinct: NULL, '\0', 0, 0.0
-
-Command-line parsers need to be bomb-proof. It is not acceptable
-to crash due to a messed up command-line. For an option "-x" that
-takes an argument, accept both "-x arg" and "-xarg". Remember to
-support "--" and "--version".
-
-Be extremely careful when handling data from other users.
-For example, it is a security hole if /proc/123/cmdline can
-overflow an array. It is often a security hole if you allow
-non-ASCII characters to be printed. Assuming the console is
-not in UTF-8 mode, all of these are bad: "\b\e\f\n\r\t\v\x9b".
-(the "\x9b" is valid in UTF-8 mode, but equivalent to "\e["
-when not in UTF-8 mode -- which gives control of terminal
-settings) It's best if you consider user-supplied data to
-be unsafe, since this makes for less work in case the code
-ends up needing to run setuid. Termcap data is user-supplied.
-Except for the above security issues, don't bother to check
-for something you can't handle... like printf() failing.
-It is expected that /dev exists and so on.
-
-Remember that a read() may return early, with partial data
-or with -1 and errno set to EINTR. You then must try again.
-
-char:      may be signed or unsigned by default
-int:       always 32-bit
-long long: always 64-bit
-pointer:   either 32-bit or 64-bit
-long:      same size as a pointer
-KLONG:     same size as a pointer or long IN THE KERNEL
-
-Functions used in just one file must be marked static.
-Use the "const" and "restrict" keywords wherever you can.
-
-Put main() at the bottom of a file so you don't need all
-those ugly forward declarations.
-
-Avoid the strcat() function. It is slow. For some odd
-reason, snprintf() is faster than sprintf().
-
-Reuse memory allocations when you can. When using realloc(),
-do your increments by more than one. 25% is a nice amount.
-
-Avoid compile-time choices. They make documentation difficult,
-and they are not friendly to binary distribution.
-
-Write programs that can handle a million processes without
-getting hopelessly slow. Allow for /proc/123/cmdline to
-be at least 128 kB.
-
-The LGPL license is strongly preferred. This allows use of
-the code in the library.
diff --git a/FAQ b/FAQ
deleted file mode 100644
index c68bf7bc..00000000
--- a/FAQ
+++ /dev/null
@@ -1,99 +0,0 @@
-Why does "ps -aux" complain about a bogus '-'?
-
-According to the POSIX and UNIX standards, the above command asks to display
-all processes with a TTY (generally the commands users are running) plus all
-processes owned by a user named "x". If that user doesn't exist, then ps will
-assume you really meant "ps aux". The warning is given to gently break you of a
-habit that will cause you trouble if a user named "x" were created.
-
-
-Why don't I see SMP (per-CPU) stats in top?
-
-You didn't enable it. Press '?' for built-in help or read the man page. Per-CPU
-stats are disabled by default because they take up too much space. Some Linux
-systems have hundreds of CPUs.
-
-
-Why do long usernames get printed as numbers?
-
-The UNIX and POSIX standards require that user names and group names be printed
-as decimal integers when there is not enough room in the column. Truncating the
-names, besides being a violation of the standard, would lead to confusion
-between names like MichelleRichards and MichelleRichardson. The UNIX and POSIX
-way to change column width is to rename the column:
-
-     ps -o pid,user=CumbersomeUserNames -o comm
-
-The easy way is to directly specify the desired width:
-
-     ps -o pid,user:19,comm
-
-
-Why is %CPU underreported for multi-threaded (Java, etc.) apps?
-
-You need to upgrade to the 2.6.10 kernel at least. Older kernels do not provide
-a reasonable way to get this information.
-
-
-Why do ps and top show threads individually?
-
-The 2.4.xx kernel does not provide proper support for grouping threads by
-process. Hacks exist to group them anyway, but such hacks will falsely group
-similar tasks and will fail to group tasks due to race conditions. The hacks
-are also slow. As none of this is acceptable in a critical system tool, task
-grouping is not currently available for the 2.4.xx kernel. The 2.6.xx kernel
-allows for proper thread grouping and reporting. To take advantage of this,
-your programs must use a threading library that features the CLONE_THREAD flag.
-The NPTL pthreads provided by recent glibc releases use CLONE_THREAD.
-
-
-What systems are supported?
-
-Linux 2.4.xx and 2.6.xx are commonly tested and expected to work well. SMP is
-well supported. Multi-node cluster views require a multi-node /proc filesystem;
-without that you will see a single-node view.
-
-
-Where to I send bug reports?
-
-You may use the Debian bug tracking system or send your report to
-procps@freelists.org (no subscription required) instead.
-
-
-Why are there so many procps projects?
-
-The original maintainer seems to have had little time for procps. Whatever his
-reasons, the project didn't get maintained. Starting in 1997, Albert Cahalan
-wrote a new ps program for the package. For the next few years, Albert quietly
-helped the Debian package maintainer fix bugs. In 2001, Rik van Riel decided to
-do something about what appeared to be the lack of a maintainer. He picked up
-the buggy old code in Red Hat's CVS and started adding patches. Meanwhile,
-other people have patched procps in a great many ways.
-
-In 2002, Albert moved procps to http://procps.sourceforge.net. This was done to
-ensure that years of testing and bug fixes would not be lost. The major version
-number was changed to 3, partly to avoid confusing users and partly because the
-top program had been redone.
-
-After development essentially stopped on sourceforge.net, in 2011 the project
-found a new home at http://gitorious.org/procps. This represents the Debian,
-Fedora and openSUSE fork of procps. To avoid confusion and potential name
-clashes the package is now known as procps-ng (next generation), the version
-number was raised to 3.3.0 and the library soname changed to libproc-ng-3.3.0.
-
-
-What is being done to procps-ng at its new home?
-
-All programs are in the process of being modernized, both in terms of coding
-style and supporting documentation. Autotools have been integrated and the
-library API has been expanded with many new fields supported such as control
-groups, supplementary groups, etc. The top program has been rewritten offering
-many new capabilities while providing performance improvements up to 300%.
-
-
-Why does ps get signal 17?
-
-No ps release has ever had this problem. Most likely your system has been
-broken into. You might want to install a more recent version of the OS. If
-you'd rather take your chances, simply upgrade procps.
-
diff --git a/Makefile.am b/Makefile.am
deleted file mode 100644
index 5338f532..00000000
--- a/Makefile.am
+++ /dev/null
@@ -1,77 +0,0 @@
-AM_CPPFLAGS = -include $(top_builddir)/config.h
-
-ACLOCAL_AMFLAGS = -I m4
-SUBDIRS = proc ps
-
-AM_CFLAGS = -Iproc
-AM_LDFLAGS = ./proc/libproc-ng.la
-
-sbin_PROGRAMS = \
-	sysctl
-
-usrbin_exec_PROGRAMS = \
-	free \
-	pgrep \
-	pkill \
-	pmap \
-	pwdx \
-	skill \
-	snice \
-	tload \
-	uptime \
-	vmstat \
-	w
-
-dist_man_MANS = \
-	free.1 \
-	pgrep.1 \
-	pkill.1 \
-	pmap.1 \
-	pwdx.1 \
-	skill.1 \
-	snice.1 \
-	sysctl.8 \
-	sysctl.conf.5 \
-	tload.1 \
-	uptime.1 \
-	vmstat.8 \
-	w.1
-
-if BUILD_KILL
-bin_PROGRAMS = kill
-dist_man_MANS += kill.1
-endif
-
-if WITH_NCURSES
-usrbin_exec_PROGRAMS += \
-	slabtop \
-	top \
-	watch
-top_SOURCES = top.c top.h
-dist_man_MANS += \
-	slabtop.1 \
-	top.1 \
-	watch.1
-slabtop_LDADD = @NCURSES_LIBS@
-top_LDADD = @NCURSES_LIBS@
-watch_LDADD = @NCURSES_LIBS@
-endif
-
-kill_SOURCES = skill.c
-snice_SOURCES = skill.c
-pkill_SOURCES = pgrep.c
-
-sysconf_DATA = sysctl.conf
-
-EXTRA_DIST = \
-	autogen.sh \
-	CodingStyle \
-	contrib/ \
-	COPYING.LIB \
-	$(sysconf_DATA)
-
-procpsngdir = $(docdir)
-dist_procpsng_DATA = \
-	BUGS \
-	FAQ \
-	README.top
diff --git a/NEWS b/NEWS
deleted file mode 100644
index d7169cce..00000000
--- a/NEWS
+++ /dev/null
@@ -1,427 +0,0 @@
-procps-3.2.8 --> procps-ng-3.3.0
-------------------------------------------------------
-Debian, Fedora and openSUSE fork of procps.
-https://gitorious.org/procps
-
-environment/build changes:
- . autotools integrated
- . procps-ng specific options
-     --enable-oomem  (add out-of-memory flds)
-     --disable-kill  (do not build kill pgm)
-     --enable-w-from (from as default for w)
-
-library changes:
- . added control groups support
- . added supplementary groups support
- . introduced proc_t memory management
- . enabled hot-plugged cpu support
- . introduced new api's
-     readeither   (readproc.c)
-     readproctab3 (readproc.c)
-     escaped_copy (escape.c)
-
-free changes:
- . rewritten/modernized
-     improved help
-     includes long options
-     added new processing options
- . updated manual page
-
-ps changes:
- . added new fields
-     cgroups,etimes,supgid,supgrp,tgid
- . exploited new library api's
-
-top changes:
- . redesigned fields management
- . added new fields
-     cgroups,gid,nmin,nth,pgrp,ruid,
-     sid,suid,supgids,supgrps,suser,
-     tgid,tpgid
- . added horizontal/vertical scrolling
- . added flexible output override via -w
- . added COMMAND column forest view via V
- . added hot-plugged cpu/memory support
- . improved user filtering via u|U
- . improved signal handling
- . restored zero delay functionality
- . introduced true line input editing
- . exploited new library api's
- . improved performance up to 300%
-
-Debian, Fedora and openSUSE fork of procps.
-https://gitorious.org/procps
-------------------------------------------------------
-
-procps-3.2.8 --> procps-3.2.9 (pending)
-
-top: fix an aliasing problem -- thanks David Owen
-
-procps-3.2.7 --> procps-3.2.8
-
-ps: allow "+" in sort specifications, as in man page     rh208217
-ps: recognize SCHED_ISO and SCHED_IDLE
-ps: document SCHED_BATCH and add a "see also" for stime
-ps: man page less ambiguous
-top: normal exit code should be 0     #341272 #354255 rh199174 suse493210
-top: misc fixes
-pgrep: usage error should exit with 2       #413383
-vmstat: use EXIT_FAILURE -- thanks Yoshio Nakamura   #425492
-sysctl: fix crash -- thanks Steinar Gunderson      #423704
-watch: tolerate umlauts                          #207103
-pmap: range limits with -A low,high
-update /dev/tty* info to May 2009 devices.txt
-don't read off end of string const                rh469495 rh498182
-
-procps-3.2.6 --> procps-3.2.7
-
-top: document H option -- thanks Tony Ernst
-top: terabytes -- thanks Tony Ernst
-top: CPU usage column width fixes -- thanks Tony Ernst
-top: *roff change                                   #326517
-ps: SCHED_BATCH is B
-ps: fix s format (signals) output with thread display
-watch: avoid integer overflow for the time delay
-pwdx: buffer overflow fixed -- thanks Ulf Harnhammar
-procps.spec needed a slash -- thanks Jesse Brandeburg
-w: stale utmp entries snuck in via uninitialized var -- thanks Robert A Basch
-pgrep/pkill: fix some realloc-related crashes       #353894
-pgrep/pkill: g is criteria (PLD Linux, patch found in locked filing cabinet)
-sysctl: use - for stdin (PLD Linux: beware of the leopard)
-top: show CPU time stolen from a virtual machine
-
-procps-3.2.5 --> procps-3.2.6
-
-vmstat: /proc/stat buffer big enough for 1024 CPUs
-dietlibc needs termios.h for struct winsize -- thanks Thomas Ogrisegg
-top: can do per-task display -- thanks John Blackwood     rh114012
-more MIPS crud  -- thanks Jim Gifford and Ryan Oliver
-begin prep for setuid
-top: fix %CPU max on 2..9 CPU SMP -- thanks Ga*tan LEURENT  rh110555
-ps: fix crash related to realloc -- thanks David Houlder
-ps: man page more detailed                         #334682
-spelling fixes                       #300333 #334684 #334685
-top: crash on resize fixed -- thanks Michal Maruska   #320289
-vmstat: -p handles /dev/ and does not overflow  #319523 #330969
-
-procps-3.2.4 --> procps-3.2.5
-
-display problem on 64-bit systems fixed   #287947
-top: variable-width PID and PPID
-top: variable-width %CPU                   rh110555
-sysctl: better error messages
-ps: security labels can contain any printable ASCII
-top: help and version message on stdout, with exit(0)    #283541
-ps: SIGTSTP and SIGTTOU shouldn't print bug email address    #246123
-slabtop: compile with glibc 2.2.17 (and older, likely)
-slabtop: fix overflow on huge NUMA boxes                #264640
-slabtop: accept any slabinfo 2.x format        g77301  #287691 rh145369 rh145906
-ps: alignment after WCHAN fixed                            ub5385
-pmap: when no -x or -d option, show full path        rh142751
-
-procps-3.2.3 --> procps-3.2.4
-
-support 64-bit MIPS with n32 binary
-sparc32 optimized for sparc32 again
-pwdx: new command -- thanks Nicholas Miell
-ps: UTF-8 username + command -- thanks Karel Zak rh134763,rh112518,rh134780
-ps: more room for some columns
-ps: tolerate SubDomain security module CONTEXT/LABEL data    #277401
-watch: passes COLUMNS and LINES in environment
-top: in batch mode, tolerate unknown $TERM -- thanks Daniel Walsh
-pkill: quiet about processes that die before kill()
-
-procps-3.2.2 --> procps-3.2.3
-
-avoid truncating long usernames
-avoid warning about -lncurses when not linking (more)
-new names for shared libraries (packagers: watch out!)
-"make install" no longer rebuilds everything
-wchan now '*' for multi-threaded processes
-ps: new man page -- thanks Nicolas Francois
-ps: STAT shows l for multi-threaded processes
-vmstat: some overflow problems fixed -- thanks Holger Kiehl
-sysctl: man page fix
-
-procps-3.2.1 --> procps-3.2.2
-
-new packager (downstream maintainer) guidelines in README
-move striping from install command to CFLAGS
-new gcc options in use: -fweb, -frename-registers, etc.
-avoid warning about -lncurses when not linking -- thanks FLWM
-tolerate IA-64 headers without PAGE_SIZE
-ps: k option, same as --sort
-ps: personality-specific -x support (HP-UX and SVR4-MP)
-pgrep: man page SEE ALSO updated                    #226817
-sysctl: -q and -N options
-sysctl: better error handling of failed writes
-top: tolerate sparse CPU numbering
-top: try to handle terminals lacking rmam and smam     #235003
-top: xterm dislikes clear-to-eol at eol (char lost)
-vmstat: fixed -d
-watch: allow sub-second intervals -- thanks Thomas Stewart
-
-procps-3.2.0 --> procps-3.2.1
-
-build even w/ curses in an odd location -- thanks to Segher Boessenkool
-ps: STAT flags for fg process group and session leader
-ps: STAT flags for swapped out process dropped (was broken)
-ps: new -M and Z options for security data (SE Linux, etc.)
-slabtop: detect broken /proc/slabinfo -- thanks to Fabian Frederick
-slabtop: ensure that error messages show up on the screen -- FF again
-
-procps-3.1.15 --> procps-3.2.0
-
-build on IA-64 again                            #227933
-pmap: output like Solaris 9, not Solaris 7
-ps: also handle SELinux on the 2.4.xx kernels
-top: during a ^Z, the terminal was messed up     #228822
-future-proof the tty handling   (thanks to Zhou Wei)
-slabtop  (Chris Rivera and Robert Love)          #226778
-pmap: detect the primary stack
-pmap: -d format
-free: report high and low memory
-
-procps-3.1.14 --> procps-3.1.15
-
-install to /lib64 if it exists
-hide kernel PID bug (Linux 2.4.13-pre1 to 2.4.MAX)   #217278 #219730 #217525 #224470
-ps: faster threaded display
-top: auto-margin problem                           #217559
-ps: support NSA SELinux, all builds, Linux 2.6+    #193648
-sysctl: tweak man page for ESR's broken parser
-
-procps-3.1.13 --> procps-3.1.14
-
-top: displays on more genuine serial terminals
-handle 32-bit dev_t of Linux 2.6
-ps: finally, m and -m satisfy the original design
-ps: distinct per-thread and whole-process pending signals
-
-procps-3.1.12 --> procps-3.1.13
-
-ps: can display NPTL threads w/ kernel patch
-no seLinux for now (new kernel interface)
-
-procps-3.1.11 --> procps-3.1.12
-
-ps: explicit width ("ps -o pid,wchan:42,args")
-ps: $PS_FORMAT works properly                    #201575
-top: new Linux 2.6.0-test4 CPU stats shown
-top: multiple -p options work again
-top: fixed 4 GB wrap-around
-ps: has a set of tests to ensure correctness
-man page: /var/run/utmp, not /etc/utmp           #206583
-required flags moved out of CFLAGS               #205429
-RPM generation handles /lib64
-WCHAN skips leading '.'
-vmstat: numerous new features
-
-procps-3.1.10 --> procps-3.1.11
-
-compile with gcc 2.95 again (C99 issue)
-
-procps-3.1.9 --> procps-3.1.10
-
-handle GPLONLY_ symbols                       #143549 #188374
-kill: better man page
-skill: better man page
-ps: PID-like columns change width as needed
-top: COMMAND instead of Command
-vmstat: -m displays slabinfo
-vmstat: -d displays disk stats
-
-procps-3.1.8 --> procps-3.1.9
-
-memory sizes fixed for 64-bit w/ gcc 3.x      #194376 #191933
-ps: detect broken OS install w/o /proc mounted        #172735
-top: fix suspend/resume behavior
-top: ditch warning until a GOOD interface is found    #188271
-kill: more info in the man page                       #182414
-ps: document the -o, o, -O, and O options             #169301
-vmstat: choose units you like: 1000, 1024, 1000000...
-
-procps-3.1.7 --> procps-3.1.8
-
-top: fix keyboard handling (help screen, etc.)
-
-procps-3.1.6 --> procps-3.1.7
-
-Makefile: made SKIP feature easier to use
-watch: --help now explains -t, --no-title    #182246
-ps: warning directs users to the FAQ
-top: batch mode can refresh by fractional seconds
-top: faster start-up
-top: do not refresh like crazy
-ps: better crash message
-
-procps-3.1.5 --> procps-3.1.6
-
-handle the 2.5.61 kernel
-top: memory leak fixed
-ps: new --ppid option selects by PPID
-watch: new --no-title option              #179862
-handle SPARC Linux badness
-rare crash fixed
-compile with gcc 2.91.xx again
-more informative "ps --info"
-README update
-ps: compare more with "ps -C verylongname"     #178127
-
-procps-3.1.4 --> procps-3.1.5
-
-ancient (2.x.xx era) data corruption fixed
-serious hidden-process problem (3.1.3+) fixed
-w: escape sequence vulnerability fixed
-
-procps-3.1.3 --> procps-3.1.4
-
-top: was trashing every "3" in a command name
-top: when killing a process, the PID was cut at a "3"
-top: more reliable %CPU
-update copyright dates (GPL & LGPL require this)
-RPM generation works now
-
-procps-3.1.2 --> procps-3.1.3
-
-uses /proc/*/wchan files when available
-top: user selection
-sysctl: add -e for Red Hat 8.0 boot scripts
-sysctl: the obvious --help, -V, and --version
-sysctl: some command line error checking
-w: stdout, not stderr -- thanks to Sander van Malssen
-
-procps-3.1.1 --> procps-3.1.2
-
-better RPM generation
-use C99 features
-some seLinux fixes
-now count Inact_laundry as needed  #172163
-ps: fewer globals
-ps: hardware-enforced buffer protection
-ps: 1 kB smaller
-top: B command added (for bold on/off)
-top: handle old (and future) config files
-top: man page tweak
-top: old sort keys     #167249
-top: out-of-bounds RT as "RT"
-top: several times faster
-top: t command fixed
-vmstat: -f
-vmstat: -s
-w: much faster
-watch: don't drop empty lines   #171005
-watch: re-indented
-
-procps-3.1.0 --> procps-3.1.1
-
-vmstat faster on 2.5.xx kernels
-vmstat header fixed
-vmstat -a re-fixed
-
-procps-3.0.5 --> procps-3.1.0
-
-vmstat displays IO-wait time instead of bogus "w"
-can build w/o shared library (set SHARED=0)
-when IO-wait hidden, count as idle, not as sys
-pmap command added (like Sun has)
-do not crash GNU make 3.79
-top slightly faster
-
-procps-3.0.4 --> procps-3.0.5
-
-top tolerates super-wide displays
-better (?) RPM generation
-XConsole and top.desktop removed
-old build system removed
-code cleanup
-pgrep and pkill get "-o" (oldest matching process)
-had vmstat "bi" and "bo" output interchanged on 2.5.xx
-fix man page tbl directives
-top man page cleaned up
-
-procps-3.0.3 --> procps-3.0.4
-
-make top go faster
-Linux 2.2.xx ELF note warning removed
-only show IO-wait on recent kernels
-fix top's SMP stats
-fix top for "dumb" and "vt510" terminals
-in top, limit the priority values to -99 ... 99
-
-procps-3.0.2 --> procps-3.0.3
-
-more "make install" fixes
-lib CFLAGS working again
-top.1 codes fixed
-bad (int*) cast in top removed
-top runs faster
-libproc memory corruption fixed
-rant moved out of top.1 man page
-ability to SKIP installing things
-fixed ps --sort crash
-
-procps-3.0.1 --> procps-3.0.2
-
-top defaults to the old layout
-top defaults to sorting by %CPU
-fix top for non-SMP 2.2.xx and 2.0.xx
-new "make install" fixed
-vmstat -a fixed
-vmstat compiles with latest gcc-3.x
-vmstat does 64-bit time
-
-procps-3.0.0 --> procps-3.0.1
-
-sysctl handles net/ipv4/conf/eth1.0123/tag (VLAN interface)
-sysctl handles net.ipv4.conf.eth1/0123.tag (VLAN interface)
-"ps" is now about 2x faster than in procps-2.x.x
-"ps -F" now documented
-w works in KOI8-R locale
-vmstat documentation update
-"skill -n blah blah blah" lets you test options
-simple "make && make install" now
-
-procps-2.x.x --> procps-3.0.0
-
-designed to support Linux 2.0 through 2.5.41 and beyond
-new top, with optional: color, windowing, SMP stats
-runs faster
-more "it crashes" bugs fixed
-top shows IO-wait time
-vmstat can show active/inactive memory stats
-real-time info supported in ps
-correct "ps -o size" and "ps --sort size"
-new maintainers
-reduced memory usage for ps
-allow large PIDs to be specified
-SELINUX support is just a recompile away
-the "F" column shrank, so "ps -l" has more command name room
-64-bit time reduces the overflow problem
-support S/390, IA-64 emulator, and user-mode Linux
-oldps is gone
-configure script -- use "make -f Makefile.noam" as a backup
-"w" program better at determining what a user is doing
-more stable
-code at http://procps.sf.net/ now (SourceForge)
-
-Earlier changes, for those not using Debian already:
-
-more stable
-runs faster
--F format option
-better error reporting in ps for unknown format specifiers
-BSD's sysctl options -b and -X
-top displays well on large-memory systems
-old BSD-style select-by-PID ("ps l$$")
-15-character user names
-ps 'f' ASCII art forest fixed
-add SIGSYS on i386
-top reports real RSS value
-large-memory systems work
-minimal ps program for embedded systems (minimal.c)
-BSD personality process selection fixed
-support locale (French) with ',' and '.' mixed up
-pgrep program
-includes the "kill" and "nice" programs
-don't chop non-tty ps output at 80 columns
diff --git a/README b/README
deleted file mode 100644
index 2ca616a4..00000000
--- a/README
+++ /dev/null
@@ -1,70 +0,0 @@
-COMPATIBILITY
-
-    This code is intended for use with Linux 2.2.xx, 2.4.xx,
-    2.6.xx, and hopefully all future kernels. You should be
-    running a system with libc 6, but libc 5 might work too.
-
-INSTALLATION
-
-    make
-    make install
-
-    Only the second ("make install") is needed if you just
-    want to build and install procps-ng in the normal way.
-
-    If you wish to test before installing, use the scripts
-    named t, v, and p to ensure that the correct libproc
-    (the new one) is used during your testing.
-
-    You may set SKIP to avoid building or installing things.
-    For example:
-
-    make SKIP='/bin/kill /usr/share/man/man1/kill.1' install
-
-    Use SHARED=0 to build procps-ng without shared libraries.
-    This may be useful for installing in your home directory.
-
-    make SHARED=0 DESTDIR=$HOME install
-
-    Suppose you wanted to install stuff in strange places.
-    You might do something like this:
-
-    make usr/bin=/tmp/Q/i/ DESTDIR=/tmp/Q install="install -D" ldconfig=echo install
-
-    If cross-compiling, you might need to set lib64 to
-    either "lib" or "lib64". You might need to set m64 to
-    -m64, -m32, or nothing at all. Some examples:
-
-    make lib64=lib m64=-m32      # for a bi-arch gcc
-    make lib64=lib64 CC=x86_64-gcc
-    make lib64=lib CC=alpha-gcc
-
-PACKAGING
-
-    If you are a downstream maintainer (packager) for a Linux distribution,
-    please avoid causing troubles. This section applies to you.
-
-    Send patches in regularly. Many patches made by vendors have been buggy,
-    some quite severely so. Sending in a patch will at least get it reviewed,
-    if not included. There is a procps-ng test suite that must be passed.
-    Forward all bug reports. If your bug database is public and busy enough
-    to bother with, please make this known. Follow Debian's lead in making
-    the bug database easy to comment on via email w/o need for an account.
-
-    Do not change the user interface. Many of the programs are intended to be
-    compatible with Solaris, FreeBSD, AIX, IRIX, Tru64, and the UNIX standard.
-    Your nice new command options WILL BE BROKEN as needed to ensure that
-    procps-ng remains compatible with the rest of the world. Sysadmins hate to
-    deal with incompatible behavior. If you need a new option, ask for it.
-
-    For normal packages, ensure that you do not add debugging flags
-    to the CFLAGS variable. If debugging flags are present, the Makefile
-    will avoid adding several optimizations that would interfere with gdb.
-
-    There should be no need to modify the Makefile. You can set variables
-    on the "make" command line or use "make -e" to pass variables from
-    the environment.
-
-BUG REPORTS
-
-    Email to procps@freelists.org.
diff --git a/README.top b/README.top
deleted file mode 100644
index b6c9142a..00000000
--- a/README.top
+++ /dev/null
@@ -1,328 +0,0 @@
-This file summarizes changes to the top program and supporting documentation
-introduced on March 31, 2011.
-
-Contents:
-      DOCUMENT Changes
-      INTERNAL Improvements
-      EXTERNAL Improvements
-      BUGS Previously Fixed and Preserved
-      BUGS Newly/Nearly Fixed
-      BUGS/WISH-LISTS That Should Go Bye-bye
-      BUGS FIXED You Didn't Know You Had
-      OTHER Changes, Hopefully They Won't Bite You
-      BENCHMARKS
-
-
-DOCUMENT Changes =========================================================
-  . The entire file was cleaned up, standardized and expanded to include:
-    - a new section "2. SUMMARY Display" added for symmetry with Fields
-    - nine new fields were added to section "3a. DESCRIPTIONS of Fields"
-    - a new section "3b. MANAGING Fields" replaced the obsolete section
-      "2b. SELECTING and ORDERING Columns"
-    - section "5c. SCROLLING a Window" was added for that new feature
-
-  . I don't know when the explanations for CODE and DATA were changed to
-    show 'virtual' memory, but I think there's a reason their alternate
-    names contain the word 'resident'.  Thus they were changed back to
-    say 'physical memory'.
-
-  . And as I indicated in a previous email, the former string identifier
-    'ME' was restored as were the 'h' key/command conventions (vs. <h>).
-
-    Oops, the 'h' key/command conventions remain restored, but subsequent
-    testing revealed problems with the .ME string identifier.  Thus, it was
-    changed to .WE (along with the companion .Me/.We id).
-
-  . Also previously mentioned, the 'man2html' program translates top.1 to
-    HTML with near perfect fidelity.  I take that to mean there should be
-    no problems with the top.1 source on most other platforms.
-
-    To further improve translation to HTML, several .Bd and .Ed macros
-    were added to preserve literal (fixed width) spacing.
-
-
-INTERNAL Improvements ====================================================
-  . The old restriction of 26 fields has been lifted.  With this new-top
-    100+ fields are now possible.  It currently supports up to 55, of
-    which 35 are in use.  Adding a new field is almost too easy.
-
-  . Task row construction has been considerably improved -- both from
-    a programming perspective and a performance perspective.
-
-  . The column highlighting costs for sort field visibility were
-    virtually eliminated.
-
-    An optional define (USE_X_COLHDR) can be enabled to completely
-    eliminate any costs associated with the 'x' command toggle.
-
-  . The management of the HST_t structures, used for %cpu calculations,
-    was optimized with a hashing scheme.  Thus the need for a qsort then
-    a binary search in each frame was completely eliminated.
-
-    An optional define can restore the former qsort/bsearch approach but
-    with an internal inlined binary search function offering substantially
-    better performance than the old top.
-
-  . This far more capable new-top executable is no larger than old top.
-
-  . The above combine to produce substantially improved performance
-    whose details are documented below under BENCHMARKS.
-
-
-EXTERNAL Improvements ====================================================
-  . Field management has been completely redesigned.  It's now embodied
-    on a single screen where display-ability, position and sort selection
-    can be handled in one place -- for all windows at one time!
-
-    This function is dependent on cursor motion keys and should a device
-    not have the customary arrow keys, alternatives are provided and
-    documented under "Operation" near the beginning of the man page.
-
-  . The following new fields have been added:
-       Group Id
-       Minor Page Faults
-       Number of Threads
-       Process Group Id
-       Real User Id
-       Saved User Id
-       Saved User Name
-       Session Id
-       Tty Process Group Id
-
-  . Scrolling keys now allow one to move the view of any window vertically
-    or horizontally to reveal any desired task or column.  Previously, only
-    some tasks were viewable even with reversible, selectable sort columns.
-
-    Each of the four windows is capable of maintaining its own scrolled
-    coordinates and an optional toggle ('C') displays a message aiding
-    navigation within the available tasks and displayable fields.
-
-  . User interactive line oriented input now provides for true line
-    editing supported by these new keys:
-        Left/Right arrow keys, Delete key, Backspace and
-        Home/End keys (likely limited to xterm, not terminal)
-
-  . User filtering via the -u | -U interactive commands is now window
-    based which means that different windows could be used to filter
-    different users.
-
-  . Signal handling has been normalized and is now consistent regardless
-    of the particular top screen a user may have been using.
-
-  . The 'i' toggle now shows any task that has used *some* cpu since the
-    last screen update.  It's no longer limited to just running tasks.
-
-  . The summary area 'task states' line now reflects either 'Threads'
-    or 'Tasks' depending on the -H toggle.
-
-
-BUGS Previously Fixed and Preserved ======================================
-  ( but not necessarily literally)
-  . 228822, suspending top leaves xterm in slightly messed-up state
-  . 256376, segfaults, if the xterm is to small
-  . 320289, segv on sigwinch
-  . 351065, wrong highlight 1st column (escape characters displayed)
-  . 358724, accepts extra numeric args
-  . 378695, seg fault if "/proc" is not mounted
-  . 426782, UID field is too narrow
-  . 458986, should check xterm for EOF/EIO
-  . 459890, Irix mode should use %#4.1f when threads shown
-
-
-BUGS Newly/Nearly Fixed ==================================================
-  . 225542, 'Unknown command' message blocks further commands
-      The message is now displayed using usleep for 1.25 seconds, instead
-      of the former full 2 seconds.  And while it still blocks further
-      commands, the delay is much more tolerable.
-
-      Can we consider this bug 'nearly' fixed?
-
-  . 410292, interface error when using backspace
-      Full line editing was added but could be disabled via a #define.
-      And via that define, even under basic termios support, the backspace
-      problem was cured.
-
-  . 567509, top idle command ('i') not working for threaded programs
-      Since the 'i' command now reflects tasks that have used *some* cpu,
-      and is no longer dependent on an 'R' state, I *believe/hope* this
-      bug has been swatted.
-
-
-BUGS/WISH-LISTS That Should Go Bye-bye ===================================
-  . 340751, wish for hostname to benefit multiple top sessions
-      Craig's suggestion regarding symlinks is the perfect solution.
-      How dare Craig say that the solution was "not ideal" !
-
-  . 586497, wish for graceful degradation on small screen sizes
-      This objective could be accomplished by setting up 2 symlinks for
-      top, personalizing them for the 2 tiny phone displays, then writing
-      the respective configuration files.
-
-      I shudder at the programming effort suggested by Paul.  And when it
-      was done you'd find everybody else would have different criteria.
-
-
-BUGS FIXED You Didn't Know You Had =======================================
-  . Without amplifying the dirty details, the long standing occasionally
-    reported display corruption, and an unreported source of performance
-    degradation, has been eliminated.  The cure is in the elimination of
-    the Pseudo_cols variable and the improved PUFF macro.
-
-  . Line oriented input was not sensitive to screen width.  Thus a user
-    could hold down any key and ultimately line wrap, overwriting the
-    columns header and the entire screen.  New top prevents this.
-
-  . User filtering (-u|-U) via a user ID (not name) now validates that
-    number.  The old-top just made sure it was numeric, then blindly
-    displayed no matching users (i.e. an empty window).
-
-  . The threads toggle ('H') is no longer window based but more properly
-    applies to all windows.  The previous implementation produced the
-    following aberration if multiple windows were being shown:
-      . -H would be acknowledged and applied to all visible windows
-      . keying 'a' or 'w' would silently turn it off
-      . then keying -H would turn it back on, but the user expected off
-
-  . If you hit ^Z on any help or fields screen to suspend old-top, after
-    issuing 'fg' you would then be left with a seemingly hung application
-    inviting ^C.  In truth, one could recover with the space bar, but that
-    was far from intuitive.
-
-  . The old-top consistently writes 1 extra byte for each task row or 1
-    byte too few for columns headers, depending on your perspective.
-    The new top writes the same number of bytes for each.
-
-  . By failing to clear to eol, old top left the display in a terrible
-    state after exiting a 'fields' screen when only a few columns were
-    being displayed.
-
-  . The old-top used a zero value for the L_NONE library flag which could
-    cause repeated rebuilding of columns headers with each frame.  In truth,
-    this was not likely to happen in real life since only two fields actually
-    used that flag.  However, if it did happen, performance could be degraded
-    by 800%.
-
-
-OTHER Changes, Hopefully They Won't Bite You =============================
-  . The undocumented TOPRC environment variable is no longer supported.
-    Any similar need can be met through a symlink alias.
-
-  . The use of environment variables to override terminal size is now
-    off by default but could be enabled through '#define TTYGETENVYES'.
-
-  . The global 'bold enable' toggle is active by default and thus agrees
-    with the documentation.  It's been wrong ever since Al's wholesale
-    'cosmetic' changes in procps-3.2.2.
-
-  . Task defaults now show bold (not reverse) and row highlighting.
-    This agrees with what was always stated in the documentation.
-
-  . The 'H' toggle (thread mode) is not persistent.  Persistence can be
-    achieved with a simple shell script employing the -H switch.
-
-  . Then 'g' and 'G' commands were reversed to reflect their likely use.
-
-
-BENCHMARKS ===============================================================
-  Tested as root with nice -10 and using only common fields
-   ( on a pretty old, slow laptop under Debian Lenny )
-  but rcfiles specified identical sort fields and identical
-  settings for the 'B', 'b', 'x' and 'y' toggles (even though
-  the defaults are not necessarily identical).
-
-  In every case new-top outperforms old-top, but I've shown %
-  improvements for only the most significant.  Those cases mostly
-  involve colors with both row & column highlighting.  I suggested
-  above that the highlighting cost was virtually eliminated in
-  new-top, and these tests bare that out.
-
-  Note the much smaller differences for new-top between the 24x80
-  window results and full screen (but don't mix apples_terminal
-  with oranges_xterm).  This is a reflection of the simplification
-  of task row construction, also mentioned above.
-
-  It's always been the case that any top in an xterm outperforms
-  that top under the terminal application, even when the xterm
-  provides additional rows and columns.  It's true below with
-  Gnome and it was true nine years ago under KDE.
-
-  ----------------------------------------------------------
-   The following comparisons were run with:
-      100 tasks & 160 threads
-      -d0 -n5000
-                                 new-top        old-top
-  xterm     24x80
- a  1 win,  lflgs_none         11.2 secs      51.8 secs    + 462.6%
-    1 win,  default            61.0 secs      66.8 secs
-    1 win,  colors w/ x+y      61.3 secs      83.0 secs    + 135.4%
-    1 win,  thread mode        88.3 secs      94.2 secs
- b  1 win,  every field on     99.7 secs     106.0 secs
-    1 win,  cmdline            71.2 secs      76.6 secs
-    4 wins, defaults          101.3 secs     107.2 secs
-    4 wins, colors w/ x+y     101.5 secs     122.8 secs    + 121.0%
-
-  xterm, full screen (53x170)
- a  1 win,  lflgs_none         15.9 secs      54.2 secs    + 340.9%
-    1 win,  default            70.0 secs      73.2 secs
-    1 win,  colors w/ x+y      69.4 secs     131.3 secs    + 189.2%
-    1 win,  thread mode        97.6 secs     102.6 secs
- c  1 win,  every field on    122.1 secs     128.1 secs
-    1 win,  cmdline            80.8 secs      83.7 secs
-    4 wins, defaults          111.4 secs     115.8 secs
-    4 wins, colors w/ x+y     112.0 secs     172.9 secs    + 154.4%
-
-  terminal  24x80
- a  1 win,  lflgs_none          8.9 secs      58.6 secs    + 658.4%
-    1 win,  default            70.1 secs      80.3 secs
-    1 win,  colors w/ x+y      70.6 secs     157.3 secs    + 222.8%
-    1 win,  thread mode       104.7 secs     120.5 secs
- b  1 win,  every field on    111.2 secs     134.5 secs
-    1 win,  cmdline            83.8 secs      94.5 secs
-    4 wins, defaults          125.6 secs     146.7 secs
-    4 wins, colors w/ x+y     125.6 secs     206.9 secs    + 176.7%
-
-  terminal, full screen (39x125)
- a  1 win,  lflgs_none          9.1 secs      60.6 secs    + 665.9%
-    1 win,  default            74.3 secs      88.0 secs
-    1 win,  colors w/ x+y      73.9 secs     314.5 secs    + 425.6%
-    1 win,  thread mode       113.0 secs     140.9 secs
- b  1 win,  every field on    117.7 secs     154.9 secs
-    1 win,  cmdline            87.4 secs     107.2 secs
-    4 wins, defaults          139.1 secs     166.7 secs
-    4 wins, colors w/ x+y     157.3 secs     423.2 secs    + 269.0%
-
-  ----------------------------------------------------------
-   The following comarisons were run with:
-      300 tasks & 360 threads
-      -d0 -n3000
-                                 new-top        old-top
-  xterm, full screen (53x170)
- a  1 win,  lflgs_none         14.3 secs      79.0 secs    + 552.4%
-    1 win,  default           101.1 secs     104.5 secs
-    1 win,  colors w/ x+y     101.3 secs     140.0 secs    + 138.2%
-    1 win,  thread mode       120.1 secs     123.1 secs
- c  1 win,  every field on    179.8 secs     185.6 secs
-    1 win,  cmdline           124.9 secs     132.8 secs
-    4 wins, defaults          174.8 secs     179.2 secs
-    4 wins, colors w/ x+y     175.0 secs     215.2 secs    + 123.0%
-
-  terminal, full screen (39x125)
- a  1 win,  lflgs_none         12.3 secs      98.5 secs    + 800.8%
-    1 win,  default           117.4 secs     134.0 secs
-    1 win,  colors w/ x+y     111.6 secs     296.1 secs    + 265.3%
-    1 win,  thread mode       141.3 secs     155.3 secs
- b  1 win,  every field on    197.7 secs     204.8 secs
-    1 win,  cmdline           143.9 secs     157.3 secs
-    4 wins, defaults          204.0 secs     226.2 secs
-    4 wins, colors w/ x+y     216.9 secs     434.5 secs    + 200.3%
-
-  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
-
-notes:
- a  these results represent the library flags L_NONE zero value and
-    thus the hidden cost of rebuilding column headers w/ every frame
- b  while every common field was turned on, not all fields could be
-    displayed due to limited screen width
- c  only in a full screen xterm window could all common fields
-    actually be displayed
-
diff --git a/TODO b/TODO
deleted file mode 100644
index 46ac1270..00000000
--- a/TODO
+++ /dev/null
@@ -1,151 +0,0 @@
--------------------------- general ------------------------
-
-Consider using glibc obstacks for memory allocation.
-
-Implement /usr/proc/bin tools like Solaris has.
-The prstat command is interesting, like top in batch mode.
-SCO has a pstat command.
-
-Don't these really belong in the procps-ng package?
-         killall pstree fuser lsof who
-(they are maintained elsewhere, which causes version problems)
-
-OpenBSD has a pfind command.
-
-Cache results of dev_to_tty.
-
----------------------- kernel -------------------------
-
-Add an "adopted child" flag to mark processes that are not
-natural children of init. This can make --forest work better.
-
-Supply better data for top's CPU state display. Currently top has
-to subtract old numbers from new numbers and divide that result by
-the number of processors. The kernel won't even supply the number
-of processors in a portable way.
-
-Supply data for the ADDR and JOBC fields.
-
-Support & supply data for SL and RE.
-
-Add a /proc/*/tty symlink to eliminate guessing when /proc/*/fd is
-not accessable.
-
-Add /proc/*/.bindata files to avoid string parsing. It should be an array
-of 64-bit values on all machines. New entries go on the end and obsolete
-ones get filled in with something logical -- entries must never be deleted!
-
-Add all the stuff Solaris has. This would also replace ptrace.
-
----------------------- watch --------------------------
-
-Tolerate UTF-8.
-
-Tolerate color, bold, underline, etc. #129334
-
-Tolerate stderr.  #420377 #155227 #225549
-
-Tolerate VT100 line-drawing characters. Maybe translate them.
-
----------------------- w --------------------------
-
-The LOGIN@ column sometimes has a space in it. This makes correct
-scripting difficult.
-
-Time formats are demented.
-
----------------------- vmstat --------------------------
-
-Extract /proc/diskstats parsing from vmstat into libproc somewhere.
-
---------------------- libproc ----------------------
-
-Stop storing fields with duplicate info (often different
-units: kB and pages, seconds and jiffies) in the proc_t struct.
-
-Use own readdir code (assembly language) because glibc sucks ass.
-
----------------------- top -------------------------
-
-Share more stuff with ps.
-
-don't truncate long usernames
-
-have a --config option
-
----------------- ps for now, maybe move to libproc ------------------
-
-With forest output and a tty named /dev/this_is_my_tty, the position
-of the command name gets messed up. (we print too many spaces) (fixed?)
-
-Fix missing stuff for these formats: FB_j FB_l FB_v HP_f HP_l HP_fl JFMT OL_m
-(jobc,cpu,sl,re,cpu,prmgrp,m_swap,m_share,vm_lib,m_dt)
-Note that "cpu" has two meanings.
-
-Add Beowulf support. This is ugly, since the current patches use a
-daemon to collect info and add a HOST field after the PID field.
-
-Query optimizer, put cheap/required process selection first.
-
-Avoid reading both /proc/*/status and /proc/*/stat.
-
-Support printing the client hostname (the FROM that w(1) uses) in place
-of a pty.
-
-Disambiguate narrow tty info. (/dev/tty7 == /dev/pts/7 now)
-1------8     1--4
-ttyS2        S2
-ttyI31       I31
-pts/7        7        Short form could be /999.
-pts/9999     9999     Short form could just be trunctuated to /999.
-tty7         7        Short form could be vc-7.
-tty63        63       Short form could be vc63.
-
-Internationalization, as specified by XPG3, Volume 1, Commands and Utilities.
-(and suggested by Unix98) LC_TIME affects date format.
-
------------------------ ps -----------------------
-
-Add an option to select all processes that a user can kill.
-(related to RUID, EUID, tty, etc. -- but maybe ignore root power)
-
-Add a nice display option for killing things.
-ruser,euser,ppid,pid,pmem,stime,args
-
-For RT stuff:
-pid,tid,class,rtprio,ni,pri,psr,pcpu,stat,wchan:14,comm
-
-For job control:
-stat,euid,ruid,tty,tpgid,sess,pgrp,ppid,pid,pcpu,comm
-
-Make the column alignment algorithm support this:
-    FOO BAR
-    8 44444
-    453  45
-    45 2989
-    63666 0
-    34  333
-(useful for the UNIX tty and time values, since the time might look
-like 100-10:40:32 for old processes and the tty might have extra room)
-
-Improve long sort/format specifiers documentation and fill in the missing
-code as much as the kernel can support. Make sure that memory amounts are in
-pages when they should be and in kB when they should be, not backwards.
-
-output encoding: UTF8 --nul --null
-
-Make BSD formats use non-standard BSD time format, at least when it
-doesn't violate the "no whitespace" rule.
-
-Better unmangling of '?' as a tty. The shell destroys '?' when there
-is a filename that matches. If the argument seems like garbage,
-check for a file that might have screwed up the '?'.
-
-If the 'O' option is given something already implied by 'O',
-assume the user wanted a sorting option.
-
-Conflict:
-Digital THREAD is user,pcpu,pri,scnt,wchan,usertime,systime
-AIX     THREAD is uname,pid,ppid,tid,S,C,PRI,scount,WCHAN,F,tty,bnd,comm
-AIX looks like this:
-         USER   PID  PPID  TID S  C PRI SC   WCHAN   FLAG   TTY BND  CMD
diff --git a/proc/alloc.c b/alloc.c
similarity index 100%
rename from proc/alloc.c
rename to alloc.c
diff --git a/proc/alloc.h b/alloc.h
similarity index 100%
rename from proc/alloc.h
rename to alloc.h
diff --git a/autogen.sh b/autogen.sh
deleted file mode 100755
index b42f57b6..00000000
--- a/autogen.sh
+++ /dev/null
@@ -1,65 +0,0 @@
-#!/bin/sh
-#
-# Helps generate autoconf/automake stuff, when code is checked
-# out from SCM.
-
-SRCDIR=$(dirname ${0})
-test -z "${SRCDIR}" && SRCDIR=.
-
-THEDIR=$(pwd)
-cd ${SRCDIR}
-DIE=0
-
-test -f top.c || {
-	echo "You must run this script in the top-level procps-ng directory"
-	DIE=1
-}
-
-(autoconf --version) < /dev/null > /dev/null || {
-	echo "You must have autoconf installed to generate procps-ng build system."
-	DIE=1
-}
-(autoheader --version) < /dev/null > /dev/null || {
-	echo "You must have autoheader installed to generate procps-ng build system."
-	echo "The autoheader command is part of the GNU autoconf package."
-	DIE=1
-}
-(libtool --version) < /dev/null > /dev/null || {
-	echo "You must have libtool-2 installed to generate procps-ng build system."
-	DIE=1
-}
-(automake --version) < /dev/null > /dev/null || {
-	echo "You must have automake installed to generate procps-ng build system."
-	DIE=1
-}
-
-LTVER=$(libtoolize --version | awk '/^libtoolize/ { print $4 }')
-LTVER=${LTVER:-"none"}
-test ${LTVER##2.} = "${LTVER}" && {
-	echo "You must have libtoolize version >= 2.x.x, but you have ${LTVER}."
-	DIE=1
-}
-
-if test ${DIE} -ne 0; then
-	exit 1
-fi
-
-echo "Generate build-system by:"
-echo "   aclocal:    $(aclocal --version | head -1)"
-echo "   autoconf:   $(autoconf --version | head -1)"
-echo "   autoheader: $(autoheader --version | head -1)"
-echo "   automake:   $(automake --version | head -1)"
-echo "   libtoolize: $(libtoolize --version | head -1)"
-
-rm -rf autom4te.cache
-
-set -e
-libtoolize --force ${LT_OPTS}
-aclocal -I m4 ${AL_OPTS}
-autoconf ${AC_OPTS}
-autoheader ${AH_OPTS}
-
-automake --add-missing ${AM_OPTS}
-
-echo
-echo "Now type '${SRCDIR}/configure' and 'make' to compile."
diff --git a/configure.ac b/configure.ac
deleted file mode 100644
index 58f8529a..00000000
--- a/configure.ac
+++ /dev/null
@@ -1,143 +0,0 @@
-#                                               -*- Autoconf -*-
-# Process this file with autoconf to produce a configure script.
-
-AC_PREREQ([2.64])
-AC_CONFIG_MACRO_DIR([m4])
-AC_INIT([procps-ng],
-	[3.3.0],
-	[procps@freelists.org],,[http://gitorious.org/procps])
-AM_INIT_AUTOMAKE
-AC_CONFIG_SRCDIR([top.c])
-AC_CONFIG_HEADERS([config.h])
-
-# Checks for programs.
-AC_GNU_SOURCE
-AC_PROG_CC
-AM_PROG_CC_C_O
-AC_PROG_INSTALL
-AC_PROG_LN_S
-
-# Checks for header files.
-AC_HEADER_MAJOR
-AC_CHECK_HEADERS([\
-	fcntl.h \
-	langinfo.h \
-	limits.h \
-	locale.h \
-	netinet/in.h \
-	stdlib.h \
-	string.h \
-	sys/file.h \
-	sys/ioctl.h \
-	sys/param.h \
-	sys/time.h \
-	termios.h \
-	unistd.h \
-	utmp.h \
-	values.h \
-	wchar.h \
-	wctype.h
-])
-
-# Checks for typedefs, structures, and compiler characteristics.
-AC_HEADER_STDBOOL
-AC_CHECK_MEMBERS([struct stat.st_rdev])
-AC_C_INLINE
-AC_C_RESTRICT
-AC_TYPE_PID_T
-AC_TYPE_SIZE_T
-AC_TYPE_SSIZE_T
-AC_TYPE_UID_T
-
-dnl libtool
-LT_INIT
-
-# Checks for library functions.
-AC_FUNC_ERROR_AT_LINE
-AC_FUNC_FORK
-AC_FUNC_MALLOC
-AC_FUNC_MBRTOWC
-AC_FUNC_MMAP
-AC_FUNC_REALLOC
-AC_FUNC_STRTOD
-AC_CHECK_FUNCS([\
-	alarm \
-	getpagesize \
-	gettimeofday \
-	iswprint \
-	memchr \
-	memmove \
-	memset \
-	munmap \
-	nl_langinfo \
-	putenv \
-	regcomp \
-	select \
-	setlocale \
-	strcasecmp \
-	strverscmp \
-	strchr \
-	strcspn \
-	strdup \
-	strerror \
-	strncasecmp \
-	strpbrk \
-	strrchr \
-	strspn \
-	strstr \
-	strtol \
-	strtoul \
-	uname \
-	utmpname \
-	wcwidth
-])
-
-AC_ARG_WITH([ncurses],
-  AS_HELP_STRING([--without-ncurses], [build only applications not needing ncurses]),
-  [with_ncurses=no], [with_ncurses=yes]
-)
-
-if test "x$with_ncurses" = xno; then
-  AM_CONDITIONAL(WITH_NCURSES, false)
-else
-  AC_CHECK_LIB(ncurses, initscr, [have_ncurses=yes], [have_ncurses=no])
-  AC_CHECK_HEADERS(curses.h ncurses.h, [], [have_ncurses=no], AC_INCLUDES_DEFAULT)
-  if test "x$have_ncurses" = xno; then
-    AC_MSG_ERROR([ncurses support missing/incomplete (for partial build use --without-ncurses)])
-  fi
-  AM_CONDITIONAL(WITH_NCURSES, true)
-  NCURSES_LIBS="-lncurses"
-fi
-AC_SUBST([NCURSES_LIBS])
-
-usrbin_execdir='${exec_prefix}/usr/bin'
-AC_SUBST([usrbin_execdir])
-
-AC_ARG_ENABLE([kill],
-  AS_HELP_STRING([--disable-kill], [do not build kill]),
-  [], enable_kill=yes
-)
-AM_CONDITIONAL(BUILD_KILL, test "x$enable_kill" = xyes)
-
-AC_ARG_ENABLE([oomem],
-  AS_HELP_STRING([--enable-oomem], [add out-of-memory fields to the library and top]),
-  [], enable_oomem=no
-)
-if test "x$enable_oomem" = xyes; then
-  AC_DEFINE(OOMEM_ENABLE, 1, [add out-of-memory fields to the library and top])
-fi
-
-AC_ARG_ENABLE([w-from],
-  AS_HELP_STRING([--enable-w-from], [enable w from field by default]),
-  [], enable_w_from=no
-)
-if test "x$enable_w_from" = xyes; then
-  AC_DEFINE(W_SHOWFROM, 1, [enable w from field by default])
-fi
-
-AC_CONFIG_FILES([
-Makefile
-proc/Makefile
-ps/Makefile
-])
-AC_OUTPUT
diff --git a/contrib/dummy.c b/contrib/dummy.c
deleted file mode 100644
index 95e78247..00000000
--- a/contrib/dummy.c
+++ /dev/null
@@ -1,31 +0,0 @@
-// This is to test the compiler.
-
-#include <sys/ioctl.h>
-#include <sys/resource.h>
-#include <sys/time.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <ctype.h>
-#include <curses.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <signal.h>
-#include <stdarg.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-// Foul POS defines all sorts of stuff...
-#include <term.h>
-#undef tab
-
-#include <termios.h>
-#include <time.h>
-#include <unistd.h>
-#include <values.h>
-
-int main(int argc, char *argv[]){
-  (void)argc;
-  (void)argv;
-  return 0;
-}
diff --git a/contrib/minimal.c b/contrib/minimal.c
deleted file mode 100644
index a38e4c79..00000000
--- a/contrib/minimal.c
+++ /dev/null
@@ -1,670 +0,0 @@
-/*
- * Copyright 1998,2004 by Albert Cahalan; all rights reserved.
- * This file may be used subject to the terms and conditions of the
- * GNU Library General Public License Version 2, or any later version
- * at your option, as published by the Free Software Foundation.
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Library General Public License for more details.
- */
-
-/* This is a minimal /bin/ps, designed to be smaller than the old ps
- * while still supporting some of the more important features of the
- * new ps. (for total size, note that this ps does not need libproc)
- * It is suitable for Linux-on-a-floppy systems only.
- *
- * Maintainers: do not compile or install for normal systems.
- * Anyone needing this will want to tweak their compiler anyway.
- */
-
-#include <pwd.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sys/ioctl.h>
-#include <sys/types.h>
-#include <unistd.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <dirent.h>
-
-
-#define DEV_ENCODE(M,m) ( \
-  ( (M&0xfff) << 8)   |   ( (m&0xfff00) << 12)   |   (m&0xff)   \
-)
-
-///////////////////////////////////////////////////////
-#ifdef __sun__
-#include <sys/mkdev.h>
-#define _STRUCTURED_PROC 1
-#include <sys/procfs.h>
-#define NO_TTY_VALUE DEV_ENCODE(-1,-1)
-#define HZ 1    // only bother with seconds
-#endif
-
-///////////////////////////////////////////////////////
-#ifdef __FreeBSD__
-#include <sys/param.h>
-#include <sys/sysctl.h>
-#include <sys/stat.h>
-#include <sys/proc.h>
-#include <sys/user.h>
-#define NO_TTY_VALUE DEV_ENCODE(-1,-1)
-#define HZ 1    // only bother with seconds
-#endif
-
-///////////////////////////////////////////////////////
-#ifdef __linux__
-#include <asm/param.h>  /* HZ */
-#include <asm/page.h>   /* PAGE_SIZE */
-#define NO_TTY_VALUE DEV_ENCODE(0,0)
-#ifndef HZ
-#warning HZ not defined, assuming it is 100
-#define HZ 100
-#endif
-#endif
-
-///////////////////////////////////////////////////////////
-
-#ifndef PAGE_SIZE
-#warning PAGE_SIZE not defined, assuming it is 4096
-#define PAGE_SIZE 4096
-#endif
-
-
-
-static char P_tty_text[16];
-static char P_cmd[16];
-static char P_state;
-static int P_euid;
-static int P_pid;
-static int P_ppid, P_pgrp, P_session, P_tty_num, P_tpgid;
-static unsigned long P_flags, P_min_flt, P_cmin_flt, P_maj_flt, P_cmaj_flt, P_utime, P_stime;
-static long P_cutime, P_cstime, P_priority, P_nice, P_timeout, P_alarm;
-static unsigned long P_start_time, P_vsize;
-static long P_rss;
-static unsigned long P_rss_rlim, P_start_code, P_end_code, P_start_stack, P_kstk_esp, P_kstk_eip;
-static unsigned P_signal, P_blocked, P_sigignore, P_sigcatch;
-static unsigned long P_wchan, P_nswap, P_cnswap;
-
-
-
-#if 0
-static int screen_cols = 80;
-static int w_count;
-#endif
-
-static int want_one_pid;
-static const char *want_one_command;
-static int select_notty;
-static int select_all;
-
-static int ps_format;
-static int old_h_option;
-
-/* we only pretend to support this */
-static int show_args;    /* implicit with -f and all BSD options */
-static int bsd_c_option; /* this option overrides the above */
-
-static int ps_argc;    /* global argc */
-static char **ps_argv; /* global argv */
-static int thisarg;    /* index into ps_argv */
-static char *flagptr;  /* current location in ps_argv[thisarg] */
-
-
-
-
-static void usage(void){
-  fprintf(stderr,
-    "-C   select by command name (minimal ps only accepts one)\n"
-    "-p   select by process ID (minimal ps only accepts one)\n"
-    "-e   all processes (same as ax)\n"
-    "a    all processes w/ tty, including other users\n"
-    "x    processes w/o controlling ttys\n"
-    "-f   full format\n"
-    "-j,j job control format\n"
-    "v    virtual memory format\n"
-    "-l,l long format\n"
-    "u    user-oriented format\n"
-    "-o   user-defined format (limited support, only \"ps -o pid=\")\n"
-    "h    no header\n"
-/*
-    "-A   all processes (same as ax)\n"
-    "c    true command name\n"
-    "-w,w wide output\n"
-*/
-  );
-  exit(1);
-}
-
-/*
- * Return the next argument, or call the usage function.
- * This handles both:   -oFOO   -o FOO
- */
-static const char *get_opt_arg(void){
-  const char *ret;
-  ret = flagptr+1;    /* assume argument is part of ps_argv[thisarg] */
-  if(*ret) return ret;
-  if(++thisarg >= ps_argc) usage();   /* there is nothing left */
-  /* argument is the new ps_argv[thisarg] */
-  ret = ps_argv[thisarg];
-  if(!ret || !*ret) usage();
-  return ret;
-}
-
-
-/* return the PID, or 0 if nothing good */
-static void parse_pid(const char *str){
-  char *endp;
-  int num;
-  if(!str)            goto bad;
-  num = strtol(str, &endp, 0);
-  if(*endp != '\0')   goto bad;
-  if(num<1)           goto bad;
-  if(want_one_pid)    goto bad;
-  want_one_pid = num;
-  return;
-bad:
-  usage();
-}
-
-/***************** parse SysV options, including Unix98  *****************/
-static void parse_sysv_option(void){
-  do{
-    switch(*flagptr){
-    /**** selection ****/
-    case 'C': /* end */
-      if(want_one_command) usage();
-      want_one_command = get_opt_arg();
-      return; /* can't have any more options */
-    case 'p': /* end */
-      parse_pid(get_opt_arg());
-      return; /* can't have any more options */
-    case 'A':
-    case 'e':
-      select_all++;
-      select_notty++;
-case 'w':    /* here for now, since the real one is not used */
-      break;
-    /**** output format ****/
-    case 'f':
-      show_args = 1;
-      /* FALL THROUGH */
-    case 'j':
-    case 'l':
-      if(ps_format) usage();
-      ps_format = *flagptr;
-      break;
-    case 'o': /* end */
-      /* We only support a limited form: "ps -o pid="  (yes, just "pid=") */
-      if(strcmp(get_opt_arg(),"pid=")) usage();
-      if(ps_format) usage();
-      ps_format = 'o';
-      old_h_option++;
-      return; /* can't have any more options */
-    /**** other stuff ****/
-#if 0
-    case 'w':
-      w_count++;
-      break;
-#endif
-    default:
-      usage();
-    } /* switch */
-  }while(*++flagptr);
-}
-
-/************************* parse BSD options **********************/
-static void parse_bsd_option(void){
-  do{
-    switch(*flagptr){
-    /**** selection ****/
-    case 'a':
-      select_all++;
-      break;
-    case 'x':
-      select_notty++;
-      break;
-    case 'p': /* end */
-      parse_pid(get_opt_arg());
-      return; /* can't have any more options */
-    /**** output format ****/
-    case 'j':
-    case 'l':
-    case 'u':
-    case 'v':
-      if(ps_format) usage();
-      ps_format = 0x80 | *flagptr;  /* use 0x80 to tell BSD from SysV */
-      break;
-    /**** other stuff ****/
-    case 'c':
-      bsd_c_option++;
-#if 0
-      break;
-#endif
-    case 'w':
-#if 0
-      w_count++;
-#endif
-      break;
-    case 'h':
-      old_h_option++;
-      break;
-    default:
-      usage();
-    } /* switch */
-  }while(*++flagptr);
-}
-
-#if 0
-#include <termios.h>
-/* not used yet */
-static void choose_dimensions(void){
-  struct winsize ws;
-  char *columns;
-  /* screen_cols is 80 by default */
-  if(ioctl(1, TIOCGWINSZ, &ws) != -1 && ws.ws_col>30) screen_cols = ws.ws_col;
-  columns = getenv("COLUMNS");
-  if(columns && *columns){
-    long t;
-    char *endptr;
-    t = strtol(columns, &endptr, 0);
-    if(!*endptr && (t>30) && (t<(long)999999999)) screen_cols = (int)t;
-  }
-  if(w_count && (screen_cols<132)) screen_cols=132;
-  if(w_count>1) screen_cols=999999999;
-}
-#endif
-
-static void arg_parse(int argc, char *argv[]){
-  int sel = 0;  /* to verify option sanity */
-  ps_argc = argc;
-  ps_argv = argv;
-  thisarg = 0;
-  /**** iterate over the args ****/
-  while(++thisarg < ps_argc){
-    flagptr = ps_argv[thisarg];
-    switch(*flagptr){
-    case '0' ... '9':
-      show_args = 1;
-      parse_pid(flagptr);
-      break;
-    case '-':
-      flagptr++;
-      parse_sysv_option();
-      break;
-    default:
-      show_args = 1;
-      parse_bsd_option();
-      break;
-    }
-  }
-  /**** sanity check and clean-up ****/
-  if(want_one_pid) sel++;
-  if(want_one_command) sel++;
-  if(select_notty || select_all) sel++;
-  if(sel>1 || select_notty>1 || select_all>1 || bsd_c_option>1 || old_h_option>1) usage();
-  if(bsd_c_option) show_args = 0;
-}
-
-#ifdef __sun__
-/* return 1 if it works, or 0 for failure */
-static int stat2proc(int pid) {
-    struct psinfo p;  //   /proc/*/psinfo, struct psinfo, psinfo_t
-    char buf[32];
-    int num;
-    int fd;
-    int tty_maj, tty_min;
-    snprintf(buf, sizeof buf, "/proc/%d/psinfo", pid);
-    if ( (fd = open(buf, O_RDONLY, 0) ) == -1 ) return 0;
-    num = read(fd, &p, sizeof p);
-    close(fd);
-    if(num != sizeof p) return 0;
-
-    num = PRFNSZ;
-    if (num >= sizeof P_cmd) num = sizeof P_cmd - 1;
-    memcpy(P_cmd, p.pr_fname, num);  // p.pr_fname or p.pr_lwp.pr_name
-    P_cmd[num] = '\0';
-
-    P_pid     = p.pr_pid;
-    P_ppid    = p.pr_ppid;
-    P_pgrp    = p.pr_pgid;
-    P_session = p.pr_sid;
-    P_euid    = p.pr_euid;
-    P_rss     = p.pr_rssize;
-    P_vsize   = p.pr_size;
-    P_start_time = p.pr_start.tv_sec;
-    P_wchan   = p.pr_lwp.pr_wchan;
-    P_state   = p.pr_lwp.pr_sname;
-    P_nice    = p.pr_lwp.pr_nice;
-    P_priority = p.pr_lwp.pr_pri;  // or pr_oldpri
-//    P_ruid    = p.pr_uid;
-//    P_rgid    = p.pr_gid;
-//    P_egid    = p.pr_egid;
-
-#if 0
-    // don't support these
-    P_tpgid; P_flags,
-    P_min_flt, P_cmin_flt, P_maj_flt, P_cmaj_flt, P_utime, P_stime;
-    P_cutime, P_cstime, P_timeout, P_alarm;
-    P_rss_rlim, P_start_code, P_end_code, P_start_stack, P_kstk_esp, P_kstk_eip;
-    P_signal, P_blocked, P_sigignore, P_sigcatch;
-    P_nswap, P_cnswap;
-#endif
-
-    // we like it Linux-encoded :-)
-    tty_maj = major(p.pr_ttydev);
-    tty_min = minor(p.pr_ttydev);
-    P_tty_num = DEV_ENCODE(tty_maj,tty_min);
-
-    snprintf(P_tty_text, sizeof P_tty_text, "%3d,%-3d", tty_maj, tty_min);
-#if 1
-    if (tty_maj == 24) snprintf(P_tty_text, sizeof P_tty_text, "pts/%-3u", tty_min);
-    if (P_tty_num == NO_TTY_VALUE)    memcpy(P_tty_text, "   ?   ", 8);
-    if (P_tty_num == DEV_ENCODE(0,0)) memcpy(P_tty_text, "console", 8);
-#endif
-
-    if(P_pid != pid) return 0;
-    return 1;
-}
-#endif
-
-#ifdef __FreeBSD__
-/* return 1 if it works, or 0 for failure */
-static int stat2proc(int pid) {
-    char buf[400];
-    int num;
-    int fd;
-    char* tmp;
-    int tty_maj, tty_min;
-    snprintf(buf, 32, "/proc/%d/status", pid);
-    if ( (fd = open(buf, O_RDONLY, 0) ) == -1 ) return 0;
-    num = read(fd, buf, sizeof buf - 1);
-    close(fd);
-    if(num<43) return 0;
-    buf[num] = '\0';
-
-    P_state = '-';
-
-    // FreeBSD /proc/*/status is seriously fucked. Unlike the Linux
-    // files, we can't use strrchr to find the end of a command name.
-    // Spaces in command names do not get escaped. To avoid spoofing,
-    // one may skip 20 characters and then look _forward_ only to
-    // find a pattern of entries that are {with,with,without} a comma.
-    // The entry without a comma is wchan. Then count backwards!
-    //
-    // Don't bother for now. FreeBSD isn't worth the trouble.
-
-    tmp = strchr(buf,' ');
-    num = tmp - buf;
-    if (num >= sizeof P_cmd) num = sizeof P_cmd - 1;
-    memcpy(P_cmd,buf,num);
-    P_cmd[num] = '\0';
-
-    num = sscanf(tmp+1,
-       "%d %d %d %d "
-       "%d,%d "
-       "%*s "
-       "%ld,%*d "
-       "%ld,%*d "
-       "%ld,%*d "
-       "%*s "
-       "%d %d ",
-       &P_pid, &P_ppid, &P_pgrp, &P_session,
-       &tty_maj, &tty_min,
-       /* SKIP funny flags thing */
-       &P_start_time, /* SKIP microseconds */
-       &P_utime, /* SKIP microseconds */
-       &P_stime, /* SKIP microseconds */
-       /* SKIP &P_wchan, for now -- it is a string */
-       &P_euid, &P_euid   // don't know which is which
-    );
-/*    fprintf(stderr, "stat2proc converted %d fields.\n",num); */
-
-    snprintf(P_tty_text, sizeof P_tty_text, "%3d,%-3d", tty_maj, tty_min);
-    P_tty_num = DEV_ENCODE(tty_maj,tty_min);
-// tty decode is 224 to 256 bytes on i386
-#if 1
-    tmp = NULL;
-    if (tty_maj ==  5) tmp = " ttyp%c ";
-    if (tty_maj == 12) tmp = " ttyv%c ";
-    if (tty_maj == 28) tmp = " ttyd%c ";
-    if (P_tty_num == NO_TTY_VALUE) tmp = "   ?   ";
-    if (P_tty_num == DEV_ENCODE(0,0)) tmp = "console";
-    if (P_tty_num == DEV_ENCODE(12,255)) tmp = "consolectl";
-    if (tmp) {
-      snprintf(
-        P_tty_text,
-        sizeof P_tty_text,
-        tmp,
-        "0123456789abcdefghijklmnopqrstuvwxyz"[tty_min&31]
-      );
-    }
-#endif
-
-    if(num < 9) return 0;
-    if(P_pid != pid) return 0;
-    return 1;
-}
-#endif
-
-#ifdef __linux__
-/* return 1 if it works, or 0 for failure */
-static int stat2proc(int pid) {
-    char buf[800]; /* about 40 fields, 64-bit decimal is about 20 chars */
-    int num;
-    int fd;
-    char* tmp;
-    struct stat sb; /* stat() used to get EUID */
-    snprintf(buf, 32, "/proc/%d/stat", pid);
-    if ( (fd = open(buf, O_RDONLY, 0) ) == -1 ) return 0;
-    num = read(fd, buf, sizeof buf - 1);
-    fstat(fd, &sb);
-    P_euid = sb.st_uid;
-    close(fd);
-    if(num<80) return 0;
-    buf[num] = '\0';
-    tmp = strrchr(buf, ')');      /* split into "PID (cmd" and "<rest>" */
-    *tmp = '\0';                  /* replace trailing ')' with NUL */
-    /* parse these two strings separately, skipping the leading "(". */
-    memset(P_cmd, 0, sizeof P_cmd);          /* clear */
-    sscanf(buf, "%d (%15c", &P_pid, P_cmd);  /* comm[16] in kernel */
-    num = sscanf(tmp + 2,                    /* skip space after ')' too */
-       "%c "
-       "%d %d %d %d %d "
-       "%lu %lu %lu %lu %lu %lu %lu "
-       "%ld %ld %ld %ld %ld %ld "
-       "%lu %lu "
-       "%ld "
-       "%lu %lu %lu %lu %lu %lu "
-       "%u %u %u %u " /* no use for RT signals */
-       "%lu %lu %lu",
-       &P_state,
-       &P_ppid, &P_pgrp, &P_session, &P_tty_num, &P_tpgid,
-       &P_flags, &P_min_flt, &P_cmin_flt, &P_maj_flt, &P_cmaj_flt, &P_utime, &P_stime,
-       &P_cutime, &P_cstime, &P_priority, &P_nice, &P_timeout, &P_alarm,
-       &P_start_time, &P_vsize,
-       &P_rss,
-       &P_rss_rlim, &P_start_code, &P_end_code, &P_start_stack, &P_kstk_esp, &P_kstk_eip,
-       &P_signal, &P_blocked, &P_sigignore, &P_sigcatch,
-       &P_wchan, &P_nswap, &P_cnswap
-    );
-/*    fprintf(stderr, "stat2proc converted %d fields.\n",num); */
-    P_vsize /= 1024;
-    P_rss *= (PAGE_SIZE/1024);
-
-    memcpy(P_tty_text, "   ?   ", 8);
-    if (P_tty_num != NO_TTY_VALUE) {
-      int tty_maj = (P_tty_num>>8)&0xfff;
-      int tty_min = (P_tty_num&0xff) | ((P_tty_num>>12)&0xfff00);
-      snprintf(P_tty_text, sizeof P_tty_text, "%3d,%-3d", tty_maj, tty_min);
-    }
-
-    if(num < 30) return 0;
-    if(P_pid != pid) return 0;
-    return 1;
-}
-#endif
-
-static const char *do_time(unsigned long t){
-  int hh,mm,ss;
-  static char buf[32];
-  int cnt = 0;
-  t /= HZ;
-  ss = t%60;
-  t /= 60;
-  mm = t%60;
-  t /= 60;
-  hh = t%24;
-  t /= 24;
-  if(t) cnt = snprintf(buf, sizeof buf, "%d-", (int)t);
-  snprintf(cnt + buf, sizeof(buf)-cnt, "%02d:%02d:%02d", hh, mm, ss);
-  return buf;
-}
-
-static const char *do_user(void){
-  static char buf[32];
-  static struct passwd *p;
-  static int lastuid = -1;
-  if(P_euid != lastuid){
-    p = getpwuid(P_euid);
-    if(p) snprintf(buf, sizeof buf, "%-8.8s", p->pw_name);
-    else  snprintf(buf, sizeof buf, "%5d   ", P_euid);
-  }
-  return buf;
-}
-
-static const char *do_cpu(int longform){
-  static char buf[8];
-  strcpy(buf," -  ");
-  if(!longform) buf[2] = '\0';
-  return buf;
-}
-
-static const char *do_mem(int longform){
-  static char buf[8];
-  strcpy(buf," -  ");
-  if(!longform) buf[2] = '\0';
-  return buf;
-}
-
-static const char *do_stime(void){
-  static char buf[32];
-  strcpy(buf,"  -  ");
-  return buf;
-}
-
-static void print_proc(void){
-  switch(ps_format){
-  case 0:
-    printf("%5d %s %s", P_pid, P_tty_text, do_time(P_utime+P_stime));
-    break;
-  case 'o':
-    printf("%d\n", P_pid);
-    return; /* don't want the command */
-  case 'l':
-    printf(
-      "0 %c %5d %5d %5d %s %3d %3d - "
-      "%5ld %06x %s %s",
-      P_state, P_euid, P_pid, P_ppid, do_cpu(0),
-      (int)P_priority, (int)P_nice, P_vsize/(PAGE_SIZE/1024),
-      (unsigned)(P_wchan&0xffffff), P_tty_text, do_time(P_utime+P_stime)
-    );
-    break;
-  case 'f':
-    printf(
-      "%8s %5d %5d %s %s %s %s",
-      do_user(), P_pid, P_ppid, do_cpu(0), do_stime(), P_tty_text, do_time(P_utime+P_stime)
-    );
-    break;
-  case 'j':
-    printf(
-      "%5d %5d %5d %s %s",
-      P_pid, P_pgrp, P_session, P_tty_text, do_time(P_utime+P_stime)
-    );
-    break;
-  case 'u'|0x80:
-    printf(
-      "%8s %5d %s %s %5ld %4ld %s %c %s %s",
-      do_user(), P_pid, do_cpu(1), do_mem(1), P_vsize, P_rss, P_tty_text, P_state,
-      do_stime(), do_time(P_utime+P_stime)
-    );
-    break;
-  case 'v'|0x80:
-    printf(
-      "%5d %s %c %s %6d   -   - %5d %s",
-      P_pid, P_tty_text, P_state, do_time(P_utime+P_stime), (int)P_maj_flt,
-      (int)P_rss, do_mem(1)
-    );
-    break;
-  case 'j'|0x80:
-    printf(
-      "%5d %5d %5d %5d %s %5d %c %5d %s",
-      P_ppid, P_pid, P_pgrp, P_session, P_tty_text, P_tpgid, P_state, P_euid, do_time(P_utime+P_stime)
-    );
-    break;
-  case 'l'|0x80:
-    printf(
-      "0 %5d %5d %5d %3d %3d "
-      "%5ld %4ld %06x %c %s %s",
-      P_euid, P_pid, P_ppid, (int)P_priority, (int)P_nice,
-      P_vsize, P_rss, (unsigned)(P_wchan&0xffffff), P_state, P_tty_text, do_time(P_utime+P_stime)
-    );
-    break;
-  default:
-    ;
-  }
-  if(show_args) printf(" [%s]\n", P_cmd);
-  else          printf(" %s\n", P_cmd);
-}
-
-
-int main(int argc, char *argv[]){
-  arg_parse(argc, argv);
-#if 0
-  choose_dimensions();
-#endif
-  if(!old_h_option){
-    const char *head;
-    switch(ps_format){
-    default: /* can't happen */
-    case 0:        head = "  PID TTY         TIME CMD"; break;
-    case 'l':      head = "F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN    TTY       TIME CMD"; break;
-    case 'f':      head = "USER       PID  PPID  C STIME   TTY       TIME CMD"; break;
-    case 'j':      head = "  PID  PGID   SID TTY         TIME CMD"; break;
-    case 'u'|0x80: head = "USER       PID %CPU %MEM   VSZ  RSS   TTY   S START     TIME COMMAND"; break;
-    case 'v'|0x80: head = "  PID   TTY   S     TIME  MAJFL TRS DRS   RSS %MEM COMMAND"; break;
-    case 'j'|0x80: head = " PPID   PID  PGID   SID   TTY   TPGID S   UID     TIME COMMAND"; break;
-    case 'l'|0x80: head = "F   UID   PID  PPID PRI  NI   VSZ  RSS WCHAN  S   TTY       TIME COMMAND"; break;
-    }
-    printf("%s\n",head);
-  }
-  if(want_one_pid){
-    if(stat2proc(want_one_pid)) print_proc();
-    else exit(1);
-  }else{
-    struct dirent *ent;          /* dirent handle */
-    DIR *dir;
-    int ouruid;
-    int found_a_proc;
-    found_a_proc = 0;
-    ouruid = getuid();
-    dir = opendir("/proc");
-    while(( ent = readdir(dir) )){
-      if(*ent->d_name<'0' || *ent->d_name>'9') continue;
-      if(!stat2proc(atoi(ent->d_name))) continue;
-      if(want_one_command){
-        if(strcmp(want_one_command,P_cmd)) continue;
-      }else{
-        if(!select_notty && P_tty_num==NO_TTY_VALUE) continue;
-        if(!select_all && P_euid!=ouruid) continue;
-      }
-      found_a_proc++;
-      print_proc();
-    }
-    closedir(dir);
-    exit(!found_a_proc);
-  }
-  return 0;
-}
diff --git a/contrib/response.filtered-with-patches.err b/contrib/response.filtered-with-patches.err
deleted file mode 100644
index 6d235e0a..00000000
--- a/contrib/response.filtered-with-patches.err
+++ /dev/null
@@ -1,312 +0,0 @@
-See http://www.freelists.org/post/procps/Scan-results,5
-
-
-	based on:
-filtered-with-patches.err
-
-	these are the categories i've assigned:
-defect_was_fixed
-	EVALUATION_ORDER
-		pmap
-	TAINTED_STRING
-		tload
-
-possibly_filter_out_?
-	MISSING_BREAK
-		slabtop
-		ps/output
-
-avoidable_false_positive
-	DEADCODE
-		proc/readproc
-	FORWARD_NULL
-		top
-		vmstat
-	RESOURCE_LEAK
-		ps/parser (3)
-	STRING_NULL
-		pwdx
-		proc/readproc
-	TAINTED_SCALAR
-		pgrep
-		slabtop
-		top (3)
-	TAINTED_STRING
-		watch (2)
-	TOCTOU
-		sysctl (2)
-	UNINIT
-		ps/output (2)
-
-unavoidable_false_positive_?
-	UNREACHABLE
-		ps/sortformat
-
-unavoidable_false_positive_but_patched_anyway
-	OVERRUN_STATIC
-		top (no defect, but i yield)
-
-
-
-	pgrep ------------------------------------------------------------------------
-Error: TAINTED_SCALAR:
-	agree that argv might be tainted
-	but the (int)argv[1][1] index is being passed to isdigit() function (and glibc safely indexes into array sized at 384 bytes)
-	my_category: avoidable_false_positive (out of step with current glibc implementation)
-pgrep.c:720: tainted_data: Passing tainted variable "argv" to a tainted sink.
-pgrep.c:558: data_index: Using tainted variable "(int)argv[1][1]" as an index to pointer "*__ctype_b_loc()".
-
-
-	pmap -------------------------------------------------------------------------
-Error: EVALUATION_ORDER:
-	agree that there is a problem.
-	moreover, it deals with an undocumented command line argument (but sami has documentation addition pending)
-	the logic was altered in line with intent, hopefully avoids this warning
-	my_category: defect_was_fixed
-pmap.c:314: write_write_order: In "arg2 = (arg2 ? arg2++ : arg1)", "arg2" is written in "arg2" (the assignment left-hand side) and written in "arg2 ? arg2++ : arg1" but the order in which the side effects take place is undefined because there is no intervening sequence point.
-
-
-
-	pwdx -------------------------------------------------------------------------
-Error: STRING_NULL:
-	static buffer is initialized to 0
-	it is +1 larger than size passed to readlink
-	was fixed in previous analysis
-	my_category: avoidable_false_positive
-pwdx.c:86: string_null_argument: Function "readlink" does not terminate string "*buf".
-pwdx.c:73: var_assign_var: Assigning: "s" = "buf". Both now point to the same unterminated string.
-pwdx.c:73: var_assign_var: Assigning: "s" = "buf". Both now point to the same unterminated string.
-pwdx.c:73: var_assign_var: Assigning: "s" = "buf". Both now point to the same unterminated string.
-pwdx.c:92: string_null: Passing unterminated string "s" to "printf".
-
-
-
-	slabtop ----------------------------------------------------------------------
-Error: MISSING_BREAK:
-	intentional fall through after setting return code
-	no change made
-	my_category: possibly_filter_out_?
-slabtop.c:314: unterminated_case: This case (value 104) is not terminated by a 'break' statement.
-slabtop.c:316: fallthrough: The above case falls through to this one.
-
-Error: TAINTED_SCALAR:
-	read limited to single byte signed 'char'
-	ultimately passed to toupper() function (and glibc safely indexes into array sized at 384 bytes)
-	my_category: avoidable_false_positive (out of step with current glibc implementation)
-slabtop.c:387: tainted_data_argument: Calling function "read" taints argument "c".
-slabtop.c:389: tainted_data: Passing tainted variable "c" to a tainted sink.
-slabtop.c:233: data_index: Using tainted variable "(int)c" as an index to pointer "*__ctype_toupper_loc()".
-
-
-
-	sysctl -----------------------------------------------------------------------
-Error: TOCTOU:
-	the pathlength between these two events cannot be reduced further
-	instead of assessing intervening lines of code, perhaps tool should assess 'if' statements (2)
-	my_category: avoidable_false_positive
-sysctl.c:149: fs_check_call: Calling function "stat" to perform check on "tmpname".
-sysctl.c:168: toctou: Calling function "fopen" that uses "tmpname" after a check function. This can cause a time-of-check, time-of-use race condition.
-
-Error: TOCTOU:
-	the pathlength between these two events cannot be reduced further
-	instead of assessing intervening lines of code, perhaps tool should assess 'if' statements (2)
-	my_category: avoidable_false_positive
-sysctl.c:327: fs_check_call: Calling function "stat" to perform check on "tmpname".
-sysctl.c:345: toctou: Calling function "fopen" that uses "tmpname" after a check function. This can cause a time-of-check, time-of-use race condition.
-
-
-
-	tload ------------------------------------------------------------------------
-Error: TAINTED_STRING:
-	altered perror call to provide an untainted string
-	my_category: defect_was_fixed
-tload.c:89: tainted_string: Passing tainted string "argv[optind]" to a function that cannot accept tainted data.
-
-
-
-	top --------------------------------------------------------------------------
-Error: FORWARD_NULL:
-	cpus cannot be NULL without fp also being NULL
-	the very next 'if (!fp)' ensures cpus will be allocated
-	my_category: avoidable_false_positive
-top.c:1790: assign_zero: Assigning: "cpus" = 0.
-top.c:1807: var_deref_op: Dereferencing null variable "cpus".
-
-Error: OVERRUN_STATIC:
-	This "error" is centered around the following code:
-	      f = w->pflgsall[i + w->begpflg];
-	      w->procflgs[i] = f;
-	   #ifndef USE_X_COLHDR
-	      if (P_MAXPFLGS < f) continue;
-	   #endif
-	      h = Fieldstab[f].head;
-
-	The enum P_MAXPFLGS is strictly a fencepost and can *never* appear in the arrays pflgsall or procflgs.
-	Thus it (39th element) cannot be used in referencing Fieldstab.
-	However, two enums of higher value (X_XON=40 and X_XOF=41) *can* appear in those arrays.
-	But the test against the fencepost ensures that those two enums are *never* used in referencing Fieldstab.
-	
-	When the analyzer sees the conditional using '<' and not '<=' it reports a false positive.
-	
-	i'm tired of explaining this so the program was changed to accommodate the tool's deficiency
-	my_category: unavoidable_false_positive_but_patched_anyway
-top.c:1417: overrun-local: Overrunning static array "Fieldstab", with 39 elements, at position 39 with index variable "f".
-
-Error: TAINTED_SCALAR:
-	the index is used subordinate to a case statement ensuring a value between '1' and '4'
-	my_category: avoidable_false_positive
-top.c:2442: tainted_data_argument: Calling function "chin" taints argument "ch".
-top.c:848: tainted_data_argument: Calling function "read" taints parameter "*buf".
-top.c:2452: tainted_data: Using tainted variable "ch - 49" as an index into an array "Winstk".
-
-Error: TAINTED_SCALAR:
-	the index is used subordinate to as case statement ensuring a value between '1' and '4'
-	my_category: avoidable_false_positive
-top.c:2719: tainted_data_argument: Calling function "chin" taints argument "ch".
-top.c:848: tainted_data_argument: Calling function "read" taints parameter "*buf".
-top.c:2720: tainted_data: Passing tainted variable "ch" to a tainted sink.
-top.c:2452: data_index: Using tainted variable "ch - 49" as an index to array "Winstk".
-
-Error: TAINTED_SCALAR:
-	buf tainted by chin is zero terminated
-	single char is ultimately passed to isprintf() function (and glibc safely indexes into array sized at 384 bytes)
-	my_category: avoidable_false_positive (out of step with current glibc implementation)
-top.c:972: tainted_data_return: Function "keyin" returns tainted data.
-top.c:912: tainted_data_argument: Function "chin" taints argument "buf".
-top.c:848: tainted_data_argument: Calling function "read" taints parameter "*buf".
-top.c:926: return_tainted_data: Returning tainted variable "buf[0]".
-top.c:972: var_assign: Assigning: "key" = "keyin", which taints "key".
-top.c:1001: tainted_data: Using tainted variable "(int)key" as an index to pointer "*__ctype_b_loc()".
-
-
-
-	vmstat -----------------------------------------------------------------------
-Error: FORWARD_NULL:
-	partition made non-null with optarg for -p where statMode |= PARTITIONSTAT
-	if no optarg then program exits with usage
-	thus call to diskpartition_format will be with non-null pointer
-	my_category: avoidable_false_positive
-vmstat.c:593: assign_zero: Assigning: "partition" = 0.
-vmstat.c:669: var_deref_model: Passing null variable "partition" to function "diskpartition_format", which dereferences it.
-vmstat.c:301: deref_parm_in_call: Function "strcmp" dereferences parameter "partition_name". (The dereference is assumed on the basis of the 'nonnull' parameter attribute.)
-
-
-
-	watch ------------------------------------------------------------------------
-Error: TAINTED_STRING:
-	even though the environment variable COLUMNS might begin tainted, from my analysis, the tool is totally mistaken
-	strtol actually untaints data in the form of 't' and 'endptr' then the environment variable COLUMNS is potentially purified with -1
-	my_category: avoidable_false_positive
-watch.c:95: tainted_string_return_content: "getenv" returns tainted string content.
-watch.c:95: var_assign: Assigning: "s" = "getenv("COLUMNS")", which taints "s".
-watch.c:100: tainted_data_transitive: Call to function "strtol" with tainted argument "s" returns tainted data.
-watch.c:100: var_assign: Assigning: "t" = "strtol(s, &endptr, 0)", which taints "t".
-watch.c:101: var_assign_var: Assigning: "incoming_cols" = "(int)t". Both are now tainted.
-watch.c:102: var_assign_var: Assigning: "width" = "incoming_cols". Both are now tainted.
-watch.c:103: vararg_transitive: Call to "snprintf" with tainted argument "width" taints "env_col_buf".
-watch.c:104: tainted_string: Passing tainted string "env_col_buf" to a function that cannot accept tainted data.
-
-Error: TAINTED_STRING:
-	even though the environment variable LINES might begin tainted, from my analysis, the tool is totally mistaken
-	strtol actually untaints data in the form of 't' and 'endptr' then the environment variable LINES is potentially purified with -1
-	my_category: avoidable_false_positive
-watch.c:108: tainted_string_return_content: "getenv" returns tainted string content.
-watch.c:108: var_assign: Assigning: "s" = "getenv("LINES")", which taints "s".
-watch.c:113: tainted_data_transitive: Call to function "strtol" with tainted argument "s" returns tainted data.
-watch.c:113: var_assign: Assigning: "t" = "strtol(s, &endptr, 0)", which taints "t".
-watch.c:114: var_assign_var: Assigning: "incoming_rows" = "(int)t". Both are now tainted.
-watch.c:115: var_assign_var: Assigning: "height" = "incoming_rows". Both are now tainted.
-watch.c:116: vararg_transitive: Call to "snprintf" with tainted argument "height" taints "env_row_buf".
-watch.c:117: tainted_string: Passing tainted string "env_row_buf" to a function that cannot accept tainted data.
-
-
-
-	proc/readproc ----------------------------------------------------------------
-Error: DEADCODE:
-	the tool does not understand gperf and the pseudo case labels preceded by goto
-	the following code snippets illustrate the deficiency:
-	   goto *(&&base + entry.offset);
-	      ...
-	   case_Threads:
-	     Threads = strtol(S,&S,10);
-	     continue;
-	my_category: avoidable_false_positive
-proc/readproc.c:387: dead_error_condition: On this path, the condition "Threads" cannot be true.
-proc/readproc.c:115: const: After this line, the value of "Threads" is equal to 0.
-proc/readproc.c:115: assignment: Assigning: "Threads" = "0L".
-proc/readproc.c:388: dead_error_begin: Execution cannot reach this statement "P->nlwp = Threads;".
-
-Error: STRING_NULL:
-	read is asked to retrieve -1 bytes than passed capacity:  num_read = read(fd, ret, cap - 1);
-	file2str does indeed null terminate sbuf:                 ret[num_read] = '\0';
-	my_category: avoidable_false_positive
-proc/readproc.c:1193: string_null_argument: Function "file2str" does not terminate string "*sbuf".
-proc/readproc.c:514: string_null_argument: Function "read" fills array "*ret" with a non-terminated string.
-proc/readproc.c:1197: string_null: Passing unterminated string "sbuf" to a function expecting a null-terminated string.
-proc/readproc.c:447: string_null_sink_parm_call: Passing parameter "S" to "strchr" which expects a null-terminated string.
-
-
-
-	ps/output --------------------------------------------------------------------
-Error: MISSING_BREAK:
-	intentional fall through
-	my_category: possibly_filter_out_?
-ps/output.c:1983: unterminated_default: The default case is not terminated by a 'break' statement.
-ps/output.c:1984: fallthrough: The above case falls through to this one.
-
-Error: UNINIT:
-	the first member is initialized in the very next statement, sufficient for bsearch callback
-	   key.spec = findme;
-	my_category: avoidable_false_positive
-ps/output.c:1737: var_decl: Declaring variable "key" without initializer.
-ps/output.c:1739: uninit_use_in_call: Using uninitialized value "key": field "key".flags is uninitialized when calling "bsearch".
-
-Error: UNINIT:
-	the first member is initialized in the very next statement, sufficient for bsearch callback
-	   key.spec = findme;
-	my_category: avoidable_false_positive
-ps/output.c:1745: var_decl: Declaring variable "key" without initializer.
-ps/output.c:1747: uninit_use_in_call: Using uninitialized value "key": field "key".head is uninitialized when calling "bsearch".
-
-
-
-	ps/parser --------------------------------------------------------------------
-Error: RESOURCE_LEAK:
-	intentional omission
-	abexit shortly
-	my_category: avoidable_false_positive
-ps/parser.c:1021: alloc_fn: Calling allocation function "malloc".
-ps/parser.c:1021: var_assign: Assigning: "pidnode" =  storage returned from "malloc(sizeof (selection_node) /*24*/)".
-ps/parser.c:1041: leaked_storage: Variable "pidnode" going out of scope leaks the storage it points to.
-ps/parser.c:1062: leaked_storage: Variable "pidnode" going out of scope leaks the storage it points to.
-
-Error: RESOURCE_LEAK:
-	intentional omission
-	abexit shortly
-	my_category: avoidable_false_positive
-ps/parser.c:1025: alloc_fn: Calling allocation function "malloc".
-ps/parser.c:1025: var_assign: Assigning: "grpnode" =  storage returned from "malloc(sizeof (selection_node) /*24*/)".
-ps/parser.c:1041: leaked_storage: Variable "grpnode" going out of scope leaks the storage it points to.
-ps/parser.c:1062: leaked_storage: Variable "grpnode" going out of scope leaks the storage it points to.
-
-Error: RESOURCE_LEAK:
-	intentional omission
-	abexit shortly
-	my_category: avoidable_false_positive
-ps/parser.c:1029: alloc_fn: Calling allocation function "malloc".
-ps/parser.c:1029: var_assign: Assigning: "sidnode" =  storage returned from "malloc(sizeof (selection_node) /*24*/)".
-ps/parser.c:1041: leaked_storage: Variable "sidnode" going out of scope leaks the storage it points to.
-ps/parser.c:1062: leaked_storage: Variable "sidnode" going out of scope leaks the storage it points to.
-
-
-
-	ps/sortformat ----------------------------------------------------------------
-Error: UNREACHABLE:
-	the tool does not understand the following 'label' usage (nor do i - perhaps some obscure compiler/platform warning/quirk)
-	   goto unknown;
-	      ...
-	   if(0) unknown:  err=errbuf;
-	my_category: unavoidable_false_positive_?
-ps/sortformat.c:312: unreachable: This code cannot be reached: "if (0){
-  unknown:
-  err = ...".
diff --git a/contrib/tmp-junk.c b/contrib/tmp-junk.c
deleted file mode 100644
index db011b17..00000000
--- a/contrib/tmp-junk.c
+++ /dev/null
@@ -1,730 +0,0 @@
-/*
- * w.c  v1.4
- *
- * An alternative "w" program for Linux.
- * Shows users and their processes.
- *
- * Copyright (c) Dec 1993, Oct 1994 Steve "Mr. Bassman" Bryant
- * 		bassman@hpbbi30.bbn.hp.com (Old address)
- *		bassman@muttley.soc.staffs.ac.uk
- *
- * Info:
- *	I starting writing as an improvement of the w program included
- * with linux. The idea was to add in some extra functionality to the
- * program, and see if I could fix a couple of bugs which seemed to
- * occur.
- *						Mr. Bassman, 10/94
- *
- * Acknowledgments:
- *
- * The original version of w:
- *	Copyright (c) 1993 Larry Greenfield  (greenfie@gauss.rutgers.edu)
- *
- * Uptime routine and w mods:
- *	Michael K. Johnson  (johnsonm@stolaf.edu)
- *
- *
- * Distribution:
- *	This program is freely distributable under the terms of copyleft.
- *	No warranty, no support, use at your own risk etc.
- *
- * Compilation:
- *	gcc -O -o w sysinfo.c whattime.c w.c
- *
- * Usage:
- *	w [-hfusd] [user]
- *
- *
- * $Log: tmp-junk.c,v $
- * Revision 1.1  2002/02/01 22:46:37  csmall
- * Initial revision
- *
- * Revision 1.5  1994/10/26  17:57:35  bassman
- * Loads of stuff - see comments.
- *
- * Revision 1.4  1994/01/01  12:57:21  johnsonm
- * Added RCS, and some other fixes.
- *
- * Revision history:
- * Jan 01, 1994 (mkj):	Eliminated GCC warnings, took out unnecessary
- *			dead variables in fscanf, replacing them with
- *			*'d format qualifiers.  Also added RCS stuff.
- * Oct 26, 1994 (bass):	Tidied up the code, fixed bug involving corrupt
- *			utmp records.  Added switch for From field;
- *			default is compile-time set.  Added -d option
- *			as a remnant from BSD 'w'.  Fixed bug so it now
- *			behaves if the first process on a tty isn't owned
- *			by the person first logged in on that tty, and
- *			also detects su'd users.  Changed the tty format
- *			to the short one.
- */
-
-#include <stdio.h>
-#include <string.h>
-#include <stdlib.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <sys/ioctl.h>
-#include <time.h>
-#include <utmp.h>
-#include <unistd.h>
-#include <errno.h>
-#include <pwd.h>
-#include "proc/whattime.h"
-
-
-#define TRUE		1
-#define FALSE		0
-/*
- * Default setting for whether to have a From field.  The -f switch
- * toggles this - if the default is to have it, using -f will turn
- * it off; if the default is not to have it, the -f switch will put
- * it in.  Possible values are TRUE (to have the field by default),
- * and FALSE.
- */
-#define DEFAULT_FROM	TRUE
-#define ZOMBIE		"<zombie>"
-
-
-void put_syntax();
-char *idletime();
-char *logintime();
-
-static char rcsid[]="$Id: tmp-junk.c,v 1.1 2002/02/01 22:46:37 csmall Exp $";
-
-
-void main (argc, argv)
-
-int argc;
-char *argv[];
-
-{
-    int header=TRUE, long_format=TRUE, ignore_user=TRUE,
-	from_switch=DEFAULT_FROM, show_pid=FALSE, line_length;
-    int i, j;
-    struct utmp *utmp_rec;
-    struct stat stat_rec;
-    struct passwd *passwd_entry;
-    uid_t uid;
-    char username[9], tty[13], rhost[17], login_time[27];
-    char idle_time[7], what[1024], pid[10];
-    char out_line[1024], file_name[256];
-    char search_name[9];
-    int  jcpu, pcpu, tpgid, curr_pid, utime, stime, cutime, cstime;
-    char /*ch,*/ state, comm[1024], *columns_ptr;
-    FILE *fp;
-
-
-    search_name[0] = '\0';
-
-
-    /*
-     * Process the command line
-     */
-    if (argc > 1)
-    {
-	/*
-	 * Args that start with '-'
-	 */
-	for (i = 1; ((i < argc) && (argv[i][0] == '-')); i ++)
-	{
-	    for (j = 1; argv[i][j] != '\0'; j++)
-	    {
-		switch (argv[i][j])
-		{
-		    case 'h':
-			header = FALSE;
-			break;
-		    case 's':
-			long_format = FALSE;
-			break;
-		    case 'u':
-			ignore_user = FALSE;
-			break;
-		    case 'd':
-			show_pid = TRUE;
-			break;
-		    case 'f':
-			if (DEFAULT_FROM == TRUE)
-			    from_switch = FALSE;
-			else
-			    from_switch = TRUE;
-			break;
-		    default:
-			fprintf (stderr, "w: unknown option: '%c'\n",
-			    argv[i][j]);
-			put_syntax ();
-			break;
-		}
-	    }
-	}
-
-
-	/*
-	 * Check for arg not starting with '-' (ie: username)
-	 */
-	if (argc > i)
-	{
-	    strncpy (search_name, argv[i], 8);
-	    search_name[8] = '\0';
-	    i ++;
-
-	    if (argc > i)
-	    {
-		fprintf (stderr, "w: syntax error\n");
-		put_syntax ();
-	    }
-	}
-    }
-
-
-
-    /*
-     * Check that /proc is actually there, or else we can't
-     * get all the information.
-     */
-    if (chdir ("/proc"))
-    {
-	fprintf (stderr, "w: fatal error: cannot access /proc\n");
-	perror (strerror(errno));
-	exit (-1);
-    }
-
-
-
-    /*
-     * Find out our screen width from $COLUMNS
-     */
-    columns_ptr = getenv ("COLUMNS");
-    if (columns_ptr == NULL)
-    {
-	struct winsize window;
-
-	/*
-	 * Try getting it directly
-	 */
-	if ((ioctl (1, TIOCGWINSZ, &window) != 1) && (window.ws_col > 0))
-	    line_length = window.ws_col;
-	else
-	    line_length = 80;		/* Default length assumed */
-    }
-    else
-	line_length = atoi (columns_ptr);
-
-    /*
-     * Maybe we should check whether there is enough space on
-     * the lines for the options selected...
-     */
-    if (line_length < 60)
-	long_format = FALSE;
-
-    line_length --;
-
-
-    /*
-     * Print whatever headers
-     */
-    if (header == TRUE)
-    {
-	/*
-	 * uptime: from MKJ's uptime routine,
-	 * found in whattime.c
-	 */
-	print_uptime();
-
-
-	/*
-	 * Print relevant header bits
-	 */
-	printf ("User     tty     ");
-
-	if (long_format == TRUE)
-	{
-	    if (from_switch == TRUE)
-		printf ("From             ");
-
-	    printf (" login@   idle  JCPU  PCPU  ");
-
-	    if (show_pid == TRUE)
-		printf (" PID  ");
-
-	    printf ("what\n");
-	}
-	else
-	{
-	    printf (" idle  ");
-
-	    if (show_pid == TRUE)
-		printf (" PID  ");
-
-	    printf ("what\n");
-	}
-    }
-
-
-
-
-    /*
-     * Process user information.
-     */
-    while ((utmp_rec = getutent()))
-    {
-	/*
-	 * Check we actually want to see this record.
-	 * It must be a valid active user process,
-	 * and match a specified search name.
-	 */
-	if ( (utmp_rec->ut_type == USER_PROCESS)
-	  && (strcmp(utmp_rec->ut_user, ""))
-	  && ( (search_name[0] == '\0')
-	    || ( (search_name[0] != '\0')
-	    && !strncmp(search_name, utmp_rec->ut_user, 8) ) ) )
-	{
-	    /*
-	     * Get the username
-	     */
-	    strncpy (username, utmp_rec->ut_user, 8);
-	    username[8] = '\0';		/* Set end terminator */
-
-
-	    /*
-	     * Find out the uid of that user (from their
-	     * passwd entry)
-	     */
-	    uid = -1;
-	    if ((passwd_entry = getpwnam (username)) != NULL)
-	    {
-	     uid = passwd_entry->pw_uid;
-	    }
-
-	    /*
-	     * Get (and clean up) the tty line
-	     */
-	    for (i = 0; (utmp_rec->ut_line[i] > 32) && (i < 6); i ++)
-		tty[i] = utmp_rec->ut_line[i];
-
-	    utmp_rec->ut_line[i] = '\0';
-	    tty[i] = '\0';
-
-
-	    /*
-	     * Don't bother getting info if it's not asked for
-	     */
-	    if (long_format == TRUE)
-	    {
-
-		/*
-		 * Get the remote hostname; this can be up to 16 chars,
-		 * but if any chars are invalid (ie: [^a-zA-Z0-9\.])
-		 * then the char is changed to a string terminator.
-		 */
-		if (from_switch == TRUE)
-		{
-		    strncpy (rhost, utmp_rec->ut_host, 16);
-		    rhost[16] = '\0';
-
-		}
-
-
-		/*
-		 * Get the login time
-		 * (Calculated by LG's routine, below)
-		 */
-		strcpy (login_time, logintime(utmp_rec->ut_time));
-	    }
-
-
-
-	    /*
-	     * Get the idle time.
-	     * (Calculated by LG's routine, below)
-	     */
-	    strcpy (idle_time, idletime (tty));
-
-
-
-	    /*
-	     * That's all the info out of /etc/utmp.
-	     * The rest is more difficult.  We use the pid from
-	     * utmp_rec->ut_pid to look in /proc for the info.
-	     * NOTE: This is not necessarily the active pid, so we chase
-	     * down the path of parent -> child pids until we find it,
-	     * according to the information given in /proc/<pid>/stat.
-	     */
-
-	    sprintf (pid, "%d", utmp_rec->ut_pid);
-
-	    what[0] = '\0';
-	    strcpy (file_name, pid);
-	    strcat (file_name, "/stat");
-	    jcpu = 0;
-	    pcpu = 0;
-
-	    if ((fp = fopen(file_name, "r")))
-	    {
-		while (what[0] == '\0')
-		{
-		    /*
-		     * Check /proc/<pid>/stat to see if the process
-		     * controlling the tty is the current one
-		     */
-		    fscanf (fp, "%d %s %c %*d %*d %*d %*d %d "
-			"%*u %*u %*u %*u %*u %d %d %d %d",
-			&curr_pid, comm, &state, &tpgid,
-			&utime, &stime, &cutime, &cstime);
-
-		    fclose (fp);
-
-		    if (comm[0] == '\0')
-			strcpy (comm, "-");
-
-		    /*
-		     * Calculate jcpu and pcpu.
-		     * JCPU is the time used by all processes and their
-		     * children, attached to the tty.
-		     * PCPU is the time used by the current process
-		     * (calculated once after the loop, using last
-		     * obtained values).
-		     */
-		    if (!jcpu)
-			jcpu = cutime + cstime;
-
-		    /*
-		     * Check for a zombie first...
-		     */
-		    if (state == 'Z')
-			strcpy (what, ZOMBIE);
-		    else if (curr_pid == tpgid)
-		    {
-			/*
-			 * If it is the current process, read cmdline
-			 * If that's empty, then the process is swapped out,
-			 * or is a zombie, so we use the command given in stat
-			 * which is in normal round brackets, ie: "()".
-			 */
-			strcpy (file_name, pid);
-			strcat (file_name, "/cmdline");
-			if ((fp = fopen(file_name, "r")))
-			{
-			    i = 0;
-			    j = fgetc (fp);
-			    while ((j != EOF) && (i < 256))
-			    {
-				if (j == '\0')
-				    j = ' ';
-
-				what[i] = j;
-				i++;
-				j = fgetc (fp);
-			    }
-			    what[i] = '\0';
-			    fclose (fp);
-			}
-
-			if (what[0] == '\0')
-			    strcpy (what, comm);
-		    }
-		    else
-		    {
-			/* 
-			 * Check out the next process
-			 * If we can't open it, use info from this process,
-			 * so we have to check out cmdline first.
-			 *
-			 * If we're not using "-u" then should we just
-			 * say "-" (or "-su") instead of a command line ?
-			 * If so, we should strpcy(what, "-"); when we
-			 * fclose() in the if after the stat() below.
-			 */
-			strcpy (file_name, pid);
-			strcat (file_name, "/cmdline");
-
-			if ((fp = fopen (file_name, "r")))
-			{
-			    i = 0;
-			    j = fgetc (fp);
-			    while ((j != EOF) && (i < 256))
-			    {
-				if (j == '\0')
-				    j = ' ';
-
-				what[i] = j;
-				i++;
-				j = fgetc (fp);
-			    }
-			    what[i] = '\0';
-			    fclose (fp);
-			}
-
-			if (what[0] == '\0')
-			    strcpy (what, comm);
-
-			/*
-			 * Now we have something in the what variable,
-			 * in case we can't open the next process.
-			 */
-			sprintf (pid, "%d", tpgid);
-			strcpy (file_name, pid);
-			strcat (file_name, "/stat");
-
-			fp = fopen (file_name, "r");
-
-			if (fp && (ignore_user == FALSE))
-			{
-			    /*
-			     * We don't necessarily go onto the next process,
-			     * unless we are either ignoring who the effective
-			     * user is, or it's the same uid
-			     */
-			    stat (file_name, &stat_rec);
-
-			    /*
-			     * If the next process is not owned by this
-			     * user finish the loop.
-			     */
-			    if (stat_rec.st_uid != uid)
-			    {
-				fclose (fp);
-
-				strcpy (what, "-su");
-				/*
-				 * See comment above somewhere;  I've used
-				 * "-su" here, as the next process is owned
-				 * by someone else; this is generally
-				 * because the user has done an "su" which
-				 * then exec'd something else.
-				 */
-			    }
-			    else
-				what[0] = '\0';
-			}
-			else if (fp)	/* else we are ignoring uid's */
-			    what[0] = '\0';
-		    }
-		}
-	    }
-	    else	/* Could not open first process for user */
-		strcpy (what, "?");
-
-
-	    /*
-	     * There is a bug somewhere in my version of linux
-	     * which means that utmp records are not cleaned
-	     * up properly when users log out. However, we
-	     * can detect this, by the users first process
-	     * not being there when we look in /proc.
-	     */
-
-
-	    /*
-	     * Don't output a line for "dead" users.
-	     * This gets round a bug which doesn't update utmp/wtmp
-	     * when users log out.
-	     */
-	    if (what[0] != '?')
-	    {
-#ifdef 0
-/* This makes unix98 pty's not line up, so has been disabled - JEH. */
-		/*
-		 * Remove the letters 'tty' from the tty id
-		 */
-		if (!strncmp (tty, "tty", 3))
-		{
-		    for (i = 3; tty[i - 1] != '\0'; i ++)
-			tty[i - 3] = tty[i];
-		}
-#endif
-
-		/*
-		 * Common fields
-		 */
-		sprintf (out_line, "%-9.8s%-6.7s ", username, tty);
-
-
-		/*
-		 * Format the line for output
-		 */
-		if (long_format == TRUE)
-		{
-		    /*
-		     * Calculate CPU usage
-		     */
-		    pcpu = utime + stime;
-		    jcpu /= 100;
-		    pcpu /= 100;
-
-		    if (from_switch == TRUE)
-			sprintf (out_line, "%s %-16.15s", out_line, rhost);
-
-		    sprintf (out_line, "%s%8.8s ", out_line, login_time);
-
-		}
-
-		sprintf (out_line, "%s%6s", out_line, idle_time);
-
-
-		if (long_format == TRUE)
-		{
-		    if (!jcpu)
-			strcat (out_line, "      ");
-		    else if (jcpu/60)
-			sprintf (out_line, "%s%3d:%02d", out_line,
-				jcpu/60, jcpu%60);
-		    else
-			sprintf (out_line, "%s    %2d", out_line, jcpu);
-
-		    if (!pcpu)
-			strcat (out_line, "      ");
-                    else if (pcpu/60)
-			sprintf (out_line, "%s%3d:%02d", out_line,
-				pcpu/60, pcpu%60);
-		    else
-			sprintf (out_line, "%s    %2d", out_line, pcpu);
-		}
-
-		if (show_pid == TRUE)
-		    sprintf (out_line, "%s %5.5s", out_line, pid);
-
-
-		strcat (out_line, "  ");
-		strcat (out_line, what);
-
-
-		/*
-		 * Try not to exceed the line length
-		 */
-		out_line[line_length] = '\0';
-
-		printf ("%s\n", out_line);
-	    }
-	}
-    }
-}
-
-
-
-/*
- * put_syntax()
- *
- * Routine to print the correct syntax to call this program,
- * and then exit out appropriately
- */
-void put_syntax ()
-{
-    fprintf (stderr, "usage: w [-hfsud] [user]\n");
-    exit (-1);
-}
-
-
-
-/*
- * idletime()
- *
- * Routine which returns a string containing
- * the idle time of a given user.
- *
- * This routine was lifted from the original w program
- * by Larry Greenfield  (greenfie@gauss.rutgers.edu)
- * Copyright (c) 1993 Larry Greenfield
- *
- */
-char *idletime (tty)
-
-char *tty;
-
-{
-    struct stat terminfo;
-    unsigned long idle;
-    char ttytmp[40];
-    static char give[20];
-    time_t curtime;
-
-    curtime = time (NULL);
-
-    sprintf (ttytmp, "/dev/%s", tty);
-    stat (ttytmp, &terminfo);
-    idle = (unsigned long) curtime - (unsigned long) terminfo.st_atime;
-
-    if (idle >= (60 * 60))		/* more than an hour */
-    {
-	if (idle >= (60 * 60 * 48))	/* more than two days */
-	    sprintf (give, "%2ludays", idle / (60 * 60 * 24));
-	else
-	    sprintf (give, " %2lu:%02u", idle / (60 * 60), 
-	      (unsigned) ((idle / 60) % 60));
-    }
-    else
-    {
-	if (idle / 60)
-	    sprintf (give, "%6lu", idle / 60);
-	else
-	    give[0]=0;
-    }
-
-    return give;
-}
-
-
-
-/*
- * logintime()
- *
- * Returns the time given in a suitable format
- *
- * This routine was lifted from the original w program
- * by Larry Greenfield  (greenfie@gauss.rutgers.edu)
- * Copyright (c) 1993 Larry Greenfield
- *
- */
-
-#undef ut_time
-
-char *logintime(ut_time)
-
-time_t ut_time;
-
-{
-    time_t curtime;
-    struct tm *logintime, *curtm;
-    int hour, am, curday, logday;
-    static char give[20];
-    static char *weekday[] = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri",
-				"Sat" };
-    static char *month[] = { "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul",
-				"Aug", "Sep", "Oct", "Nov", "Dec" };
-
-    curtime = time(NULL);
-    curtm = localtime(&curtime);
-    curday = curtm->tm_yday;
-    logintime = localtime(&ut_time);
-    hour = logintime->tm_hour;
-    logday = logintime->tm_yday;
-    am = (hour < 12);
-
-    if (!am)
-	hour -= 12;
-
-    if (hour == 0)
-	hour = 12;
-
-    /*
-     * This is a newer behavior: it waits 12 hours and the next day, and then
-     * goes to the 2nd time format. This should reduce confusion.
-     * It then waits only 6 days (not till the last moment) to go the last
-     * time format.
-     */
-    if ((curtime > (ut_time + (60 * 60 * 12))) && (logday != curday))
-    {
-	if (curtime > (ut_time + (60 * 60 * 24 * 6)))
-	    sprintf(give, "%2d%3s%2d", logintime->tm_mday,
-		month[logintime->tm_mon], (logintime->tm_year % 100));
-	else
-	    sprintf(give, "%*s%2d%s", 3, weekday[logintime->tm_wday],
-		hour, am ? "am" : "pm");
-    }
-    else
-	sprintf(give, "%2d:%02d%s", hour, logintime->tm_min, am ? "am" : "pm");
-
-    return give;
-}
-
diff --git a/contrib/utmp.c b/contrib/utmp.c
deleted file mode 100644
index 936a7f6c..00000000
--- a/contrib/utmp.c
+++ /dev/null
@@ -1,178 +0,0 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sys/ioctl.h>
-#include <time.h>
-#include <utmp.h>
-#include <fcntl.h>
-#include <unistd.h>
-#include <sys/stat.h>
-
-/* examine and fix utmp entries.  Note that the code for fixing entries
-   is not complete, and indeed does nothing at all at this time.  No bug
-   reports, please, as I am still actively working on this.  It is not
-   here for general use, but only so that I can ferret out any bugs that
-   exist on other peoples systems without having to log in to their systems
-   myself ;-)  */
-
-
-int main (int argc, char **argv) {
-
-  FILE *ut; /* /var/run/utmp */
-  struct utmp uts; /* utmp record */
-  char user[UT_NAMESIZE + 1];
-  char host[17];
-  char ch;
-  int print_all = 0, list = 0, fix = 0;
-
-/* get options */
-  while ((ch = getopt(argc, argv, "laf")) != EOF)
-    switch (ch) {
-    case 'a':
-      print_all = 1;
-      break;
-    case 'l':
-      list = 1;
-      break;
-    case 'f':
-      fix = 1;
-      break;
-    }
-
-/* check argument options */
-  if ( (!list && !print_all && !fix)) {
-    fprintf(stderr, "You must specify a command line option:\n\tl = list\n\
-\tf = fix\n\ta = all (requires l or f)\n");
-    exit(1);
-  }
-
-  
-  if (list) {
-    ut = fopen(UTMP_FILE, "r");
-    while (fread(&uts, sizeof(uts), 1, ut))
-      if (((uts.ut_type == USER_PROCESS) && (uts.ut_name[0] != '\000'))
-	  || print_all) {
-	strncpy(user, uts.ut_user, UT_NAMESIZE);
-	user[UT_NAMESIZE]=0;
-	strncpy(host, uts.ut_host, 16);
-	host[16]=0;
-	printf("ut_type: %d\n", uts.ut_type);
-	printf("ut_pid:  %d\n", uts.ut_pid);
-	printf("ut_line: %s\n", uts.ut_line);
-	printf("ut_id:   %2s\n", uts.ut_id);
-	printf("ut_time: %d\n", uts.ut_time);
-	printf("ut_user: %s\n", user);
-	printf("ut_host: %s\n", host);
-	printf("ut_addr: %d\n\n", uts.ut_addr);
-      }
-    fclose(ut);
-  }
-
-
-  if (fix) {
-    ut = fopen(UTMP_FILE, "r");
-    while (fread(&uts, sizeof(uts), 1, ut)) 
-      if (((uts.ut_type == USER_PROCESS) && (uts.ut_name[0] != '\000'))
-	  || print_all) {
-	/* Display entry in utmp */
-	strncpy(user, uts.ut_user, UT_NAMESIZE);
-	user[UT_NAMESIZE]=0;
-	strncpy(host, uts.ut_host, 16);
-	host[16]=0;
-	printf("ut_type: %d\n", uts.ut_type);
-	printf("ut_pid:  %d\n", uts.ut_pid);
-	printf("ut_line: %s\n", uts.ut_line);
-	printf("ut_id:   %s2\n", uts.ut_id);
-	printf("ut_time: %d\n", uts.ut_time);
-	printf("ut_user: %s\n", user);
-	printf("ut_host: %s\n", host);
-	printf("ut_addr: %d\n\n", uts.ut_addr);
-      
-	printf("Modify this record? (y/N): "); fflush(stdout);
-	/* Ask if to delete or no */
-	if ((ch = getchar()) == 'y' || ch == 'Y') {
-	  while (getchar() != '\n');
-	  printf("Change ut_type? "); fflush(stdout);
-	  if ((ch = getchar()) == 'y' || ch == 'Y') {
-	    while (getchar() != '\n');
-	    printf("INIT, LOGIN, USER, or DEAD_PROCESS? (I/L/U/D): ");
-	    fflush(stdout);
-	    ch = getchar();
-	    switch (ch) {
-	    case 'i':
-	    case 'I':
-	      uts.ut_type = INIT_PROCESS;
-	      break;
-	    case 'l':
-	    case 'L':
-	      uts.ut_type = LOGIN_PROCESS;
-	      break;
-	    case 'u':
-	    case 'U':
-	      uts.ut_type = USER_PROCESS;
-	      break;
-	    case 'd':
-	    case 'D':
-	      uts.ut_type = DEAD_PROCESS;
-	      break;
-	    default:
-	      printf("Invalid choice: %c\n", ch);
-	    }
-	    if (ch != '\n') while ((ch = getchar()) != '\n');
-	  }
-	  if (ch != '\n') while ((ch = getchar()) != '\n');
-	  printf("Change ut_id field? (y/N): "); fflush(stdout);
-	  if ((ch = getchar()) == 'y' || ch == 'Y') {
-	    while (getchar() != '\n');
-	    printf("Please enter the two characters for ut_id: ");
-	    fflush(stdout);
-	    uts.ut_id[0] = getchar();
-	    uts.ut_id[1] = getchar();
-	    while ((ch = getchar()) != '\n');
-	  }
-	  if (ch != '\n') while ((ch = getchar()) != '\n');
-	  printf("Change the ut_user field? (y/N): "); fflush(stdout);
-	  if ((ch = getchar()) == 'y' || ch == 'Y') {
-	    int i;
-	    while (getchar() != '\n');
-	    printf("Please enter the new ut_name, up to %c characters: ",
-		   UT_NAMESIZE);
-	    fflush(stdout);
-	    for (i=0; i<UT_NAMESIZE; i++) {
-	      ch = getchar();
-	      uts.ut_user[i] = (ch != '\n') ? ch : i = UT_NAMESIZE, (char) 0;
-	    }
-	  }
-	  if (ch != '\n') while ((ch = getchar()) != '\n');
-	  printf("Change the ut_host field? (y/N): "); fflush(stdout);
-	  if ((ch = getchar()) == 'y' || ch == 'Y') {
-	    int i;
-	    while (getchar() != '\n');
-	    printf("Please enter the new ut_host, up to 16 characters: ");
-	    fflush(stdout);
-	    for (i=0; i<16; i++) {
-	      ch = getchar();
-	      uts.ut_user[i] = (ch != '\n') ? ch : i = 16, (char) 0;
-	    }
-	    if (ch != '\n') while ((ch = getchar()) != '\n');
-	  }
-
-	  /* Here go the changes...*/
-/*	  utmpname(UTMP_FILE);
-	  setutent();
-	  pututline(&uts);
-	  endutent(); */
-/* But they don't work... */
-
-	}
-	if (ch != '\n') while ((ch = getchar()) != '\n');
-	/* here we should write the utmp entry */
-      }
-    fclose(ut);
-  }
-
-
-  return 0;
-
-
-}
diff --git a/proc/devname.c b/devname.c
similarity index 98%
rename from proc/devname.c
rename to devname.c
index 32ad9540..50456f43 100644
--- a/proc/devname.c
+++ b/devname.c
@@ -1,13 +1,13 @@
 /*
- * Copyright 1998-2002 by Albert Cahalan; all rights resered.         
+ * Copyright 1998-2002 by Albert Cahalan; all rights resered.
  * This file may be used subject to the terms and conditions of the
- * GNU Library General Public License Version 2, or any later version  
+ * GNU Library General Public License Version 2, or any later version
  * at your option, as published by the Free Software Foundation.
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  * GNU Library General Public License for more details.
- */                                 
+ */
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -69,7 +69,7 @@ static void load_drivers(void){
   p = buf;
   while(( p = strstr(p, " /dev/") )){  // " /dev/" is the second column
     tty_map_node *tmn;
-    int len;
+    unsigned int len;
     char *end;
     p += 6;
     end = strchr(p, ' ');
diff --git a/proc/devname.h b/devname.h
similarity index 100%
rename from proc/devname.h
rename to devname.h
diff --git a/proc/escape.c b/escape.c
similarity index 86%
rename from proc/escape.c
rename to escape.c
index 92ba4b19..0eb1418b 100644
--- a/proc/escape.c
+++ b/escape.c
@@ -50,6 +50,13 @@ static int escape_str_utf8(char *restrict dst, const char *restrict src, int buf
       my_cells++; 
       my_bytes++;
 
+    } else if (len==1) {
+      /* non-multibyte */
+      *(dst++) = isprint(*src) ? *src : '?';
+      src++;
+      my_cells++;
+      my_bytes++;
+      
     } else if (!iswprint(wc)) {
       /* multibyte - no printable */
       *(dst++) = '?';
@@ -91,7 +98,7 @@ static int escape_str_utf8(char *restrict dst, const char *restrict src, int buf
     }
     //fprintf(stdout, "cells: %d\n", my_cells);
   }
-  *dst = '\0';
+  *(dst++) = '\0';
 
   // fprintf(stderr, "maxcells: %d, my_cells; %d\n", *maxcells, my_cells);
   
@@ -107,14 +114,14 @@ int escape_str(char *restrict dst, const char *restrict src, int bufsize, int *m
   int my_cells = 0;
   int my_bytes = 0;
   const char codes[] =
-  "Z..............................."
-  "||||||||||||||||||||||||||||||||"
-  "||||||||||||||||||||||||||||||||"
-  "|||||||||||||||||||||||||||||||."
-  "????????????????????????????????"
-  "????????????????????????????????"
-  "????????????????????????????????"
-  "????????????????????????????????";
+  "Z-------------------------------"
+  "********************************"
+  "********************************"
+  "*******************************-"
+  "--------------------------------"
+  "********************************"
+  "********************************"
+  "********************************";
   
 #if (__GNU_LIBRARY__ >= 6)
   static int utf_init=0;
@@ -124,10 +131,9 @@ int escape_str(char *restrict dst, const char *restrict src, int bufsize, int *m
      char *enc = nl_langinfo(CODESET);
      utf_init = enc && strcasecmp(enc, "UTF-8")==0 ? 1 : -1;
   }
-  if (utf_init==1 && MB_CUR_MAX>1) {
+  if (utf_init==1)
      /* UTF8 locales */
      return escape_str_utf8(dst, src, bufsize, maxcells);
-  }
 #endif
 		  
   if(bufsize > *maxcells+1) bufsize=*maxcells+1; // FIXME: assumes 8-bit locale
@@ -137,12 +143,12 @@ int escape_str(char *restrict dst, const char *restrict src, int bufsize, int *m
       break;
     c = (unsigned char) *(src++);
     if(!c) break;
-    if(codes[c]!='|') c=codes[c];
+    if(codes[c]=='-') c='?';
     my_cells++;
     my_bytes++;
     *(dst++) = c;
   }
-  *dst = '\0';
+  *(dst++) = '\0';
   
   *maxcells -= my_cells;
   return my_bytes;        // bytes of text, excluding the NUL
@@ -208,16 +214,3 @@ int escape_command(char *restrict const outbuf, const proc_t *restrict const pp,
   outbuf[end] = '\0';
   return end;  // bytes, not including the NUL
 }
-
-/////////////////////////////////////////////////
-
-// copy an already 'escaped' string,
-// using the traditional escape.h calling conventions
-int escaped_copy(char *restrict dst, const char *restrict src, int bufsize, int *maxroom){
-  int n;
-  if (bufsize > *maxroom+1) bufsize = *maxroom+1;
-  n = snprintf(dst, bufsize, "%s", src);
-  if (n >= bufsize) n = bufsize-1;
-  *maxroom -= n;
-  return n;
-}
diff --git a/proc/escape.h b/escape.h
similarity index 89%
rename from proc/escape.h
rename to escape.h
index aa9f6d64..172960f5 100644
--- a/proc/escape.h
+++ b/escape.h
@@ -17,7 +17,6 @@ EXTERN_C_BEGIN
 extern int escape_strlist(char *restrict dst, const char *restrict const *restrict src, size_t n, int *cells);
 extern int escape_str(char *restrict dst, const char *restrict src, int bufsize, int *maxcells);
 extern int escape_command(char *restrict const outbuf, const proc_t *restrict const pp, int bytes, int *cells, unsigned flags);
-extern int escaped_copy(char *restrict dst, const char *restrict src, int bufsize, int *maxroom);
 
 EXTERN_C_END
 #endif
diff --git a/free.1 b/free.1
deleted file mode 100644
index 58847510..00000000
--- a/free.1
+++ /dev/null
@@ -1,86 +0,0 @@
-.\"             -*-Nroff-*-
-.\"  This page Copyright (C) 1993 Matt Welsh, mdw@sunsite.unc.edu.
-.\"  Long options where added at April 15th, 2011.
-.\"  Freely distributable under the terms of the GPL
-.TH FREE 1 "15 Apr 2011 " "Cohesive Systems" "Linux User's Manual"
-.SH NAME
-free \- Display amount of free and used memory in the system
-.SH SYNOPSIS
-.B free
-.RB [ options ]
-.SH DESCRIPTION
-\fBfree\fP displays the total amount of free and used physical and swap 
-memory in the system, as well as the buffers used by the kernel.
-The shared memory column should be ignored; it is obsolete.
-.SS OPTIONS
-.TP
-\fB\-b, \-\-bytes\fR
-Display the amount of memory in bytes.
-.TP
-\fB\-k, \-\-kilo\fR
-Display the amount of memory in kilobytes. This is the default.
-.TP
-\fB\-m, \-\-mega\fR
-Display the amount of memory in megabytes.
-.TP
-\fB\-g, \-\-giga\fR
-Display the amount of memory in gigabytes.
-.TP
-\fB\-\-tera
-Display the amount of memory in terabytes.
-.TP
-\fB\-h, \-\-human\fP
-Show all output fields automatically scaled to shortest three
-digit unit and display the units of print out. Following units
-are used.
-
-.nf
-  B = bytes
-  K = kilos
-  M = megas
-  G = gigas
-  T = teras
-.fi
-
-If unit is missing, and you have petabyte of RAM or swap, the
-number is in terabytes and columns might not be aligned with
-header.
-.TP
-\fB\-c, \-\-count\fR \fICOUNT\fR
-Display the result \fIcount\fR times.  Requires the \fB\-s\fR option.
-.TP
-\fB\-l, \-\-lohi\fR
-Show detailed low and high memory statistics.
-.TP
-\fB\-o, \-\-old\fR
-Display the output in old format, the only difference being this option
-will disable the display of the "buffer adjusted" line.
-.TP
-\fB\-s, \-\-seconds\fR \fISECONDS\fR
-Continuously display the result \fIdelay\fP seconds apart. You
-may actually specify any floating point number for \fIdelay\fP, 
-.BR usleep (3)
-is used for microsecond resolution delay times.
-.TP
-\fB\-\-si\fP
-Use power of 1000 not 1024.
-.TP
-\fB\-t, \-\-total\fR
-Display a line showing the column totals.
-.TP
-\fB\-\-help\fP
-Print help.
-.TP
-\fB\-V, \-\-version\fR
-Display version information.
-.SH FILES
-.nf
-/proc/meminfo memory information
-.fi
-.SH AUTHORS
-Written by Brian Edmonds. 
-
-Send bug reports to <procps@freelists.org>
-.SH "SEE ALSO"
-.BR ps "(1), " slabtop "(1), " top "(1), " vmstat (8).
-.\"{{{}}}
diff --git a/free.c b/free.c
deleted file mode 100644
index d281c95f..00000000
--- a/free.c
+++ /dev/null
@@ -1,330 +0,0 @@
-/*
- * free.c - free(1)
- * procps-ng utility to display free memory information
- *
- * Mostly new, Sami Kerola <kerolasa@iki.fi>		15 Apr 2011
- * All new, Robert Love <rml@tech9.net>			18 Nov 2002
- * Original by Brian Edmonds and Rafal Maszkowski	14 Dec 1992
- *
- * This program is licensed under the GNU Library General Public License, v2
- *
- * Copyright 2003 Robert Love
- * Copyright 2004 Albert Cahalan
- */
-#include "proc/sysinfo.h"
-#include "proc/version.h"
-#include <errno.h>
-#include <err.h>
-#include <limits.h>
-#include <ctype.h>
-#include <getopt.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-
-#ifndef SIZE_MAX
-#define SIZE_MAX		32
-#endif
-
-#define FREE_HUMANREADABLE	(1 << 1)
-#define FREE_LOHI		(1 << 2)
-#define FREE_OLDFMT		(1 << 3)
-#define FREE_TOTAL		(1 << 4)
-#define FREE_SI			(1 << 5)
-#define FREE_REPEAT		(1 << 6)
-#define FREE_REPEATCOUNT	(1 << 7)
-
-struct commandline_arguments {
-	int exponent;		/* demanded in kilos, magas... */
-	float repeat_interval;	/* delay in seconds */
-	int repeat_counter;	/* number of repeats */
-};
-
-/* function prototypes */
-static void usage(FILE * out);
-double power(unsigned int base, unsigned int expo);
-static const char *scale_size(unsigned long size, int flags, struct commandline_arguments args);
-
-static void __attribute__ ((__noreturn__))
-    usage(FILE * out)
-{
-	fprintf(out, "\nUsage: %s [options]\n" "\nOptions:\n", program_invocation_short_name);
-	fprintf(out,
-		"  -b, --bytes         show output in bytes\n"
-		"  -k, --kilo          show output in kilobytes\n"
-		"  -m, --mega          show output in megabytes\n"
-		"  -g, --giga          show output in gigabytes\n"
-		"      --tera          show output in terabytes\n"
-		"  -h, --human         show human readable output\n"
-		"      --si            use powers of 1000 not 1024\n"
-		"  -l, --lohi          show detailed low and high memory statistics\n"
-		"  -o, --old           use old format (no -/+buffers/cache line)\n"
-		"  -t, --total         show total for RAM + swap\n"
-		"  -s N, --seconds N   repeat printing every N seconds\n"
-		"  -c N, --count N     repeat printing N times\n");
-	fprintf(out,
-		"      --help          display this help text\n"
-		"  -V, --version       display version information and exit\n");
-	fprintf(out, "\nFor more information see free(1).\n");
-
-	exit(out == stderr ? EXIT_FAILURE : EXIT_SUCCESS);
-}
-
-double power(unsigned int base, unsigned int expo)
-{
-	return (expo == 0) ? 1 : base * power(base, expo - 1);
-}
-
-/* idea of this function is copied from top size scaling */
-static const char *scale_size(unsigned long size, int flags, struct commandline_arguments args)
-{
-	static char nextup[] = { 'B', 'K', 'M', 'G', 'T', 0 };
-	static char buf[SIZE_MAX];
-	int i;
-	char *up;
-	float base;
-
-	if (flags & FREE_SI)
-		base = 1000.0;
-	else
-		base = 1024.0;
-
-	/* default output */
-	if (args.exponent == 0 && !(flags & FREE_HUMANREADABLE)) {
-		snprintf(buf, sizeof(buf), "%ld", size);
-		return buf;
-	}
-
-	if (!(flags & FREE_HUMANREADABLE)) {
-		if (args.exponent == 1) {
-			/* in bytes, which can not be in SI */
-			snprintf(buf, sizeof(buf), "%ld", (long int)(size * 1024));
-			return buf;
-		}
-		if (args.exponent == 2) {
-			if (!(flags & FREE_SI))
-				snprintf(buf, sizeof(buf), "%ld", size);
-			else
-				snprintf(buf, sizeof(buf), "%ld", (long int)(size / 0.9765625));
-			return buf;
-		}
-		if (args.exponent > 2) {
-			/* In desired scale. */
-			snprintf(buf, sizeof(buf), "%ld",
-				 (long int)(size / power(base, args.exponent - 2))
-			    );
-			return buf;
-		}
-	}
-
-	/* human readable output */
-	up = nextup;
-	for (i = 1; up[0] != '0'; i++, up++) {
-		switch (i) {
-		case 1:
-			if (4 >= snprintf(buf, sizeof(buf), "%ld%c", (long)size * 1024, *up))
-				return buf;
-			break;
-		case 2:
-
-			if (!(flags & FREE_SI)) {
-				if (4 >= snprintf(buf, sizeof(buf), "%ld%c", size, *up))
-					return buf;
-			} else {
-				if (4 >=
-				    snprintf(buf, sizeof(buf), "%ld%c",
-					     (long)(size / 0.9765625), *up))
-					return buf;
-			}
-			break;
-		case 3:
-		case 4:
-		case 5:
-			if (4 >=
-			    snprintf(buf, sizeof(buf), "%.1f%c",
-				     (float)(size / power(base, i - 2)), *up))
-				return buf;
-			if (4 >=
-			    snprintf(buf, sizeof(buf), "%ld%c",
-				     (long)(size / power(base, i - 2)), *up))
-				return buf;
-			break;
-		case 6:
-			break;
-		}
-	}
-	/*
-	 * On system where there is more than petabyte of memory or swap the
-	 * output does not fit to column. For incoming few years this should
-	 * not be a big problem (wrote at Apr, 2011).
-	 */
-	return buf;
-}
-
-int main(int argc, char **argv)
-{
-	int c, flags = 0;
-	char *endptr;
-	struct commandline_arguments args;
-	args.repeat_counter = 0;
-
-	/*
-	 * For long options that have no equivalent short option, use a
-	 * non-character as a pseudo short option, starting with CHAR_MAX + 1.
-	 */
-	enum {
-		SI_OPTION = CHAR_MAX + 1,
-		TERA_OPTION,
-		HELP_OPTION
-	};
-
-	static const struct option longopts[] = {
-		{  "bytes",	no_argument,	    NULL,  'b'		},
-		{  "kilo",	no_argument,	    NULL,  'k'		},
-		{  "mega",	no_argument,	    NULL,  'm'		},
-		{  "giga",	no_argument,	    NULL,  'g'		},
-		{  "tera",	no_argument,	    NULL,  TERA_OPTION	},
-		{  "human",	no_argument,	    NULL,  'h'		},
-		{  "si",	no_argument,	    NULL,  SI_OPTION	},
-		{  "lohi",	no_argument,	    NULL,  'l'		},
-		{  "old",	no_argument,	    NULL,  'o'		},
-		{  "total",	no_argument,	    NULL,  't'		},
-		{  "seconds",	required_argument,  NULL,  's'		},
-		{  "count",	required_argument,  NULL,  'c'		},
-		{  "help",	no_argument,	    NULL,  HELP_OPTION	},
-		{  "version",	no_argument,	    NULL,  'V'		},
-		{  NULL,	0,		    NULL,  0		}
-	};
-
-	/* defaults to old format */
-	args.exponent = 0;
-	args.repeat_interval = 1000000;
-
-	while ((c = getopt_long(argc, argv, "bkmghlotc:s:V", longopts, NULL)) != -1)
-		switch (c) {
-		case 'b':
-			args.exponent = 1;
-			break;
-		case 'k':
-			args.exponent = 2;
-			break;
-		case 'm':
-			args.exponent = 3;
-			break;
-		case 'g':
-			args.exponent = 4;
-			break;
-		case TERA_OPTION:
-			args.exponent = 5;
-			break;
-		case 'h':
-			flags |= FREE_HUMANREADABLE;
-			break;
-		case SI_OPTION:
-			flags |= FREE_SI;
-			break;
-		case 'l':
-			flags |= FREE_LOHI;
-			break;
-		case 'o':
-			flags |= FREE_OLDFMT;
-			break;
-		case 't':
-			flags |= FREE_TOTAL;
-			break;
-		case 's':
-			flags |= FREE_REPEAT;
-			args.repeat_interval = (1000000 * strtof(optarg, &endptr));
-			if (errno || optarg == endptr || (endptr && *endptr))
-				errx(EXIT_FAILURE, "seconds argument `%s' failed", optarg);
-			if (args.repeat_interval < 1)
-				errx(EXIT_FAILURE,
-				     "seconds argument `%s' is not positive number", optarg);
-			break;
-		case 'c':
-			flags |= FREE_REPEAT;
-			flags |= FREE_REPEATCOUNT;
-			args.repeat_counter = strtoul(optarg, &endptr, 10);
-			if (errno || optarg == endptr || (endptr && *endptr))
-				errx(EXIT_FAILURE, "count argument `%s' failed", optarg);
-
-			break;
-		case HELP_OPTION:
-			usage(stdout);
-		case 'V':
-			display_version();
-			exit(EXIT_SUCCESS);
-		default:
-			usage(stderr);
-		}
-
-	do {
-
-		meminfo();
-
-		printf
-		    ("             total       used       free     shared    buffers     cached\n");
-		printf("%-7s", "Mem:");
-		printf(" %10s", scale_size(kb_main_total, flags, args));
-		printf(" %10s", scale_size(kb_main_used, flags, args));
-		printf(" %10s", scale_size(kb_main_free, flags, args));
-		printf(" %10s", scale_size(kb_main_shared, flags, args));
-		printf(" %10s", scale_size(kb_main_buffers, flags, args));
-		printf(" %10s", scale_size(kb_main_cached, flags, args));
-		printf("\n");
-		/*
-		 * Print low vs. high information, if the user requested it.
-		 * Note we check if low_total == 0: if so, then this kernel
-		 * does not export the low and high stats. Note we still want
-		 * to print the high info, even if it is zero.
-		 */
-		if (flags & FREE_LOHI) {
-			printf("%-7s", "Low:");
-			printf(" %10s", scale_size(kb_low_total, flags, args));
-			printf(" %10s", scale_size(kb_low_total - kb_low_free, flags, args));
-			printf(" %10s", scale_size(kb_low_free, flags, args));
-			printf("\n");
-
-			printf("%-7s", "High:");
-			printf(" %10s", scale_size(kb_high_total, flags, args));
-			printf(" %10s", scale_size(kb_high_total - kb_high_free, flags, args));
-			printf(" %10s", scale_size(kb_high_free, flags, args));
-			printf("\n");
-		}
-
-		if (!(flags & FREE_OLDFMT)) {
-			unsigned KLONG buffers_plus_cached = kb_main_buffers + kb_main_cached;
-			printf("-/+ buffers/cache:");
-			printf(" %10s",
-			       scale_size(kb_main_used - buffers_plus_cached, flags, args));
-			printf(" %10s",
-			       scale_size(kb_main_free + buffers_plus_cached, flags, args));
-			printf("\n");
-		}
-		printf("%-7s", "Swap:");
-		printf(" %10s", scale_size(kb_swap_total, flags, args));
-		printf(" %10s", scale_size(kb_swap_used, flags, args));
-		printf(" %10s", scale_size(kb_swap_free, flags, args));
-		printf("\n");
-
-		if (flags & FREE_TOTAL) {
-			printf("%-7s", "Total:");
-			printf(" %10s", scale_size(kb_main_total + kb_swap_total, flags, args));
-			printf(" %10s", scale_size(kb_main_used + kb_swap_used, flags, args));
-			printf(" %10s", scale_size(kb_main_free + kb_swap_free, flags, args));
-			printf("\n");
-		}
-		fflush(stdout);
-		if (flags & FREE_REPEATCOUNT) {
-			args.repeat_counter--;
-			if (args.repeat_counter < 1)
-				exit(EXIT_SUCCESS);
-		}
-		if (flags & FREE_REPEAT) {
-			printf("\n");
-			usleep(args.repeat_interval);
-		}
-	} while ((flags & FREE_REPEAT));
-
-	exit(EXIT_SUCCESS);
-}
diff --git a/kill.1 b/kill.1
deleted file mode 100644
index 5df66a14..00000000
--- a/kill.1
+++ /dev/null
@@ -1,106 +0,0 @@
-'\" t
-.\" (The preceding line is a note to broken versions of man to tell
-.\" them to pre-process this man page with tbl)
-.\" Man page for kill.
-.\" Licensed under version 2 of the GNU General Public License.
-.\" Written by Albert Cahalan; converted to a man page by
-.\" Michael K. Johnson
-.TH KILL 1 "November 21, 1999" "Linux" "Linux User's Manual"
-.SH NAME
-kill \- send a signal to a process
-
-.SH SYNOPSIS
-\fBkill\fR [ \-\fBsignal\fR | \-s \fBsignal\fR ] \fBpid\fR ...
-.br
-\fBkill\fR [ \-L | -V, \-\-version ]
-.br
-\fBkill\fR \-l  [ \fBsignal\fR ]
-
-.SH DESCRIPTION
-The default signal for kill is TERM. Use \-l or \-L to list available signals.
-Particularly useful signals include HUP, INT, KILL, STOP, CONT, and 0.
-Alternate signals may be specified in three ways: \-9 \-SIGKILL \-KILL.
-Negative PID values may be used to choose whole process groups; see the
-PGID column in ps command output. A PID of \-1 is special; it indicates
-all processes except the kill process itself and init.
-
-.SH SIGNALS
-The signals listed below may be available for use with kill.
-When known constant, numbers and default behavior are shown.
-
-.TS
-lB rB lB lB
-lfCW r l l.
-Name	Num	Action	Description
-0	0	n/a	exit code indicates if a signal may be sent
-ALRM	14	exit
-HUP	1	exit
-INT	2	exit
-KILL	9	exit	cannot be blocked
-PIPE	13	exit
-POLL		exit
-PROF		exit
-TERM	15	exit
-USR1		exit
-USR2		exit
-VTALRM		exit
-STKFLT		exit	might not be implemented
-PWR		ignore	might exit on some systems
-WINCH		ignore
-CHLD		ignore
-URG		ignore
-TSTP		stop	might interact with the shell
-TTIN		stop	might interact with the shell
-TTOU		stop	might interact with the shell
-STOP		stop	cannot be blocked
-CONT		restart	continue if stopped, otherwise ignore
-ABRT	6	core
-FPE	8	core
-ILL	4	core
-QUIT	3	core
-SEGV	11	core
-TRAP	5	core
-SYS		core	might not be implemented
-EMT		core	might not be implemented
-BUS		core	core dump might fail
-XCPU		core	core dump might fail
-XFSZ		core	core dump might fail
-.TE
-
-.SH NOTES
-Your shell (command line interpreter) may have a built-in kill command.
-You may need to run the command described here as /bin/kill to solve
-the conflict.
-
-.SH EXAMPLES
-.TP
-.B kill \-9 \-1
-Kill all processes you can kill.
-.TP
-.B kill \-l 11
-Translate number 11 into a signal name.
-.TP
-.B kill -L
-List the available signal choices in a nice table.
-.TP
-.B kill 123 543 2341 3453
-Send the default signal, SIGTERM, to all those processes.
-
-.SH "SEE ALSO"
-.BR pkill (1),
-.BR skill (1),
-.BR kill (2),
-.BR renice (1),
-.BR nice (1),
-.BR signal (7),
-.BR killall (1).
-
-.SH STANDARDS
-This command meets appropriate standards. The \-L flag is Linux-specific.
-
-.SH AUTHOR
-Albert Cahalan <albert@users.sf.net> wrote kill in 1999 to replace a
-bsdutils one that was not standards compliant. The util-linux one might
-also work correctly.
-
-Please send bug reports to <procps@freelists.org>
diff --git a/proc/ksym.c b/ksym.c
similarity index 100%
rename from proc/ksym.c
rename to ksym.c
diff --git a/proc/library.map b/library.map
similarity index 77%
rename from proc/library.map
rename to library.map
index 199b9ac8..a38627b7 100644
--- a/proc/library.map
+++ b/library.map
@@ -6,14 +6,14 @@ global:
   __cyg_profile_func_enter; __cyg_profile_func_exit; main;
 
   readproc; readtask; readproctab; readproctab2; look_up_our_self; escape_command;
-  escape_str; escape_strlist; escaped_copy; read_cmdline;
-  openproc; closeproc; freeproc; readeither; readproctab3;
+  escape_str; escape_strlist;
+  openproc; closeproc;
   tty_to_dev; dev_to_tty; open_psdb_message; open_psdb; lookup_wchan;
   display_version; procps_version; linux_version_code;
-  Hertz; smp_num_cpus; have_privs; getbtime;
+  Hertz; smp_num_cpus; have_privs;
   sprint_uptime; uptime; user_from_uid; print_uptime; loadavg;
   pretty_print_signals; print_given_signals; unix_print_signals; signal_name_to_number; signal_number_to_name;
-  cpuinfo; meminfo; vminfo; getstat; getdiskstat; getpartitions_num; getslabinfo; get_pid_digits;
+  meminfo; vminfo; getstat; getdiskstat; getpartitions_num; getslabinfo; get_pid_digits;
   kb_active; kb_inactive; kb_main_buffers; kb_main_cached;
   kb_main_free; kb_main_total; kb_main_used; kb_swap_free;
   kb_swap_total; kb_swap_used; kb_main_shared;
diff --git a/module.mk b/module.mk
new file mode 100644
index 00000000..af203348
--- /dev/null
+++ b/module.mk
@@ -0,0 +1,130 @@
+# This file gets included into the main Makefile, in the top directory.
+
+# Ideally, we want something like this:
+#
+# /lib/libproc.so.w        ELF soname ('w' is a digit, starting from 1)
+# /lib/procps-x.y.z.so     file itself (x.y.z is the procps version)
+# /lib/libproc.so          for linking, UNSUPPORTED
+# /usr/lib/libproc.a       for linking, UNSUPPORTED
+# proc/libproc.so.w        as above, if testing with LD_LIBRARY_PATH
+# proc/whatever            if testing with LD_PRELOAD
+# proc/libproc.a           for static build
+#
+# Without a stable ABI, there's no point in having any of that.
+# Without a stable API, there's no point in having the *.a file.
+#
+# A new ELF soname is required for every big ABI change. To conserve
+# numbers for future use, the ELF soname can be set equal to the
+# file name until some future date when a stable ABI is declared.
+
+SHARED     := 1
+
+# for lib$(NAME).so and /usr/include/($NAME) and such
+NAME       :=  proc
+
+LIBVERSION := $(VERSION).$(SUBVERSION).$(MINORVERSION)
+ABIVERSION := 0
+
+SOFILE     := lib$(NAME)-$(LIBVERSION).so
+ifneq ($(ABIVERSION),0)
+SOLINK     := lib$(NAME).so
+SONAME     := lib$(NAME).so.$(ABIVERSION)
+else
+SONAME     := $(SOFILE)
+SOLINK     := $(SOFILE)
+endif
+
+ANAME      := lib$(NAME).a
+
+############
+
+FPIC       := -fpic
+
+ifeq ($(SHARED),1)
+ALL        += proc/$(SONAME)
+INSTALL    += ldconfig
+LIBFLAGS   := -DSHARED=1 $(FPIC)
+# This is in gcc 3.5, but exported functions must be marked.
+#LIBFLAGS += $(call check_gcc,-fvisibility=hidden,)
+LIBPROC    := proc/$(SONAME)
+else
+ALL        += proc/$(ANAME)
+#INSTALL    += $(usr/lib)$(ANAME)
+LIBFLAGS   := -DSHARED=0
+LIBPROC    := proc/$(ANAME)
+endif
+
+LIBSRC :=  $(wildcard proc/*.c)
+LIBHDR :=  $(wildcard proc/*.h)
+LIBOBJ :=  $(LIBSRC:.c=.o)
+
+# Separate rule for this directory, to use -fpic or -fPIC
+$(filter-out proc/version.o,$(LIBOBJ)): proc/%.o: proc/%.c
+	$(CC) -c $(ALL_CPPFLAGS) $(ALL_CFLAGS) $(LIBFLAGS) $< -o $@
+
+LIB_X := COPYING module.mk library.map
+TARFILES += $(LIBSRC) $(LIBHDR) $(addprefix proc/,$(LIB_X))
+
+
+# Clean away all output files, .depend, and symlinks.
+# Use wildcards in case the version has changed.
+CLEAN += proc/.depend proc/lib*.so* proc/lib*.a $(LIBOBJ)
+DIRS  += proc/
+
+proc/$(ANAME): $(LIBOBJ)
+	$(AR) rcs $@ $^
+
+#proc/$(SONAME): proc/library.map
+proc/$(SONAME): $(LIBOBJ)
+	$(CC) $(ALL_CFLAGS) $(ALL_LDFLAGS) -shared -Wl,-soname,$(SONAME) -Wl,--version-script=proc/library.map -o $@ $^ -lc
+
+
+# AUTOMATIC DEPENDENCY GENERATION -- GCC AND GNUMAKE DEPENDENT
+proc/.depend: $(LIBSRC) $(LIBHDR)
+	$(strip $(CC) $(ALL_CPPFLAGS) $(LIB_CFLAGS) -MM -MG $(LIBSRC) > $@)
+
+ifneq ($(MAKECMDGOALS),clean)
+ifneq ($(MAKECMDGOALS),tar)
+ifneq ($(MAKECMDGOALS),extratar)
+ifneq ($(MAKECMDGOALS),beta)
+-include proc/.depend
+endif
+endif
+endif
+endif
+
+#################### install rules ###########################
+
+$(lib)$(SOFILE) : proc/$(SONAME)
+	$(install) --mode a=rx $< $@
+
+ifneq ($(SOLINK),$(SOFILE))
+.PHONY: $(lib)$(SOLINK)
+$(lib)$(SOLINK) : $(lib)$(SOFILE)
+	cd $(lib) && $(ln_sf) $(SOFILE) $(SOLINK)
+endif
+
+ifneq ($(SONAME),$(SOFILE))
+.PHONY: $(lib)$(SONAME)
+$(lib)$(SONAME) : $(lib)$(SOFILE)
+	cd $(lib) && $(ln_sf) $(SOFILE) $(SONAME)
+endif
+
+.PHONY: ldconfig
+ldconfig : $(lib)$(SONAME) $(lib)$(SOLINK)
+	$(ldconfig)
+
+$(usr/lib)$(ANAME) : proc/$(ANAME)
+	$(install) --mode a=r $< $@
+
+# Junk anyway... supposed to go in /usr/include/$(NAME)
+#INSTALL += $(addprefix $(include),$(HDRFILES))
+#
+#$(addprefix $(include),$(HDRFILES)): $(include)% : proc/%
+#$(include)% : proc/%
+#	$(install) --mode a=r $< $@
+
+##################################################################
+
+proc/version.o:	proc/version.c proc/version.h
+	$(CC) $(ALL_CPPFLAGS) $(ALL_CFLAGS) $(LIBFLAGS) -DVERSION=\"$(VERSION)\" -DSUBVERSION=\"$(SUBVERSION)\" -DMINORVERSION=\"$(MINORVERSION)\" -c -o $@ $<
diff --git a/pgrep.1 b/pgrep.1
deleted file mode 100644
index eba694bb..00000000
--- a/pgrep.1
+++ /dev/null
@@ -1,177 +0,0 @@
-.\" Manual page for pgrep / pkill.
-.\" Licensed under version 2 of the GNU General Public License.
-.\" Copyright 2000 Kjetil Torgrim Homme
-.\"
-.TH PGREP 1 "October 5, 2007" "Linux" "Linux User's Manual"
-.SH NAME
-pgrep, pkill \- look up or signal processes based on name and other attributes
-
-.SH SYNOPSIS
-.na
-\fBpgrep\fR [\fB\-flvx\fR] [\fB\-d\ \fIdelimiter\fR] [\fB\-n\fR|\fB\-o\fR] \
-[\fB\-P\ \fIppid\fR,...] [\fB\-g\ \fIpgrp\fR,...] [\fB\-s\ \fIsid\fR,...] \
-[\fB\-u\ \fIeuid\fR,...] [\fB\-U\ \fIuid\fR,...] [\fB\-G\ \fIgid\fR,...] \
-[\fB\-t\ \fIterm\fR,...] [\fIpattern\fR]
-
-.HP
-\fBpkill\fR [\fB\-\fIsignal\fR] [\fB\-fvx\fR] [\fB\-n\fR|\fB\-o\fR] \
-[\fB\-P\ \fIppid\fR,...] [\fB\-g\ \fIpgrp\fR,...] [\fB\-s\ \fIsid\fR,...] \
-[\fB\-u\ \fIeuid\fR,...] [\fB\-U\ \fIuid\fR,...] [\fB\-G\ \fIgid\fR,...] \
-[\fB\-t\ \fIterm\fR,...] [\fIpattern\fR]
-
-.SH DESCRIPTION
-\fBpgrep\fP looks through the currently running processes and lists the
-process IDs which matches the selection criteria to stdout.  All
-the criteria have to match.  For example,
-
-.IP
-$ pgrep \-u root sshd
-
-.PP
-will only list the processes called \fBsshd\fP AND owned by \fBroot\fP.
-On the other hand,
-
-.IP
-$ pgrep \-u root,daemon
-
-.PP
-will list the processes owned by \fBroot\fP OR \fBdaemon\fP.
-
-\fBpkill\fP will send the specified signal (by default \fBSIGTERM\fP)
-to each process instead of listing them on stdout.
-
-.SH OPTIONS
-.TP
-\fB\-d \fIdelimiter\fP
-Sets the string used to delimit each process ID in the output (by
-default a newline).  (\fBpgrep\fP only.)
-.TP
-\fB\-f\fR
-The \fIpattern\fP is normally only matched against the process name.
-When \fB\-f\fR is set, the full command line is used.
-.TP
-\fB\-g \fIpgrp\fP,...
-Only match processes in the process group IDs listed.  Process group 0
-is translated into \fBpgrep\fP's or \fBpkill\fP's own process group.
-.TP
-\-G \fIgid\fP,...
-Only match processes whose real group ID is listed.  Either the
-numerical or symbolical value may be used.
-.TP
-\fB\-l\fR
-List the process name as well as the process ID. (\fBpgrep\fP only.)
-.TP
-\fB\-n\fR
-Select only the newest (most recently started) of the matching
-processes.
-.TP
-\fB\-o\fR
-Select only the oldest (least recently started) of the matching
-processes.
-.TP
-\fB\-P \fIppid\fP,...
-Only match processes whose parent process ID is listed.
-.TP
-\fB\-s \fIsid\fP,...
-Only match processes whose process session ID is listed.  Session ID 0
-is translated into \fBpgrep\fP's or \fBpkill\fP's own session ID.
-.TP
-\fB\-t \fIterm\fP,...
-Only match processes whose controlling terminal is listed.  The
-terminal name should be specified without the "/dev/" prefix.
-.TP
-\fB\-u \fIeuid\fP,...
-Only match processes whose effective user ID is listed.  Either the
-numerical or symbolical value may be used.
-.TP
-\fB\-U \fIuid\fP,...
-Only match processes whose real user ID is listed.  Either the
-numerical or symbolical value may be used.
-.TP
-\fB\-v\fR
-Negates the matching.
-.TP
-\fB\-x\fR
-Only match processes whose name (or command line if \-f is specified)
-\fBexactly\fP match the \fIpattern\fP.
-.TP
-\-\fIsignal\fP
-Defines the signal to send to each matched process.  Either the
-numeric or the symbolic signal name can be used.  (\fBpkill\fP only.)
-
-.SH OPERANDS
-.TP
-\fIpattern\fP
-Specifies an Extended Regular Expression for matching against the
-process names or command lines.
-
-.SH EXAMPLES
-Example 1: Find the process ID of the \fBnamed\fP daemon:
-
-.IP
-$ pgrep \-u root named
-
-.PP
-Example 2: Make \fBsyslog\fP reread its configuration file:
-
-.IP
-$ pkill \-HUP syslogd
-
-.PP
-Example 3: Give detailed information on all \fBxterm\fP processes:
-
-.IP
-$ ps \-fp $(pgrep \-d, \-x xterm)
-
-.PP
-Example 4: Make all \fBnetscape\fP processes run nicer:
-
-.IP
-$ renice +4 `pgrep netscape`
-
-.SH "EXIT STATUS"
-.PD 0
-.TP
-.I 0
-One or more processes matched the criteria.
-.TP
-.I 1
-No processes matched.
-.TP
-.I 2
-Syntax error in the command line.
-.TP
-.I 3
-Fatal error: out of memory etc.
-
-.SH NOTES
-The process name used for matching is limited to the 15 characters
-present in the output of /proc/\fIpid\fP/stat.  Use the \-f option to
-match against the complete command line, /proc/\fIpid\fP/cmdline.
-
-The running \fBpgrep\fP or \fBpkill\fP process will never report
-itself as a match.
-
-.SH BUGS
-The options \fB\-n\fP and \fB\-o\fP and \fB\-v\fP can not be combined.
-Let me know if you need to do this.
-
-Defunct processes are reported.
-
-.SH "SEE ALSO"
-.BR ps (1),
-.BR regex (7),
-.BR signal (7),
-.BR killall (1),
-.BR skill (1),
-.BR kill (1),
-.BR kill (2)
-
-.SH STANDARDS
-\fBpkill\fP and \fBpgrep\fP were introduced in Sun's Solaris 7.  This
-implementation is fully compatible.
-
-.SH AUTHOR
-Kjetil Torgrim Homme <kjetilho@ifi.uio.no>
-
-Please send bug reports to <procps@freelists.org>
diff --git a/pgrep.c b/pgrep.c
deleted file mode 100644
index 5492fa72..00000000
--- a/pgrep.c
+++ /dev/null
@@ -1,738 +0,0 @@
-/* emacs settings:  -*- c-basic-offset: 8 tab-width: 8 -*-
- *
- * pgrep/pkill -- utilities to filter the process table
- *
- * Copyright 2000 Kjetil Torgrim Homme <kjetilho@ifi.uio.no>
- *
- * May be distributed under the conditions of the
- * GNU General Public License; a copy is in COPYING
- *
- * Changes by Albert Cahalan, 2002,2006.
- * 
- */
-
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <limits.h>
-#include <unistd.h>
-#include <ctype.h>
-#include <string.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <signal.h>
-#include <pwd.h>
-#include <grp.h>
-#include <regex.h>
-#include <errno.h>
-
-#include "proc/readproc.h"
-#include "proc/sig.h"
-#include "proc/devname.h"
-#include "proc/sysinfo.h"
-#include "proc/version.h" /* procps_version */
-
-// EXIT_SUCCESS is 0
-// EXIT_FAILURE is 1
-#define EXIT_USAGE 2
-#define EXIT_FATAL 3
-
-static int i_am_pkill = 0;
-static const char *progname = "pgrep";
-
-union el {
-	long	num;
-	char *	str;
-};
-
-/* User supplied arguments */
-
-static int opt_full = 0;
-static int opt_long = 0;
-static int opt_oldest = 0;
-static int opt_newest = 0;
-static int opt_negate = 0;
-static int opt_exact = 0;
-static int opt_signal = SIGTERM;
-static int opt_lock = 0;
-static int opt_case = 0;
-
-static const char *opt_delim = "\n";
-static union el *opt_pgrp = NULL;
-static union el *opt_rgid = NULL;
-static union el *opt_pid = NULL;
-static union el *opt_ppid = NULL;
-static union el *opt_sid = NULL;
-static union el *opt_term = NULL;
-static union el *opt_euid = NULL;
-static union el *opt_ruid = NULL;
-static char *opt_pattern = NULL;
-static char *opt_pidfile = NULL;
-
-static int usage (int opt) NORETURN;
-static int usage (int opt)
-{
-	int err = (opt=='?'); /* getopt() uses '?' to mark an error */
-	FILE *fp = err ? stderr : stdout;
-
-	if (i_am_pkill)
-		fprintf (fp, "Usage: pkill [-SIGNAL] [-fvx] ");
-	else
-		fprintf (fp, "Usage: pgrep [-flvx] [-d DELIM] ");
-	fprintf (fp, "[-n|-o] [-P PPIDLIST] [-g PGRPLIST] [-s SIDLIST]\n"
-		 "\t[-u EUIDLIST] [-U UIDLIST] [-G GIDLIST] [-t TERMLIST] "
-		 "[PATTERN]\n");
-
-	exit(err ? EXIT_USAGE : EXIT_SUCCESS);
-}
-
-
-static union el *split_list (const char *restrict str, int (*convert)(const char *, union el *))
-{
-	char *copy = strdup (str);
-	char *ptr = copy;
-	char *sep_pos;
-	int i = 0;
-	int size = 0;
-	union el *list = NULL;
-
-	do {
-		if (i == size) {
-			size = size * 5 / 4 + 4;
-			// add 1 because slot zero is a count
-			list = realloc (list, 1 + size * sizeof *list);
-			if (list == NULL)
-				exit (EXIT_FATAL);
-		}
-		sep_pos = strchr (ptr, ',');
-		if (sep_pos)
-			*sep_pos = 0;
-		// Use ++i instead of i++ because slot zero is a count
-		if (!convert (ptr, &list[++i]))
-			exit (EXIT_USAGE);
-		if (sep_pos)
-			ptr = sep_pos + 1;
-	} while (sep_pos);
-
-	free (copy);
-	if (!i) {
-		free (list);
-		list = NULL;
-	} else {
-		list[0].num = i;
-	}
-	return list;
-}
-
-// strict_atol returns a Boolean: TRUE if the input string
-// contains a plain number, FALSE if there are any non-digits.
-static int strict_atol (const char *restrict str, long *restrict value)
-{
-	int res = 0;
-	int sign = 1;
-
-	if (*str == '+')
-		++str;
-	else if (*str == '-') {
-		++str;
-		sign = -1;
-	}
-
-	for ( ; *str; ++str) {
-		if (! isdigit (*str))
-			return (0);
-		res *= 10;
-		res += *str - '0';
-	}
-	*value = sign * res;
-	return 1;
-}
-
-#include <sys/file.h>
-
-// Seen non-BSD code do this:
-//
-//if (fcntl_lock(pid_fd, F_SETLK, F_WRLCK, SEEK_SET, 0, 0) == -1)
-//                return -1;
-int fcntl_lock(int fd, int cmd, int type, int whence, int start, int len)
-{
-        struct flock lock[1];
-
-        lock->l_type = type;
-        lock->l_whence = whence;
-        lock->l_start = start;
-        lock->l_len = len;
-
-        return fcntl(fd, cmd, lock);
-}
-                                                
-
-// We try a read lock. The daemon should have a write lock.
-// Seen using flock: FreeBSD code
-static int has_flock(int fd)
-{
-	return flock(fd, LOCK_SH|LOCK_NB)==-1 && errno==EWOULDBLOCK;
-}
-
-// We try a read lock. The daemon should have a write lock.
-// Seen using fcntl: libslack
-static int has_fcntl(int fd)
-{
-	struct flock f;  // seriously, struct flock is for a fnctl lock!
-	f.l_type = F_RDLCK;
-	f.l_whence = SEEK_SET;
-	f.l_start = 0;
-	f.l_len = 0;
-	return fcntl(fd,F_SETLK,&f)==-1 && (errno==EACCES || errno==EAGAIN);
-}
-
-static union el *read_pidfile(void)
-{
-	char buf[12];
-	int fd;
-	struct stat sbuf;
-	char *endp;
-	int n, pid;
-	union el *list = NULL;
-
-	fd = open(opt_pidfile, O_RDONLY|O_NOCTTY|O_NONBLOCK);
-	if(fd<0)
-		goto just_ret;
-	if(fstat(fd,&sbuf) || !S_ISREG(sbuf.st_mode) || sbuf.st_size<1)
-		goto out;
-	// type of lock, if any, is not standardized on Linux
-	if(opt_lock && !has_flock(fd) && !has_fcntl(fd))
-		goto out;
-	memset(buf,'\0',sizeof buf);
-	n = read(fd,buf+1,sizeof buf-2);
-	if (n<1)
-		goto out;
-	buf[n] = '\0';
-	pid = strtoul(buf+1,&endp,10);
-	if(endp<=buf+1 || pid<1 || pid>0x7fffffff)
-		goto out;
-	if(*endp && !isspace(*endp))
-		goto out;
-	list = malloc(2 * sizeof *list);
-	list[0].num = 1;
-	list[1].num = pid;
-out:
-	close(fd);
-just_ret:
-	return list;
-}
-
-static int conv_uid (const char *restrict name, union el *restrict e)
-{
-	struct passwd *pwd;
-
-	if (strict_atol (name, &e->num))
-		return (1);
-
-	pwd = getpwnam (name);
-	if (pwd == NULL) {
-		fprintf (stderr, "%s: invalid user name: %s\n",
-			 progname, name);
-		return 0;
-	}
-	e->num = pwd->pw_uid;
-	return 1;
-}
-
-
-static int conv_gid (const char *restrict name, union el *restrict e)
-{
-	struct group *grp;
-
-	if (strict_atol (name, &e->num))
-		return 1;
-
-	grp = getgrnam (name);
-	if (grp == NULL) {
-		fprintf (stderr, "%s: invalid group name: %s\n",
-			 progname, name);
-		return 0;
-	}
-	e->num = grp->gr_gid;
-	return 1;
-}
-
-
-static int conv_pgrp (const char *restrict name, union el *restrict e)
-{
-	if (! strict_atol (name, &e->num)) {
-		fprintf (stderr, "%s: invalid process group: %s\n",
-			 progname, name);
-		return 0;
-	}
-	if (e->num == 0)
-		e->num = getpgrp ();
-	return 1;
-}
-
-
-static int conv_sid (const char *restrict name, union el *restrict e)
-{
-	if (! strict_atol (name, &e->num)) {
-		fprintf (stderr, "%s: invalid session id: %s\n",
-			 progname, name);
-		return 0;
-	}
-	if (e->num == 0)
-		e->num = getsid (0);
-	return 1;
-}
-
-
-static int conv_num (const char *restrict name, union el *restrict e)
-{
-	if (! strict_atol (name, &e->num)) {
-		fprintf (stderr, "%s: not a number: %s\n",
-			 progname, name);
-		return 0;
-	}
-	return 1;
-}
-
-
-static int conv_str (const char *restrict name, union el *restrict e)
-{
-	e->str = strdup (name);
-	return 1;
-}
-
-
-static int match_numlist (long value, const union el *restrict list)
-{
-	int found = 0;
-	if (list == NULL)
-		found = 0;
-	else {
-		int i;
-		for (i = list[0].num; i > 0; i--) {
-			if (list[i].num == value)
-				found = 1;
-		}
-	}
-	return found;
-}
-
-static int match_strlist (const char *restrict value, const union el *restrict list)
-{
-	int found = 0;
-	if (list == NULL)
-		found = 0;
-	else {
-		int i;
-		for (i = list[0].num; i > 0; i--) {
-			if (! strcmp (list[i].str, value))
-				found = 1;
-		}
-	}
-	return found;
-}
-
-static void output_numlist (const union el *restrict list, int num)
-{
-	int i;
-	const char *delim = opt_delim;
-	for (i = 0; i < num; i++) {
-		if(i+1==num)
-			delim = "\n";
-		printf ("%ld%s", list[i].num, delim);
-	}
-}
-
-static void output_strlist (const union el *restrict list, int num)
-{
-// FIXME: escape codes
-	int i;
-	const char *delim = opt_delim;
-	for (i = 0; i < num; i++) {
-		if(i+1==num)
-			delim = "\n";
-		printf ("%s%s", list[i].str, delim);
-	}
-}
-
-static PROCTAB *do_openproc (void)
-{
-	PROCTAB *ptp;
-	int flags = 0;
-
-	if (opt_pattern || opt_full)
-		flags |= PROC_FILLCOM;
-	if (opt_ruid || opt_rgid)
-		flags |= PROC_FILLSTATUS;
-	if (opt_oldest || opt_newest || opt_pgrp || opt_sid || opt_term)
-		flags |= PROC_FILLSTAT;
-	if (!(flags & PROC_FILLSTAT))
-		flags |= PROC_FILLSTATUS;  // FIXME: need one, and PROC_FILLANY broken
-	if (opt_euid && !opt_negate) {
-		int num = opt_euid[0].num;
-		int i = num;
-		uid_t *uids = malloc (num * sizeof (uid_t));
-		if (uids == NULL)
-			exit (EXIT_FATAL);
-		while (i-- > 0) {
-			uids[i] = opt_euid[i+1].num;
-		}
-		flags |= PROC_UID;
-		ptp = openproc (flags, uids, num);
-		free(uids);
-	} else {
-		ptp = openproc (flags);
-	}
-	return ptp;
-}
-
-static regex_t * do_regcomp (void)
-{
-	regex_t *preg = NULL;
-
-	if (opt_pattern) {
-		char *re;
-		char errbuf[256];
-		int re_err;
-
-		preg = malloc (sizeof (regex_t));
-		if (preg == NULL)
-			exit (EXIT_FATAL);
-		if (opt_exact) {
-			re = malloc (strlen (opt_pattern) + 5);
-			if (re == NULL)
-				exit (EXIT_FATAL);
-			sprintf (re, "^(%s)$", opt_pattern);
-		} else {
-		 	re = opt_pattern;
-		}
-
-		re_err = regcomp (preg, re, REG_EXTENDED | REG_NOSUB | opt_case);
-		free(re);
-		if (re_err) {
-			regerror (re_err, preg, errbuf, sizeof(errbuf));
-			fputs(errbuf,stderr);
-			exit (EXIT_USAGE);
-		}
-	}
-	return preg;
-}
-
-static union el * select_procs (int *num)
-{
-	PROCTAB *ptp;
-	proc_t task;
-	unsigned long long saved_start_time;      // for new/old support
-	pid_t saved_pid = 0;                      // for new/old support
-	int matches = 0;
-	int size = 0;
-	regex_t *preg;
-	pid_t myself = getpid();
-	union el *list = NULL;
-	char cmd[4096];
-
-	ptp = do_openproc();
-	preg = do_regcomp();
-
-	if (opt_newest) saved_start_time =  0ULL;
-	if (opt_oldest) saved_start_time = ~0ULL;
-	if (opt_newest) saved_pid = 0;
-	if (opt_oldest) saved_pid = INT_MAX;
-	
-	memset(&task, 0, sizeof (task));
-	while(readproc(ptp, &task)) {
-		int match = 1;
-
-		if (task.XXXID == myself)
-			continue;
-		else if (opt_newest && task.start_time < saved_start_time)
-			match = 0;
-		else if (opt_oldest && task.start_time > saved_start_time)
-			match = 0;
-		else if (opt_ppid && ! match_numlist (task.ppid, opt_ppid))
-			match = 0;
-		else if (opt_pid && ! match_numlist (task.tgid, opt_pid))
-			match = 0;
-		else if (opt_pgrp && ! match_numlist (task.pgrp, opt_pgrp))
-			match = 0;
-		else if (opt_euid && ! match_numlist (task.euid, opt_euid))
-			match = 0;
-		else if (opt_ruid && ! match_numlist (task.ruid, opt_ruid))
-			match = 0;
-		else if (opt_rgid && ! match_numlist (task.rgid, opt_rgid))
-			match = 0;
-		else if (opt_sid && ! match_numlist (task.session, opt_sid))
-			match = 0;
-		else if (opt_term) {
-			if (task.tty == 0) {
-				match = 0;
-			} else {
-				char tty[256];
-				dev_to_tty (tty, sizeof(tty) - 1,
-					    task.tty, task.XXXID, ABBREV_DEV);
-				match = match_strlist (tty, opt_term);
-			}
-		}
-		if (opt_long || (match && opt_pattern)) {
-			if (opt_full && task.cmdline) {
-				int i = 0;
-				int bytes = sizeof (cmd) - 1;
-
-				/* make sure it is always NUL-terminated */
-				cmd[bytes] = 0;
-				/* make room for SPC in loop below */
-				--bytes;
-
-				strncpy (cmd, task.cmdline[i], bytes);
-				bytes -= strlen (task.cmdline[i++]);
-				while (task.cmdline[i] && bytes > 0) {
-					strncat (cmd, " ", bytes);
-					strncat (cmd, task.cmdline[i], bytes);
-					bytes -= strlen (task.cmdline[i++]) + 1;
-				}
-			} else {
-				strcpy (cmd, task.cmd);
-			}
-		}
-
-		if (match && opt_pattern) {
-			if (regexec (preg, cmd, 0, NULL, 0) != 0)
-				match = 0;
-		}
-
-		if (match ^ opt_negate) {	/* Exclusive OR is neat */
-			if (opt_newest) {
-				if (saved_start_time == task.start_time &&
-				    saved_pid > task.XXXID)
-					continue;
-				saved_start_time = task.start_time;
-				saved_pid = task.XXXID;
-				matches = 0;
-			}
-			if (opt_oldest) {
-				if (saved_start_time == task.start_time &&
-				    saved_pid < task.XXXID)
-					continue;
-				saved_start_time = task.start_time;
-				saved_pid = task.XXXID;
-				matches = 0;
-			}
-			if (matches == size) {
-				size = size * 5 / 4 + 4;
-				list = realloc(list, size * sizeof *list);
-				if (list == NULL)
-					exit (EXIT_FATAL);
-			}
-			if (opt_long) {
-				char buff[5096];  // FIXME
-				sprintf (buff, "%d %s", task.XXXID, cmd);
-				list[matches++].str = strdup (buff);
-			} else {
-				list[matches++].num = task.XXXID;
-			}
-		}
-		
-		memset (&task, 0, sizeof (task));
-	}
-	closeproc (ptp);
-	*num = matches;
-	free(preg);
-	return list;
-}
-
-
-static void parse_opts (int argc, char **argv)
-{
-	char opts[32] = "";
-	int opt;
-	int criteria_count = 0;
-
-	if (strstr (argv[0], "pkill")) {
-		i_am_pkill = 1;
-		progname = "pkill";
-		/* Look for a signal name or number as first argument */
-		if (argc > 1 && argv[1][0] == '-') {
-			int sig;
-			sig = signal_name_to_number (argv[1] + 1);
-			if (sig == -1 && isdigit (argv[1][1]))
-				sig = atoi (argv[1] + 1);
-			if (sig != -1) {
-				int i;
-				for (i = 2; i < argc; i++)
-					argv[i-1] = argv[i];
-				--argc;
-				opt_signal = sig;
-			}
-		}
-	} else {
-		/* These options are for pgrep only */
-		strcat (opts, "ld:");
-	}
-			
-	strcat (opts, "LF:fnovxP:g:s:u:U:G:t:?V");
-	
-	while ((opt = getopt (argc, argv, opts)) != -1) {
-		switch (opt) {
-//		case 'D':   // FreeBSD: print info about non-matches for debugging
-//			break;
-		case 'F':   // FreeBSD: the arg is a file containing a PID to match
-			opt_pidfile = strdup (optarg);
-			++criteria_count;
-			break;
-		case 'G':   // Solaris: match rgid/rgroup
-	  		opt_rgid = split_list (optarg, conv_gid);
-			if (opt_rgid == NULL)
-				usage (opt);
-			++criteria_count;
-			break;
-//		case 'I':   // FreeBSD: require confirmation before killing
-//			break;
-//		case 'J':   // Solaris: match by project ID (name or number)
-//			break;
-		case 'L':   // FreeBSD: fail if pidfile (see -F) not locked
-			opt_lock++;
-			break;
-//		case 'M':   // FreeBSD: specify core (OS crash dump) file
-//			break;
-//		case 'N':   // FreeBSD: specify alternate namelist file (for us, System.map -- but we don't need it)
-//			break;
-		case 'P':   // Solaris: match by PPID
-	  		opt_ppid = split_list (optarg, conv_num);
-			if (opt_ppid == NULL)
-				usage (opt);
-			++criteria_count;
-			break;
-//		case 'S':   // FreeBSD: don't ignore the built-in kernel tasks
-//			break;
-//		case 'T':   // Solaris: match by "task ID" (probably not a Linux task)
-//			break;
-		case 'U':   // Solaris: match by ruid/rgroup
-	  		opt_ruid = split_list (optarg, conv_uid);
-			if (opt_ruid == NULL)
-				usage (opt);
-			++criteria_count;
-			break;
-		case 'V':
-			fprintf(stdout, "%s (%s)\n", progname, procps_version);
-			exit(EXIT_SUCCESS);
-//		case 'c':   // Solaris: match by contract ID
-//			break;
-		case 'd':   // Solaris: change the delimiter
-			opt_delim = strdup (optarg);
-			break;
-		case 'f':   // Solaris: match full process name (as in "ps -f")
-			opt_full = 1;
-			break;
-		case 'g':   // Solaris: match pgrp
-	  		opt_pgrp = split_list (optarg, conv_pgrp);
-			if (opt_pgrp == NULL)
-				usage (opt);
-			++criteria_count;
-			break;
-//		case 'i':   // FreeBSD: ignore case. OpenBSD: withdrawn. See -I. This sucks.
-//			if (opt_case)
-//				usage (opt);
-//			opt_case = REG_ICASE;
-//			break;
-//		case 'j':   // FreeBSD: restricted to the given jail ID
-//			break;
-		case 'l':   // Solaris: long output format (pgrep only) Should require -f for beyond argv[0] maybe?
-			opt_long = 1;
-			break;
-		case 'n':   // Solaris: match only the newest
-			if (opt_oldest|opt_negate|opt_newest)
-				usage (opt);
-			opt_newest = 1;
-			++criteria_count;
-			break;
-		case 'o':   // Solaris: match only the oldest
-			if (opt_oldest|opt_negate|opt_newest)
-				usage (opt);
-			opt_oldest = 1;
-			++criteria_count;
-			break;
-		case 's':   // Solaris: match by session ID -- zero means self
-	  		opt_sid = split_list (optarg, conv_sid);
-			if (opt_sid == NULL)
-				usage (opt);
-			++criteria_count;
-			break;
-		case 't':   // Solaris: match by tty
-	  		opt_term = split_list (optarg, conv_str);
-			if (opt_term == NULL)
-				usage (opt);
-			++criteria_count;
-			break;
-		case 'u':   // Solaris: match by euid/egroup
-	  		opt_euid = split_list (optarg, conv_uid);
-			if (opt_euid == NULL)
-				usage (opt);
-			++criteria_count;
-			break;
-		case 'v':   // Solaris: as in grep, invert the matching (uh... applied after selection I think)
-			if (opt_oldest|opt_negate|opt_newest)
-				usage (opt);
-	  		opt_negate = 1;
-			break;
-		// OpenBSD -x, being broken, does a plain string
-		case 'x':   // Solaris: use ^(regexp)$ in place of regexp (FreeBSD too)
-			opt_exact = 1;
-			break;
-//		case 'z':   // Solaris: match by zone ID
-//			break;
-		case '?':
-			usage (opt);
-			break;
-		}
-	}
-
-	if(opt_lock && !opt_pidfile){
-		fprintf(stderr, "%s: -L without -F makes no sense\n",progname);
-		usage(0);
-	}
-
-	if(opt_pidfile){
-		opt_pid = read_pidfile();
-		if(!opt_pid){
-			fprintf(stderr, "%s: pidfile not valid\n",progname);
-			usage(0);
-		}
-	}
-
-        if (argc - optind == 1)
-		opt_pattern = argv[optind];
-	else if (argc - optind > 1)
-		usage (0);
-	else if (criteria_count == 0) {
-		fprintf (stderr, "%s: No matching criteria specified\n",
-			 progname);
-		usage (0);
-	}
-}
-
-
-int main (int argc, char *argv[])
-{
-	union el *procs;
-	int num;
-
-	parse_opts (argc, argv);
-
-	procs = select_procs (&num);
-	if (i_am_pkill) {
-		int i;
-		for (i = 0; i < num; i++) {
-			if (kill (procs[i].num, opt_signal) != -1) continue;
-			if (errno==ESRCH) continue; // gone now, which is OK
-			fprintf (stderr, "pkill: %ld - %s\n",
-				 procs[i].num, strerror (errno));
-		}
-	} else {
-		if (opt_long)
-			output_strlist(procs,num);
-		else
-			output_numlist(procs,num);
-	}
-	return !num; // exit(EXIT_SUCCESS) if match, otherwise exit(EXIT_FAILURE)
-}
diff --git a/pkill.1 b/pkill.1
deleted file mode 100644
index 0e94b52c..00000000
--- a/pkill.1
+++ /dev/null
@@ -1 +0,0 @@
-.so man1/pgrep.1
diff --git a/pmap.1 b/pmap.1
deleted file mode 100644
index 9327c6bc..00000000
--- a/pmap.1
+++ /dev/null
@@ -1,41 +0,0 @@
-'\" t
-.\" (The preceding line is a note to broken versions of man to tell
-.\" them to pre-process this man page with tbl)
-.\" Man page for pmap.
-.\" Licensed under version 2 of the GNU General Public License.
-.\" Written by Albert Cahalan.
-.\"
-.TH PMAP 1 "October 26, 2002" "Linux" "Linux User's Manual"
-.SH NAME
-pmap \- report memory map of a process
-
-.SH SYNOPSIS
-.B pmap
-.RB [ \-x | \-d ]
-.RB [ \-q ]
-.I pid
-\& ...
-.br
-.B pmap \-V
-
-.SH DESCRIPTION
-The pmap command reports the memory map of a process or processes.
-
-.SH "GENERAL OPTIONS"
-.TS
-lB l l.
-\-x	extended	Show the extended format.
-\-d	device	Show the device format.
-\-q	quiet	Do not display some header/footer lines.
-\-V	show version	Displays version of program.
-.TE
-
-.SH "SEE ALSO"
-.BR ps (1),
-.BR pgrep (1)
-
-.SH STANDARDS
-No standards apply, but pmap looks an awful lot like a SunOS command.
-
-.SH BUG REPORTS
-Please send bug reports to <procps@freelists.org>
diff --git a/pmap.c b/pmap.c
deleted file mode 100644
index 1df1a852..00000000
--- a/pmap.c
+++ /dev/null
@@ -1,373 +0,0 @@
-/*
- * Copyright 2002 by Albert Cahalan; all rights reserved.
- * This file may be used subject to the terms and conditions of the
- * GNU Library General Public License Version 2, or any later version
- * at your option, as published by the Free Software Foundation.
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Library General Public License for more details.
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <ctype.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <string.h>
-#include <unistd.h>
-
-#include <sys/ipc.h>
-#include <sys/shm.h>
-
-#include "proc/readproc.h"
-#include "proc/version.h"
-#include "proc/escape.h"
-
-static void usage(void) NORETURN;
-static void usage(void){
-  fprintf(stderr,
-    "Usage: pmap [-x | -d] [-q] [-A low,high] pid...\n"
-    "-x  show details\n"
-    "-d  show offset and device number\n"
-    "-q  quiet; less header/footer info\n"
-    "-V  show the version number\n"
-    "-A  limit results to the given range\n"
-  );
-  exit(1);
-}
-
-
-static unsigned KLONG range_low;
-static unsigned KLONG range_high = ~0ull;
-
-static int V_option;
-static int r_option;  // ignored -- for SunOS compatibility
-static int x_option;
-static int d_option;
-static int q_option;
-
-static unsigned shm_minor = ~0u;
-
-static void discover_shm_minor(void){
-  void *addr;
-  int shmid;
-  char mapbuf[256];
-
-  if(!freopen("/proc/self/maps", "r", stdin)) return;
-
-  // create
-  shmid = shmget(IPC_PRIVATE, 42, IPC_CREAT | 0666);
-  if(shmid==-1) return; // failed; oh well
-  // attach
-  addr = shmat(shmid, NULL, SHM_RDONLY);
-  if(addr==(void*)-1) goto out_destroy;
-
-  while(fgets(mapbuf, sizeof mapbuf, stdin)){
-    char flags[32];
-    char *tmp; // to clean up unprintables
-    unsigned KLONG start, end;
-    unsigned long long file_offset, inode;
-    unsigned dev_major, dev_minor;
-    sscanf(mapbuf,"%"KLF"x-%"KLF"x %31s %Lx %x:%x %Lu", &start, &end, flags, &file_offset, &dev_major, &dev_minor, &inode);
-    tmp = strchr(mapbuf,'\n');
-    if(tmp) *tmp='\0';
-    tmp = mapbuf;
-    while(*tmp){
-      if(!isprint(*tmp)) *tmp='?';
-      tmp++;
-    }
-    if(start > (unsigned long)addr) continue;
-    if(dev_major) continue;
-    if(flags[3] != 's') continue;
-    if(strstr(mapbuf,"/SYSV")){
-      shm_minor = dev_minor;
-      break;
-    }
-  }
-
-  if(shmdt(addr)) perror("shmdt");
-
-out_destroy:
-  if(shmctl(shmid, IPC_RMID, NULL)) perror("IPC_RMID");
-
-  return;
-}
-
-
-static const char *mapping_name(proc_t *p, unsigned KLONG addr, unsigned KLONG len, const char *mapbuf, unsigned showpath, unsigned dev_major, unsigned dev_minor, unsigned long long inode){
-  const char *cp;
-
-  if(!dev_major && dev_minor==shm_minor && strstr(mapbuf,"/SYSV")){
-    static char shmbuf[64];
-    snprintf(shmbuf, sizeof shmbuf, "  [ shmid=0x%Lx ]", inode);
-    return shmbuf;
-  }
-
-  cp = strrchr(mapbuf,'/');
-  if(cp){
-    if(showpath) return strchr(mapbuf,'/');
-    return cp[1] ? cp+1 : cp;
-  }
-
-  cp = strchr(mapbuf,'/');
-  if(cp){
-    if(showpath) return cp;
-    return strrchr(cp,'/') + 1;  // it WILL succeed
-  }
-
-  cp = "  [ anon ]";
-  if( (p->start_stack >= addr) && (p->start_stack <= addr+len) )  cp = "  [ stack ]";
-  return cp;
-}
-
-static int one_proc(proc_t *p){
-  char buf[32];
-  char mapbuf[9600];
-  char cmdbuf[512];
-  unsigned long total_shared = 0ul;
-  unsigned long total_private_readonly = 0ul;
-  unsigned long total_private_writeable = 0ul;
-
-  // Overkill, but who knows what is proper? The "w" prog
-  // uses the tty width to determine this.
-  int maxcmd = 0xfffff;
-
-  sprintf(buf,"/proc/%u/maps",p->tgid);
-  if(!freopen(buf, "r", stdin)) return 1;
-
-  escape_command(cmdbuf, p, sizeof cmdbuf, &maxcmd, ESC_ARGS|ESC_BRACKETS);
-  printf("%u:   %s\n", p->tgid, cmdbuf);
-
-  if(!q_option && (x_option|d_option)){
-    if(x_option){
-      if(sizeof(KLONG)==4) printf("Address   Kbytes     RSS    Anon  Locked Mode   Mapping\n");
-      else         printf("Address           Kbytes     RSS    Anon  Locked Mode   Mapping\n");
-    }
-    if(d_option){
-      if(sizeof(KLONG)==4) printf("Address   Kbytes Mode  Offset           Device    Mapping\n");
-      else         printf("Address           Kbytes Mode  Offset           Device    Mapping\n");
-    }
-  }
-
-  while(fgets(mapbuf,sizeof mapbuf,stdin)){
-    char flags[32];
-    char *tmp; // to clean up unprintables
-    unsigned KLONG start, end, diff;
-    unsigned long long file_offset, inode;
-    unsigned dev_major, dev_minor;
-    sscanf(mapbuf,"%"KLF"x-%"KLF"x %31s %Lx %x:%x %Lu", &start, &end, flags, &file_offset, &dev_major, &dev_minor, &inode);
-
-    if(start > range_high)
-      break;
-    if(end < range_low)
-      continue;
-
-    tmp = strchr(mapbuf,'\n');
-    if(tmp) *tmp='\0';
-    tmp = mapbuf;
-    while(*tmp){
-      if(!isprint(*tmp)) *tmp='?';
-      tmp++;
-    }
-    
-    diff = end-start;
-    if(flags[3]=='s') total_shared  += diff;
-    if(flags[3]=='p'){
-      flags[3] = '-';
-      if(flags[1]=='w') total_private_writeable += diff;
-      else              total_private_readonly  += diff;
-    }
-
-    // format used by Solaris 9 and procps-3.2.0+
-    // an 'R' if swap not reserved (MAP_NORESERVE, SysV ISM shared mem, etc.)
-    flags[4] = '-';
-    flags[5] = '\0';
-
-    if(x_option){
-      const char *cp = mapping_name(p, start, diff, mapbuf, 0, dev_major, dev_minor, inode);
-      printf(
-        (sizeof(KLONG)==8)
-          ? "%016"KLF"x %7lu       -       -       - %s  %s\n"
-          :      "%08lx %7lu       -       -       - %s  %s\n",
-        start,
-        (unsigned long)(diff>>10),
-        flags,
-        cp
-      );
-    }
-    if(d_option){
-      const char *cp = mapping_name(p, start, diff, mapbuf, 0, dev_major, dev_minor, inode);
-      printf(
-        (sizeof(KLONG)==8)
-          ? "%016"KLF"x %7lu %s %016Lx %03x:%05x %s\n"
-          :      "%08lx %7lu %s %016Lx %03x:%05x %s\n",
-        start,
-        (unsigned long)(diff>>10),
-        flags,
-        file_offset,
-        dev_major, dev_minor,
-        cp
-      );
-    }
-    if(!x_option && !d_option){
-      const char *cp = mapping_name(p, start, diff, mapbuf, 1, dev_major, dev_minor, inode);
-      printf(
-        (sizeof(KLONG)==8)
-          ? "%016"KLF"x %6luK %s  %s\n"
-          :      "%08lx %6luK %s  %s\n",
-        start,
-        (unsigned long)(diff>>10),
-        flags,
-        cp
-      );
-    }
-    
-  }
-
-
-
-
-  if(!q_option){
-    if(x_option){
-      if(sizeof(KLONG)==8){
-        printf("----------------  ------  ------  ------  ------\n");
-        printf(
-          "total kB %15ld       -       -       -\n",
-          (total_shared + total_private_writeable + total_private_readonly) >> 10
-        );
-      }else{
-        printf("-------- ------- ------- ------- -------\n");
-        printf(
-          "total kB %7ld       -       -       -\n",
-          (total_shared + total_private_writeable + total_private_readonly) >> 10
-        );
-      }
-    }
-    if(d_option){
-        printf(
-          "mapped: %ldK    writeable/private: %ldK    shared: %ldK\n",
-          (total_shared + total_private_writeable + total_private_readonly) >> 10,
-          total_private_writeable >> 10,
-          total_shared >> 10
-        );
-    }
-    if(!x_option && !d_option){
-      if(sizeof(KLONG)==8) printf(" total %16ldK\n", (total_shared + total_private_writeable + total_private_readonly) >> 10);
-      else                 printf(" total %8ldK\n",  (total_shared + total_private_writeable + total_private_readonly) >> 10);
-    }
-  }
-
-  return 0;
-}
-
-
-int main(int argc, char *argv[]){
-  unsigned *pidlist;
-  unsigned count = 0;
-  PROCTAB* PT;
-  proc_t p;
-  int ret = 0;
-
-  if(argc<2) usage();
-  pidlist = malloc(sizeof(unsigned)*argc);  // a bit more than needed perhaps
-
-  while(*++argv){
-    if(!strcmp("--version",*argv)){
-      V_option++;
-      continue;
-    }
-    if(**argv=='-'){
-      char *walk = *argv;
-      if(!walk[1]) usage();
-      while(*++walk){
-        switch(*walk){
-        case 'V':
-          V_option++;
-          break;
-        case 'x':
-          x_option++;
-          break;
-        case 'r':
-          r_option++;
-          break;
-        case 'd':
-          d_option++;
-          break;
-        case 'q':
-          q_option++;
-          break;
-        case 'A':{
-            char *arg1;
-            if(walk[1]){
-              arg1 = walk+1;
-              walk += strlen(walk)-1;
-            }else{
-              arg1 = *++argv;
-              if(!arg1)
-                usage();
-            }
-            char *arg2 = strchr(arg1,',');
-            if(arg2)
-              *arg2 = '\0';
-            if(arg2) ++arg2;
-            else arg2 = arg1;
-            
-            if(*arg1)
-              range_low = STRTOUKL(arg1,&arg1,16);
-            if(*arg2)
-              range_high = STRTOUKL(arg2,&arg2,16);
-            if(*arg1 || *arg2)
-              usage();
-          }
-          break;
-        case 'a': // Sun prints anon/swap reservations
-        case 'F': // Sun forces hostile ptrace-like grab
-        case 'l': // Sun shows unresolved dynamic names
-        case 'L': // Sun shows lgroup info
-        case 's': // Sun shows page sizes
-        case 'S': // Sun shows swap reservations
-        default:
-          usage();
-        }
-      }
-    }else{
-      char *walk = *argv;
-      char *endp;
-      unsigned long pid;
-      if(!strncmp("/proc/",walk,6)){
-        walk += 6;
-        // user allowed to do: pmap /proc/*
-        if(*walk<'0' || *walk>'9') continue;
-      }
-      if(*walk<'0' || *walk>'9') usage();
-      pid = strtoul(walk, &endp, 0);
-      if(pid<1ul || pid>0x7ffffffful || *endp) usage();
-      pidlist[count++] = pid;
-    }
-  }
-
-  if( (x_option|V_option|r_option|d_option|q_option) >> 1 ) usage(); // dupes
-  if(V_option){
-    if(count|x_option|r_option|d_option|q_option) usage();
-    fprintf(stdout, "pmap (%s)\n", procps_version);
-    return 0;
-  }
-  if(count<1) usage();   // no processes
-  if(d_option && x_option) usage();
-
-  discover_shm_minor();
-
-  memset(&p, '\0', sizeof(p));
-  pidlist[count] = 0;  // old libproc interface is zero-terminated
-  PT = openproc(PROC_FILLSTAT|PROC_FILLARG|PROC_PID, pidlist);
-  while(readproc(PT, &p)){
-    ret |= one_proc(&p);
-    count--;
-  }
-  closeproc(PT);
-
-  if(count) ret |= 42;  // didn't find all processes asked for
-  return ret;
-}
diff --git a/proc/COPYING b/proc/COPYING
deleted file mode 100644
index 92b8903f..00000000
--- a/proc/COPYING
+++ /dev/null
@@ -1,481 +0,0 @@
-		  GNU LIBRARY GENERAL PUBLIC LICENSE
-		       Version 2, June 1991
-
- Copyright (C) 1991 Free Software Foundation, Inc.
-    		    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-[This is the first released version of the library GPL.  It is
- numbered 2 because it goes with version 2 of the ordinary GPL.]
-
-			    Preamble
-
-  The licenses for most software are designed to take away your
-freedom to share and change it.  By contrast, the GNU General Public
-Licenses are intended to guarantee your freedom to share and change
-free software--to make sure the software is free for all its users.
-
-  This license, the Library General Public License, applies to some
-specially designated Free Software Foundation software, and to any
-other libraries whose authors decide to use it.  You can use it for
-your libraries, too.
-
-  When we speak of free software, we are referring to freedom, not
-price.  Our General Public Licenses are designed to make sure that you
-have the freedom to distribute copies of free software (and charge for
-this service if you wish), that you receive source code or can get it
-if you want it, that you can change the software or use pieces of it
-in new free programs; and that you know you can do these things.
-
-  To protect your rights, we need to make restrictions that forbid
-anyone to deny you these rights or to ask you to surrender the rights.
-These restrictions translate to certain responsibilities for you if
-you distribute copies of the library, or if you modify it.
-
-  For example, if you distribute copies of the library, whether gratis
-or for a fee, you must give the recipients all the rights that we gave
-you.  You must make sure that they, too, receive or can get the source
-code.  If you link a program with the library, you must provide
-complete object files to the recipients so that they can relink them
-with the library, after making changes to the library and recompiling
-it.  And you must show them these terms so they know their rights.
-
-  Our method of protecting your rights has two steps: (1) copyright
-the library, and (2) offer you this license which gives you legal
-permission to copy, distribute and/or modify the library.
-
-  Also, for each distributor's protection, we want to make certain
-that everyone understands that there is no warranty for this free
-library.  If the library is modified by someone else and passed on, we
-want its recipients to know that what they have is not the original
-version, so that any problems introduced by others will not reflect on
-the original authors' reputations.
-
-  Finally, any free program is threatened constantly by software
-patents.  We wish to avoid the danger that companies distributing free
-software will individually obtain patent licenses, thus in effect
-transforming the program into proprietary software.  To prevent this,
-we have made it clear that any patent must be licensed for everyone's
-free use or not licensed at all.
-
-  Most GNU software, including some libraries, is covered by the ordinary
-GNU General Public License, which was designed for utility programs.  This
-license, the GNU Library General Public License, applies to certain
-designated libraries.  This license is quite different from the ordinary
-one; be sure to read it in full, and don't assume that anything in it is
-the same as in the ordinary license.
-
-  The reason we have a separate public license for some libraries is that
-they blur the distinction we usually make between modifying or adding to a
-program and simply using it.  Linking a program with a library, without
-changing the library, is in some sense simply using the library, and is
-analogous to running a utility program or application program.  However, in
-a textual and legal sense, the linked executable is a combined work, a
-derivative of the original library, and the ordinary General Public License
-treats it as such.
-
-  Because of this blurred distinction, using the ordinary General
-Public License for libraries did not effectively promote software
-sharing, because most developers did not use the libraries.  We
-concluded that weaker conditions might promote sharing better.
-
-  However, unrestricted linking of non-free programs would deprive the
-users of those programs of all benefit from the free status of the
-libraries themselves.  This Library General Public License is intended to
-permit developers of non-free programs to use free libraries, while
-preserving your freedom as a user of such programs to change the free
-libraries that are incorporated in them.  (We have not seen how to achieve
-this as regards changes in header files, but we have achieved it as regards
-changes in the actual functions of the Library.)  The hope is that this
-will lead to faster development of free libraries.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.  Pay close attention to the difference between a
-"work based on the library" and a "work that uses the library".  The
-former contains code derived from the library, while the latter only
-works together with the library.
-
-  Note that it is possible for a library to be covered by the ordinary
-General Public License rather than by this special one.
-
-		  GNU LIBRARY GENERAL PUBLIC LICENSE
-   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
-
-  0. This License Agreement applies to any software library which
-contains a notice placed by the copyright holder or other authorized
-party saying it may be distributed under the terms of this Library
-General Public License (also called "this License").  Each licensee is
-addressed as "you".
-
-  A "library" means a collection of software functions and/or data
-prepared so as to be conveniently linked with application programs
-(which use some of those functions and data) to form executables.
-
-  The "Library", below, refers to any such software library or work
-which has been distributed under these terms.  A "work based on the
-Library" means either the Library or any derivative work under
-copyright law: that is to say, a work containing the Library or a
-portion of it, either verbatim or with modifications and/or translated
-straightforwardly into another language.  (Hereinafter, translation is
-included without limitation in the term "modification".)
-
-  "Source code" for a work means the preferred form of the work for
-making modifications to it.  For a library, complete source code means
-all the source code for all modules it contains, plus any associated
-interface definition files, plus the scripts used to control compilation
-and installation of the library.
-
-  Activities other than copying, distribution and modification are not
-covered by this License; they are outside its scope.  The act of
-running a program using the Library is not restricted, and output from
-such a program is covered only if its contents constitute a work based
-on the Library (independent of the use of the Library in a tool for
-writing it).  Whether that is true depends on what the Library does
-and what the program that uses the Library does.
-  
-  1. You may copy and distribute verbatim copies of the Library's
-complete source code as you receive it, in any medium, provided that
-you conspicuously and appropriately publish on each copy an
-appropriate copyright notice and disclaimer of warranty; keep intact
-all the notices that refer to this License and to the absence of any
-warranty; and distribute a copy of this License along with the
-Library.
-
-  You may charge a fee for the physical act of transferring a copy,
-and you may at your option offer warranty protection in exchange for a
-fee.
-
-  2. You may modify your copy or copies of the Library or any portion
-of it, thus forming a work based on the Library, and copy and
-distribute such modifications or work under the terms of Section 1
-above, provided that you also meet all of these conditions:
-
-    a) The modified work must itself be a software library.
-
-    b) You must cause the files modified to carry prominent notices
-    stating that you changed the files and the date of any change.
-
-    c) You must cause the whole of the work to be licensed at no
-    charge to all third parties under the terms of this License.
-
-    d) If a facility in the modified Library refers to a function or a
-    table of data to be supplied by an application program that uses
-    the facility, other than as an argument passed when the facility
-    is invoked, then you must make a good faith effort to ensure that,
-    in the event an application does not supply such function or
-    table, the facility still operates, and performs whatever part of
-    its purpose remains meaningful.
-
-    (For example, a function in a library to compute square roots has
-    a purpose that is entirely well-defined independent of the
-    application.  Therefore, Subsection 2d requires that any
-    application-supplied function or table used by this function must
-    be optional: if the application does not supply it, the square
-    root function must still compute square roots.)
-
-These requirements apply to the modified work as a whole.  If
-identifiable sections of that work are not derived from the Library,
-and can be reasonably considered independent and separate works in
-themselves, then this License, and its terms, do not apply to those
-sections when you distribute them as separate works.  But when you
-distribute the same sections as part of a whole which is a work based
-on the Library, the distribution of the whole must be on the terms of
-this License, whose permissions for other licensees extend to the
-entire whole, and thus to each and every part regardless of who wrote
-it.
-
-Thus, it is not the intent of this section to claim rights or contest
-your rights to work written entirely by you; rather, the intent is to
-exercise the right to control the distribution of derivative or
-collective works based on the Library.
-
-In addition, mere aggregation of another work not based on the Library
-with the Library (or with a work based on the Library) on a volume of
-a storage or distribution medium does not bring the other work under
-the scope of this License.
-
-  3. You may opt to apply the terms of the ordinary GNU General Public
-License instead of this License to a given copy of the Library.  To do
-this, you must alter all the notices that refer to this License, so
-that they refer to the ordinary GNU General Public License, version 2,
-instead of to this License.  (If a newer version than version 2 of the
-ordinary GNU General Public License has appeared, then you can specify
-that version instead if you wish.)  Do not make any other change in
-these notices.
-
-  Once this change is made in a given copy, it is irreversible for
-that copy, so the ordinary GNU General Public License applies to all
-subsequent copies and derivative works made from that copy.
-
-  This option is useful when you wish to copy part of the code of
-the Library into a program that is not a library.
-
-  4. You may copy and distribute the Library (or a portion or
-derivative of it, under Section 2) in object code or executable form
-under the terms of Sections 1 and 2 above provided that you accompany
-it with the complete corresponding machine-readable source code, which
-must be distributed under the terms of Sections 1 and 2 above on a
-medium customarily used for software interchange.
-
-  If distribution of object code is made by offering access to copy
-from a designated place, then offering equivalent access to copy the
-source code from the same place satisfies the requirement to
-distribute the source code, even though third parties are not
-compelled to copy the source along with the object code.
-
-  5. A program that contains no derivative of any portion of the
-Library, but is designed to work with the Library by being compiled or
-linked with it, is called a "work that uses the Library".  Such a
-work, in isolation, is not a derivative work of the Library, and
-therefore falls outside the scope of this License.
-
-  However, linking a "work that uses the Library" with the Library
-creates an executable that is a derivative of the Library (because it
-contains portions of the Library), rather than a "work that uses the
-library".  The executable is therefore covered by this License.
-Section 6 states terms for distribution of such executables.
-
-  When a "work that uses the Library" uses material from a header file
-that is part of the Library, the object code for the work may be a
-derivative work of the Library even though the source code is not.
-Whether this is true is especially significant if the work can be
-linked without the Library, or if the work is itself a library.  The
-threshold for this to be true is not precisely defined by law.
-
-  If such an object file uses only numerical parameters, data
-structure layouts and accessors, and small macros and small inline
-functions (ten lines or less in length), then the use of the object
-file is unrestricted, regardless of whether it is legally a derivative
-work.  (Executables containing this object code plus portions of the
-Library will still fall under Section 6.)
-
-  Otherwise, if the work is a derivative of the Library, you may
-distribute the object code for the work under the terms of Section 6.
-Any executables containing that work also fall under Section 6,
-whether or not they are linked directly with the Library itself.
-
-  6. As an exception to the Sections above, you may also compile or
-link a "work that uses the Library" with the Library to produce a
-work containing portions of the Library, and distribute that work
-under terms of your choice, provided that the terms permit
-modification of the work for the customer's own use and reverse
-engineering for debugging such modifications.
-
-  You must give prominent notice with each copy of the work that the
-Library is used in it and that the Library and its use are covered by
-this License.  You must supply a copy of this License.  If the work
-during execution displays copyright notices, you must include the
-copyright notice for the Library among them, as well as a reference
-directing the user to the copy of this License.  Also, you must do one
-of these things:
-
-    a) Accompany the work with the complete corresponding
-    machine-readable source code for the Library including whatever
-    changes were used in the work (which must be distributed under
-    Sections 1 and 2 above); and, if the work is an executable linked
-    with the Library, with the complete machine-readable "work that
-    uses the Library", as object code and/or source code, so that the
-    user can modify the Library and then relink to produce a modified
-    executable containing the modified Library.  (It is understood
-    that the user who changes the contents of definitions files in the
-    Library will not necessarily be able to recompile the application
-    to use the modified definitions.)
-
-    b) Accompany the work with a written offer, valid for at
-    least three years, to give the same user the materials
-    specified in Subsection 6a, above, for a charge no more
-    than the cost of performing this distribution.
-
-    c) If distribution of the work is made by offering access to copy
-    from a designated place, offer equivalent access to copy the above
-    specified materials from the same place.
-
-    d) Verify that the user has already received a copy of these
-    materials or that you have already sent this user a copy.
-
-  For an executable, the required form of the "work that uses the
-Library" must include any data and utility programs needed for
-reproducing the executable from it.  However, as a special exception,
-the source code distributed need not include anything that is normally
-distributed (in either source or binary form) with the major
-components (compiler, kernel, and so on) of the operating system on
-which the executable runs, unless that component itself accompanies
-the executable.
-
-  It may happen that this requirement contradicts the license
-restrictions of other proprietary libraries that do not normally
-accompany the operating system.  Such a contradiction means you cannot
-use both them and the Library together in an executable that you
-distribute.
-
-  7. You may place library facilities that are a work based on the
-Library side-by-side in a single library together with other library
-facilities not covered by this License, and distribute such a combined
-library, provided that the separate distribution of the work based on
-the Library and of the other library facilities is otherwise
-permitted, and provided that you do these two things:
-
-    a) Accompany the combined library with a copy of the same work
-    based on the Library, uncombined with any other library
-    facilities.  This must be distributed under the terms of the
-    Sections above.
-
-    b) Give prominent notice with the combined library of the fact
-    that part of it is a work based on the Library, and explaining
-    where to find the accompanying uncombined form of the same work.
-
-  8. You may not copy, modify, sublicense, link with, or distribute
-the Library except as expressly provided under this License.  Any
-attempt otherwise to copy, modify, sublicense, link with, or
-distribute the Library is void, and will automatically terminate your
-rights under this License.  However, parties who have received copies,
-or rights, from you under this License will not have their licenses
-terminated so long as such parties remain in full compliance.
-
-  9. You are not required to accept this License, since you have not
-signed it.  However, nothing else grants you permission to modify or
-distribute the Library or its derivative works.  These actions are
-prohibited by law if you do not accept this License.  Therefore, by
-modifying or distributing the Library (or any work based on the
-Library), you indicate your acceptance of this License to do so, and
-all its terms and conditions for copying, distributing or modifying
-the Library or works based on it.
-
-  10. Each time you redistribute the Library (or any work based on the
-Library), the recipient automatically receives a license from the
-original licensor to copy, distribute, link with or modify the Library
-subject to these terms and conditions.  You may not impose any further
-restrictions on the recipients' exercise of the rights granted herein.
-You are not responsible for enforcing compliance by third parties to
-this License.
-
-  11. If, as a consequence of a court judgment or allegation of patent
-infringement or for any other reason (not limited to patent issues),
-conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot
-distribute so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you
-may not distribute the Library at all.  For example, if a patent
-license would not permit royalty-free redistribution of the Library by
-all those who receive copies directly or indirectly through you, then
-the only way you could satisfy both it and this License would be to
-refrain entirely from distribution of the Library.
-
-If any portion of this section is held invalid or unenforceable under any
-particular circumstance, the balance of the section is intended to apply,
-and the section as a whole is intended to apply in other circumstances.
-
-It is not the purpose of this section to induce you to infringe any
-patents or other property right claims or to contest validity of any
-such claims; this section has the sole purpose of protecting the
-integrity of the free software distribution system which is
-implemented by public license practices.  Many people have made
-generous contributions to the wide range of software distributed
-through that system in reliance on consistent application of that
-system; it is up to the author/donor to decide if he or she is willing
-to distribute software through any other system and a licensee cannot
-impose that choice.
-
-This section is intended to make thoroughly clear what is believed to
-be a consequence of the rest of this License.
-
-  12. If the distribution and/or use of the Library is restricted in
-certain countries either by patents or by copyrighted interfaces, the
-original copyright holder who places the Library under this License may add
-an explicit geographical distribution limitation excluding those countries,
-so that distribution is permitted only in or among countries not thus
-excluded.  In such case, this License incorporates the limitation as if
-written in the body of this License.
-
-  13. The Free Software Foundation may publish revised and/or new
-versions of the Library General Public License from time to time.
-Such new versions will be similar in spirit to the present version,
-but may differ in detail to address new problems or concerns.
-
-Each version is given a distinguishing version number.  If the Library
-specifies a version number of this License which applies to it and
-"any later version", you have the option of following the terms and
-conditions either of that version or of any later version published by
-the Free Software Foundation.  If the Library does not specify a
-license version number, you may choose any version ever published by
-the Free Software Foundation.
-
-  14. If you wish to incorporate parts of the Library into other free
-programs whose distribution conditions are incompatible with these,
-write to the author to ask for permission.  For software which is
-copyrighted by the Free Software Foundation, write to the Free
-Software Foundation; we sometimes make exceptions for this.  Our
-decision will be guided by the two goals of preserving the free status
-of all derivatives of our free software and of promoting the sharing
-and reuse of software generally.
-
-			    NO WARRANTY
-
-  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
-WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
-EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
-OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
-KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
-LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
-THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
-
-  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
-WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
-AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
-FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
-CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
-LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
-RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
-FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
-SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
-DAMAGES.
-
-		     END OF TERMS AND CONDITIONS
-
-           How to Apply These Terms to Your New Libraries
-
-  If you develop a new library, and you want it to be of the greatest
-possible use to the public, we recommend making it free software that
-everyone can redistribute and change.  You can do so by permitting
-redistribution under these terms (or, alternatively, under the terms of the
-ordinary General Public License).
-
-  To apply these terms, attach the following notices to the library.  It is
-safest to attach them to the start of each source file to most effectively
-convey the exclusion of warranty; and each file should have at least the
-"copyright" line and a pointer to where the full notice is found.
-
-    <one line to give the library's name and a brief idea of what it does.>
-    Copyright (C) <year>  <name of author>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Library General Public
-    License as published by the Free Software Foundation; either
-    version 2 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Library General Public License for more details.
-
-    You should have received a copy of the GNU Library General Public
-    License along with this library; if not, write to the Free
-    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-
-Also add information on how to contact you by electronic and paper mail.
-
-You should also get your employer (if you work as a programmer) or your
-school, if any, to sign a "copyright disclaimer" for the library, if
-necessary.  Here is a sample; alter the names:
-
-  Yoyodyne, Inc., hereby disclaims all copyright interest in the
-  library `Frob' (a library for tweaking knobs) written by James Random Hacker.
-
-  <signature of Ty Coon>, 1 April 1990
-  Ty Coon, President of Vice
-
-That's all there is to it!
diff --git a/proc/Makefile.am b/proc/Makefile.am
deleted file mode 100644
index 391ac2b0..00000000
--- a/proc/Makefile.am
+++ /dev/null
@@ -1,47 +0,0 @@
-PACKAGE_VERSION = @PACKAGE_VERSION@
-AM_CPPFLAGS = -include $(top_builddir)/config.h
-lib_LTLIBRARIES = libproc-ng.la
-
-libproc_ng_ladir = $(ladir)
-libproc_ng_la_LIBADD = $(LIB_KPARTS)
-libproc_ng_la_LDFLAGS = $(all_libraries) -release $(PACKAGE_VERSION) -no-undefined
-
-libproc_ng_la_SOURCES = \
-	alloc.c \
-	alloc.h \
-	devname.c \
-	devname.h \
-	escape.c \
-	escape.h \
-	ksym.c \
-	procps.h \
-	pwcache.c \
-	pwcache.h \
-	readproc.c \
-	readproc.h \
-	sig.c \
-	sig.h \
-	slab.c \
-	slab.h \
-	sysinfo.c \
-	sysinfo.h \
-	version.c \
-	version.h \
-	wchan.h \
-	whattime.c \
-	whattime.h
-
-libproc_ng_la_includedir = $(includedir)/proc/
-libproc_ng_la_include_HEADERS =  \
-	alloc.h \
-	devname.h \
-	escape.h \
-	procps.h \
-	pwcache.h \
-	readproc.h \
-	sig.h \
-	slab.h \
-	sysinfo.h \
-	version.h \
-	wchan.h \
-	whattime.h
diff --git a/proc/procps.h b/procps.h
similarity index 98%
rename from proc/procps.h
rename to procps.h
index 42d02b45..a70e9257 100644
--- a/proc/procps.h
+++ b/procps.h
@@ -78,7 +78,7 @@
 #define STRINGIFY_ARG(a)	#a
 #define STRINGIFY(a)		STRINGIFY_ARG(a)
 
-// marks old junk, to warn non-procps-ng library users
+// marks old junk, to warn non-procps library users
 #if ( __GNUC__ == 3 && __GNUC_MINOR__ > 0 ) || __GNUC__ > 3
 #define OBSOLETE __attribute__((deprecated))
 #else
diff --git a/ps/COPYING b/ps/COPYING
deleted file mode 100644
index 92b8903f..00000000
--- a/ps/COPYING
+++ /dev/null
@@ -1,481 +0,0 @@
-		  GNU LIBRARY GENERAL PUBLIC LICENSE
-		       Version 2, June 1991
-
- Copyright (C) 1991 Free Software Foundation, Inc.
-    		    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-[This is the first released version of the library GPL.  It is
- numbered 2 because it goes with version 2 of the ordinary GPL.]
-
-			    Preamble
-
-  The licenses for most software are designed to take away your
-freedom to share and change it.  By contrast, the GNU General Public
-Licenses are intended to guarantee your freedom to share and change
-free software--to make sure the software is free for all its users.
-
-  This license, the Library General Public License, applies to some
-specially designated Free Software Foundation software, and to any
-other libraries whose authors decide to use it.  You can use it for
-your libraries, too.
-
-  When we speak of free software, we are referring to freedom, not
-price.  Our General Public Licenses are designed to make sure that you
-have the freedom to distribute copies of free software (and charge for
-this service if you wish), that you receive source code or can get it
-if you want it, that you can change the software or use pieces of it
-in new free programs; and that you know you can do these things.
-
-  To protect your rights, we need to make restrictions that forbid
-anyone to deny you these rights or to ask you to surrender the rights.
-These restrictions translate to certain responsibilities for you if
-you distribute copies of the library, or if you modify it.
-
-  For example, if you distribute copies of the library, whether gratis
-or for a fee, you must give the recipients all the rights that we gave
-you.  You must make sure that they, too, receive or can get the source
-code.  If you link a program with the library, you must provide
-complete object files to the recipients so that they can relink them
-with the library, after making changes to the library and recompiling
-it.  And you must show them these terms so they know their rights.
-
-  Our method of protecting your rights has two steps: (1) copyright
-the library, and (2) offer you this license which gives you legal
-permission to copy, distribute and/or modify the library.
-
-  Also, for each distributor's protection, we want to make certain
-that everyone understands that there is no warranty for this free
-library.  If the library is modified by someone else and passed on, we
-want its recipients to know that what they have is not the original
-version, so that any problems introduced by others will not reflect on
-the original authors' reputations.
-
-  Finally, any free program is threatened constantly by software
-patents.  We wish to avoid the danger that companies distributing free
-software will individually obtain patent licenses, thus in effect
-transforming the program into proprietary software.  To prevent this,
-we have made it clear that any patent must be licensed for everyone's
-free use or not licensed at all.
-
-  Most GNU software, including some libraries, is covered by the ordinary
-GNU General Public License, which was designed for utility programs.  This
-license, the GNU Library General Public License, applies to certain
-designated libraries.  This license is quite different from the ordinary
-one; be sure to read it in full, and don't assume that anything in it is
-the same as in the ordinary license.
-
-  The reason we have a separate public license for some libraries is that
-they blur the distinction we usually make between modifying or adding to a
-program and simply using it.  Linking a program with a library, without
-changing the library, is in some sense simply using the library, and is
-analogous to running a utility program or application program.  However, in
-a textual and legal sense, the linked executable is a combined work, a
-derivative of the original library, and the ordinary General Public License
-treats it as such.
-
-  Because of this blurred distinction, using the ordinary General
-Public License for libraries did not effectively promote software
-sharing, because most developers did not use the libraries.  We
-concluded that weaker conditions might promote sharing better.
-
-  However, unrestricted linking of non-free programs would deprive the
-users of those programs of all benefit from the free status of the
-libraries themselves.  This Library General Public License is intended to
-permit developers of non-free programs to use free libraries, while
-preserving your freedom as a user of such programs to change the free
-libraries that are incorporated in them.  (We have not seen how to achieve
-this as regards changes in header files, but we have achieved it as regards
-changes in the actual functions of the Library.)  The hope is that this
-will lead to faster development of free libraries.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.  Pay close attention to the difference between a
-"work based on the library" and a "work that uses the library".  The
-former contains code derived from the library, while the latter only
-works together with the library.
-
-  Note that it is possible for a library to be covered by the ordinary
-General Public License rather than by this special one.
-
-		  GNU LIBRARY GENERAL PUBLIC LICENSE
-   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
-
-  0. This License Agreement applies to any software library which
-contains a notice placed by the copyright holder or other authorized
-party saying it may be distributed under the terms of this Library
-General Public License (also called "this License").  Each licensee is
-addressed as "you".
-
-  A "library" means a collection of software functions and/or data
-prepared so as to be conveniently linked with application programs
-(which use some of those functions and data) to form executables.
-
-  The "Library", below, refers to any such software library or work
-which has been distributed under these terms.  A "work based on the
-Library" means either the Library or any derivative work under
-copyright law: that is to say, a work containing the Library or a
-portion of it, either verbatim or with modifications and/or translated
-straightforwardly into another language.  (Hereinafter, translation is
-included without limitation in the term "modification".)
-
-  "Source code" for a work means the preferred form of the work for
-making modifications to it.  For a library, complete source code means
-all the source code for all modules it contains, plus any associated
-interface definition files, plus the scripts used to control compilation
-and installation of the library.
-
-  Activities other than copying, distribution and modification are not
-covered by this License; they are outside its scope.  The act of
-running a program using the Library is not restricted, and output from
-such a program is covered only if its contents constitute a work based
-on the Library (independent of the use of the Library in a tool for
-writing it).  Whether that is true depends on what the Library does
-and what the program that uses the Library does.
-  
-  1. You may copy and distribute verbatim copies of the Library's
-complete source code as you receive it, in any medium, provided that
-you conspicuously and appropriately publish on each copy an
-appropriate copyright notice and disclaimer of warranty; keep intact
-all the notices that refer to this License and to the absence of any
-warranty; and distribute a copy of this License along with the
-Library.
-
-  You may charge a fee for the physical act of transferring a copy,
-and you may at your option offer warranty protection in exchange for a
-fee.
-
-  2. You may modify your copy or copies of the Library or any portion
-of it, thus forming a work based on the Library, and copy and
-distribute such modifications or work under the terms of Section 1
-above, provided that you also meet all of these conditions:
-
-    a) The modified work must itself be a software library.
-
-    b) You must cause the files modified to carry prominent notices
-    stating that you changed the files and the date of any change.
-
-    c) You must cause the whole of the work to be licensed at no
-    charge to all third parties under the terms of this License.
-
-    d) If a facility in the modified Library refers to a function or a
-    table of data to be supplied by an application program that uses
-    the facility, other than as an argument passed when the facility
-    is invoked, then you must make a good faith effort to ensure that,
-    in the event an application does not supply such function or
-    table, the facility still operates, and performs whatever part of
-    its purpose remains meaningful.
-
-    (For example, a function in a library to compute square roots has
-    a purpose that is entirely well-defined independent of the
-    application.  Therefore, Subsection 2d requires that any
-    application-supplied function or table used by this function must
-    be optional: if the application does not supply it, the square
-    root function must still compute square roots.)
-
-These requirements apply to the modified work as a whole.  If
-identifiable sections of that work are not derived from the Library,
-and can be reasonably considered independent and separate works in
-themselves, then this License, and its terms, do not apply to those
-sections when you distribute them as separate works.  But when you
-distribute the same sections as part of a whole which is a work based
-on the Library, the distribution of the whole must be on the terms of
-this License, whose permissions for other licensees extend to the
-entire whole, and thus to each and every part regardless of who wrote
-it.
-
-Thus, it is not the intent of this section to claim rights or contest
-your rights to work written entirely by you; rather, the intent is to
-exercise the right to control the distribution of derivative or
-collective works based on the Library.
-
-In addition, mere aggregation of another work not based on the Library
-with the Library (or with a work based on the Library) on a volume of
-a storage or distribution medium does not bring the other work under
-the scope of this License.
-
-  3. You may opt to apply the terms of the ordinary GNU General Public
-License instead of this License to a given copy of the Library.  To do
-this, you must alter all the notices that refer to this License, so
-that they refer to the ordinary GNU General Public License, version 2,
-instead of to this License.  (If a newer version than version 2 of the
-ordinary GNU General Public License has appeared, then you can specify
-that version instead if you wish.)  Do not make any other change in
-these notices.
-
-  Once this change is made in a given copy, it is irreversible for
-that copy, so the ordinary GNU General Public License applies to all
-subsequent copies and derivative works made from that copy.
-
-  This option is useful when you wish to copy part of the code of
-the Library into a program that is not a library.
-
-  4. You may copy and distribute the Library (or a portion or
-derivative of it, under Section 2) in object code or executable form
-under the terms of Sections 1 and 2 above provided that you accompany
-it with the complete corresponding machine-readable source code, which
-must be distributed under the terms of Sections 1 and 2 above on a
-medium customarily used for software interchange.
-
-  If distribution of object code is made by offering access to copy
-from a designated place, then offering equivalent access to copy the
-source code from the same place satisfies the requirement to
-distribute the source code, even though third parties are not
-compelled to copy the source along with the object code.
-
-  5. A program that contains no derivative of any portion of the
-Library, but is designed to work with the Library by being compiled or
-linked with it, is called a "work that uses the Library".  Such a
-work, in isolation, is not a derivative work of the Library, and
-therefore falls outside the scope of this License.
-
-  However, linking a "work that uses the Library" with the Library
-creates an executable that is a derivative of the Library (because it
-contains portions of the Library), rather than a "work that uses the
-library".  The executable is therefore covered by this License.
-Section 6 states terms for distribution of such executables.
-
-  When a "work that uses the Library" uses material from a header file
-that is part of the Library, the object code for the work may be a
-derivative work of the Library even though the source code is not.
-Whether this is true is especially significant if the work can be
-linked without the Library, or if the work is itself a library.  The
-threshold for this to be true is not precisely defined by law.
-
-  If such an object file uses only numerical parameters, data
-structure layouts and accessors, and small macros and small inline
-functions (ten lines or less in length), then the use of the object
-file is unrestricted, regardless of whether it is legally a derivative
-work.  (Executables containing this object code plus portions of the
-Library will still fall under Section 6.)
-
-  Otherwise, if the work is a derivative of the Library, you may
-distribute the object code for the work under the terms of Section 6.
-Any executables containing that work also fall under Section 6,
-whether or not they are linked directly with the Library itself.
-
-  6. As an exception to the Sections above, you may also compile or
-link a "work that uses the Library" with the Library to produce a
-work containing portions of the Library, and distribute that work
-under terms of your choice, provided that the terms permit
-modification of the work for the customer's own use and reverse
-engineering for debugging such modifications.
-
-  You must give prominent notice with each copy of the work that the
-Library is used in it and that the Library and its use are covered by
-this License.  You must supply a copy of this License.  If the work
-during execution displays copyright notices, you must include the
-copyright notice for the Library among them, as well as a reference
-directing the user to the copy of this License.  Also, you must do one
-of these things:
-
-    a) Accompany the work with the complete corresponding
-    machine-readable source code for the Library including whatever
-    changes were used in the work (which must be distributed under
-    Sections 1 and 2 above); and, if the work is an executable linked
-    with the Library, with the complete machine-readable "work that
-    uses the Library", as object code and/or source code, so that the
-    user can modify the Library and then relink to produce a modified
-    executable containing the modified Library.  (It is understood
-    that the user who changes the contents of definitions files in the
-    Library will not necessarily be able to recompile the application
-    to use the modified definitions.)
-
-    b) Accompany the work with a written offer, valid for at
-    least three years, to give the same user the materials
-    specified in Subsection 6a, above, for a charge no more
-    than the cost of performing this distribution.
-
-    c) If distribution of the work is made by offering access to copy
-    from a designated place, offer equivalent access to copy the above
-    specified materials from the same place.
-
-    d) Verify that the user has already received a copy of these
-    materials or that you have already sent this user a copy.
-
-  For an executable, the required form of the "work that uses the
-Library" must include any data and utility programs needed for
-reproducing the executable from it.  However, as a special exception,
-the source code distributed need not include anything that is normally
-distributed (in either source or binary form) with the major
-components (compiler, kernel, and so on) of the operating system on
-which the executable runs, unless that component itself accompanies
-the executable.
-
-  It may happen that this requirement contradicts the license
-restrictions of other proprietary libraries that do not normally
-accompany the operating system.  Such a contradiction means you cannot
-use both them and the Library together in an executable that you
-distribute.
-
-  7. You may place library facilities that are a work based on the
-Library side-by-side in a single library together with other library
-facilities not covered by this License, and distribute such a combined
-library, provided that the separate distribution of the work based on
-the Library and of the other library facilities is otherwise
-permitted, and provided that you do these two things:
-
-    a) Accompany the combined library with a copy of the same work
-    based on the Library, uncombined with any other library
-    facilities.  This must be distributed under the terms of the
-    Sections above.
-
-    b) Give prominent notice with the combined library of the fact
-    that part of it is a work based on the Library, and explaining
-    where to find the accompanying uncombined form of the same work.
-
-  8. You may not copy, modify, sublicense, link with, or distribute
-the Library except as expressly provided under this License.  Any
-attempt otherwise to copy, modify, sublicense, link with, or
-distribute the Library is void, and will automatically terminate your
-rights under this License.  However, parties who have received copies,
-or rights, from you under this License will not have their licenses
-terminated so long as such parties remain in full compliance.
-
-  9. You are not required to accept this License, since you have not
-signed it.  However, nothing else grants you permission to modify or
-distribute the Library or its derivative works.  These actions are
-prohibited by law if you do not accept this License.  Therefore, by
-modifying or distributing the Library (or any work based on the
-Library), you indicate your acceptance of this License to do so, and
-all its terms and conditions for copying, distributing or modifying
-the Library or works based on it.
-
-  10. Each time you redistribute the Library (or any work based on the
-Library), the recipient automatically receives a license from the
-original licensor to copy, distribute, link with or modify the Library
-subject to these terms and conditions.  You may not impose any further
-restrictions on the recipients' exercise of the rights granted herein.
-You are not responsible for enforcing compliance by third parties to
-this License.
-
-  11. If, as a consequence of a court judgment or allegation of patent
-infringement or for any other reason (not limited to patent issues),
-conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot
-distribute so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you
-may not distribute the Library at all.  For example, if a patent
-license would not permit royalty-free redistribution of the Library by
-all those who receive copies directly or indirectly through you, then
-the only way you could satisfy both it and this License would be to
-refrain entirely from distribution of the Library.
-
-If any portion of this section is held invalid or unenforceable under any
-particular circumstance, the balance of the section is intended to apply,
-and the section as a whole is intended to apply in other circumstances.
-
-It is not the purpose of this section to induce you to infringe any
-patents or other property right claims or to contest validity of any
-such claims; this section has the sole purpose of protecting the
-integrity of the free software distribution system which is
-implemented by public license practices.  Many people have made
-generous contributions to the wide range of software distributed
-through that system in reliance on consistent application of that
-system; it is up to the author/donor to decide if he or she is willing
-to distribute software through any other system and a licensee cannot
-impose that choice.
-
-This section is intended to make thoroughly clear what is believed to
-be a consequence of the rest of this License.
-
-  12. If the distribution and/or use of the Library is restricted in
-certain countries either by patents or by copyrighted interfaces, the
-original copyright holder who places the Library under this License may add
-an explicit geographical distribution limitation excluding those countries,
-so that distribution is permitted only in or among countries not thus
-excluded.  In such case, this License incorporates the limitation as if
-written in the body of this License.
-
-  13. The Free Software Foundation may publish revised and/or new
-versions of the Library General Public License from time to time.
-Such new versions will be similar in spirit to the present version,
-but may differ in detail to address new problems or concerns.
-
-Each version is given a distinguishing version number.  If the Library
-specifies a version number of this License which applies to it and
-"any later version", you have the option of following the terms and
-conditions either of that version or of any later version published by
-the Free Software Foundation.  If the Library does not specify a
-license version number, you may choose any version ever published by
-the Free Software Foundation.
-
-  14. If you wish to incorporate parts of the Library into other free
-programs whose distribution conditions are incompatible with these,
-write to the author to ask for permission.  For software which is
-copyrighted by the Free Software Foundation, write to the Free
-Software Foundation; we sometimes make exceptions for this.  Our
-decision will be guided by the two goals of preserving the free status
-of all derivatives of our free software and of promoting the sharing
-and reuse of software generally.
-
-			    NO WARRANTY
-
-  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
-WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
-EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
-OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
-KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
-LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
-THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
-
-  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
-WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
-AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
-FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
-CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
-LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
-RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
-FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
-SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
-DAMAGES.
-
-		     END OF TERMS AND CONDITIONS
-
-           How to Apply These Terms to Your New Libraries
-
-  If you develop a new library, and you want it to be of the greatest
-possible use to the public, we recommend making it free software that
-everyone can redistribute and change.  You can do so by permitting
-redistribution under these terms (or, alternatively, under the terms of the
-ordinary General Public License).
-
-  To apply these terms, attach the following notices to the library.  It is
-safest to attach them to the start of each source file to most effectively
-convey the exclusion of warranty; and each file should have at least the
-"copyright" line and a pointer to where the full notice is found.
-
-    <one line to give the library's name and a brief idea of what it does.>
-    Copyright (C) <year>  <name of author>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Library General Public
-    License as published by the Free Software Foundation; either
-    version 2 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Library General Public License for more details.
-
-    You should have received a copy of the GNU Library General Public
-    License along with this library; if not, write to the Free
-    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-
-Also add information on how to contact you by electronic and paper mail.
-
-You should also get your employer (if you work as a programmer) or your
-school, if any, to sign a "copyright disclaimer" for the library, if
-necessary.  Here is a sample; alter the names:
-
-  Yoyodyne, Inc., hereby disclaims all copyright interest in the
-  library `Frob' (a library for tweaking knobs) written by James Random Hacker.
-
-  <signature of Ty Coon>, 1 April 1990
-  Ty Coon, President of Vice
-
-That's all there is to it!
diff --git a/ps/HACKING b/ps/HACKING
deleted file mode 100644
index ffae92c5..00000000
--- a/ps/HACKING
+++ /dev/null
@@ -1,53 +0,0 @@
-Warning:
-
-This code must corrctly handle lots of picky little details to meet
-the Unix98 standard while simultaneously being as compatible as
-possible with the original Linux ps. Don't "fix" something without
-considering the impact on all the special-case code. For example,
-the "tty" format _must_ use "TT" as the header, even though the SysV
-output formats _must_ use "TTY".
-
-File overview:
-
-display.c     main(), debug code, iterates over processes
-escape.c      Does stuff like \202 and &lt; to command and environment.
-global.c      Data + code to init it.
-help.c        Help message.
-output.c      Giant tables and lots of output functions.
-parser.c      Initial command parsing.
-select.c      want_this_proc() checks a process against flags & lists
-sortformat.c  Parses sort & format specifier lists. Picks output format.
-stacktrace.c  Debug code, not normally used.
-../proc/*     Library used to gather data.
-regression    Regression tests that ought to be run.
-common.h      Lots of interesting stuff.
-Makefile      Makefile
-p             Script used to test ps when the library is not installed.
-utf           Empty file used to test "ps ut?" unmangling behavior.
-ps.1          Man page.
-
-Compiling:
-
-Whatever you do, don't trust the Makefiles. They are severely broken.
-You can touch top.h and top won't be recompiled, or you can change
-library files and discover that the library and programs won't be
-recompiled.
-
-Operation:
-
-Unless the personality forces BSD parsing, parser.c tries to parse the
-command line as a mixed BSD+SysV+Gnu mess. On failure, BSD parsing is
-attempted. If BSD parsing fails _after_ SysV parsing has been attempted,
-the error message comes from the original SysV parse.
-
-Control goes to sortformat.c, which must pick apart ambiguous options
-like "O". Failure can reset the whole program and set PER_FORCE_BSD,
-which means a second trip through parser.c and sortformat.c.
-
-The choice of output format happens in sortformat.c. There is a switch()
-with all the valid format_flags combinations. The SysV and default
-options are NULL (unless overridden by personality), which causes a
-trip through SysV output format generation hackery. Note that the
-default format always goes through there, even if it is for BSD.
-Formats that came from the switch() (generally BSD, plus overrides)
-get mangled a bit to support various SysV output modifiers.
diff --git a/ps/Makefile.am b/ps/Makefile.am
deleted file mode 100644
index ced42f23..00000000
--- a/ps/Makefile.am
+++ /dev/null
@@ -1,28 +0,0 @@
-AM_CPPFLAGS = -include $(top_builddir)/config.h
-
-AM_CFLAGS = -I../proc
-AM_LDFLAGS = ../proc/libproc-ng.la
-
-dist_man_MANS = ps.1
-
-# Use `ginstall' in the definition of PROGRAMS and in dependencies to avoid
-# confusion with the `install' target.  The install rule transforms `ginstall'
-# to install before applying any user-specified name transformations.
-transform = s/pscommand/ps/; $(program_transform_name)
-bin_PROGRAMS = pscommand
-pscommand_SOURCES =  \
-	common.h \
-	display.c \
-	global.c \
-	help.c \
-	output.c \
-	parser.c \
-	select.c \
-	sortformat.c \
-	stacktrace.c
-
-EXTRA_DIST = \
-	HACKING \
-	it \
-	regression \
-	TRANSLATION
diff --git a/ps/TRANSLATION b/ps/TRANSLATION
deleted file mode 100644
index ff8df84e..00000000
--- a/ps/TRANSLATION
+++ /dev/null
@@ -1,39 +0,0 @@
-Initially I only want to translate the --help output and man page.
-Common error messages would be next on the list. I want to avoid
-run-time overhead and bloat.
-
-Translations of the --help output should not be longer than 22 lines long.
-Feel free to leave out the less useful options to save space. (not even
-the English help text has all the options)
-
-I think these are the most important options:
-
-*** selection ***
--C  by command name list
--G  by real group ID list (supports names)
--U  by real user ID list (supports names)
--u  by effective user ID list (supports names)
--e  all processes
--p  by process ID list
-
-*** output ***
---no-heading  No header line.
--o,o          user-defined output
--j,j          job control format
--l,l          long format
--f            full format
-s             signal format
-u             user-oriented format
---forest      ASCII art forest (process hierarchy)
-c             show true command name
-
-List of man page translators:
-
-de  Wed Jan 10 19:09:15 2001 by Martin Schulze <joey@infodrom.ffis.de>
-es  19 Jan 1999 by Diego Sevilla Ruiz (dsevilla@ditec.um.es)
-fr  09/06/1997 par Christophe Blaess (ccb@club-internet.fr)
-hu  Horv#th Andr#s (the '#' is 'a' w/ '/') <horvatha@rs1.szif.hu>
-it  Traduzione in italiano di Giovanni Bortolozzo <borto@dei.unipd.it>
-it  Revisione parziale di Daniele Giacomini <daniele@evo.it> 30/03/1999
-ja  Tue Nov 14 2000 by NAKANO Takeo <nakano@apm.seikei.ac.jp>
-nl  <manpages-nl@nl.linux.org>
diff --git a/ps/common.h b/ps/common.h
deleted file mode 100644
index d7208a7c..00000000
--- a/ps/common.h
+++ /dev/null
@@ -1,337 +0,0 @@
-/*
- * Copyright 1998-2002 by Albert Cahalan; all rights resered.         
- * This file may be used subject to the terms and conditions of the
- * GNU Library General Public License Version 2, or any later version  
- * at your option, as published by the Free Software Foundation.
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Library General Public License for more details.
- */
-
-#ifndef PROCPS_PS_H
-#define PROCPS_PS_H
-
-#include "../proc/procps.h"
-#include "../proc/escape.h"
-#include "../proc/readproc.h"
-
-#if 0
-#define trace(args...) printf(## args)
-#else
-#define trace(args...)
-#endif
-
-
-/***************** GENERAL DEFINE ********************/
-
-
-/* selection list */
-#define SEL_RUID 1
-#define SEL_EUID 2
-#define SEL_SUID 3
-#define SEL_FUID 4
-#define SEL_RGID 5
-#define SEL_EGID 6
-#define SEL_SGID 7
-#define SEL_FGID 8
-#define SEL_PGRP 9
-#define SEL_PID  10
-#define SEL_TTY  11
-#define SEL_SESS 12
-#define SEL_COMM 13
-#define SEL_PPID 14
-
-/* Since an enum could be smashed by a #define, it would be bad. */
-#define U98  0 /* Unix98 standard */    /* This must be 0 */
-#define XXX  1 /* Common extension */
-#define DEC  2 /* Digital Unix */
-#define AIX  3 /* AIX */
-#define SCO  4 /* SCO */
-#define LNX  5 /* Linux original :-) */
-#define BSD  6 /* FreeBSD and OpenBSD */
-#define SUN  7 /* SunOS 5 (Solaris) */
-#define HPU  8 /* HP-UX */
-#define SGI  9 /* Irix */
-#define SOE 10 /* IBM's S/390 OpenEdition */
-#define TST 11 /* test code */
-
-/*
- * Try not to overflow the output buffer:
- *    32 pages for env+cmd
- *    64 kB pages on IA-64
- *    4 chars for "\377", or 1 when mangling to '?'  (ESC_STRETCH)
- *    plus some slack for other stuff
- * That is about 8.5 MB on IA-64, or 0.6 MB on i386
- *
- * Sadly, current kernels only supply one page of env/command data.
- * The buffer is now protected with a guard page, and via other means
- * to avoid hitting the guard page.
- */
-
-/* output buffer size */
-#define OUTBUF_SIZE (2 * 64*1024 * ESC_STRETCH)
-
-/******************* PS DEFINE *******************/
-
-// Column flags
-// Justification control for flags field comes first.
-#define CF_JUST_MASK                0x0f
-//      CF_AIXHACK                     0
-#define CF_USER                        1 // left if text, right if numeric
-#define CF_LEFT                        2
-#define CF_RIGHT                       3
-#define CF_UNLIMITED                   4
-#define CF_WCHAN                       5 // left if text, right if numeric
-#define CF_SIGNAL                      6 // right in 9, or 16 if screen_cols>107
-// Then the other flags
-#define CF_PIDMAX             0x00000010 // react to pid_max
-// Only one allowed; use separate bits to catch errors.
-#define CF_PRINT_THREAD_ONLY  0x10000000
-#define CF_PRINT_PROCESS_ONLY 0x20000000
-#define CF_PRINT_EVERY_TIME   0x40000000
-#define CF_PRINT_AS_NEEDED    0x80000000 // means we have no clue, so assume EVERY TIME
-#define CF_PRINT_MASK         0xf0000000
-
-#define needs_for_select (PROC_FILLSTAT | PROC_FILLSTATUS)
-
-/* thread_flags */
-#define TF_B_H         0x0001
-#define TF_B_m         0x0002
-#define TF_U_m         0x0004
-#define TF_U_T         0x0008
-#define TF_U_L         0x0010
-#define TF_show_proc   0x0100  // show the summary line
-#define TF_show_task   0x0200  // show the per-thread lines
-#define TF_show_both   0x0400  // distinct proc/task format lists
-#define TF_loose_tasks 0x0800  // let sorting break up task groups (BSDish)
-#define TF_no_sort     0x1000  // don't know if thread-grouping should survive a sort
-#define TF_no_forest   0x2000  // don't see how to do threads w/ forest option
-#define TF_must_use    0x4000  // options only make sense if LWP/SPID column added
-
-/* personality control flags */
-#define PER_BROKEN_o      0x0001
-#define PER_BSD_h         0x0002
-#define PER_BSD_m         0x0004
-#define PER_IRIX_l        0x0008
-#define PER_FORCE_BSD     0x0010
-#define PER_GOOD_o        0x0020
-#define PER_OLD_m         0x0040
-#define PER_NO_DEFAULT_g  0x0080
-#define PER_ZAP_ADDR      0x0100
-#define PER_SANE_USER     0x0200
-#define PER_HPUX_x        0x0400
-#define PER_SVR4_x        0x0800
-#define PER_BSD_COLS      0x1000
-#define PER_UNIX_COLS     0x2000
-
-/* Simple selections by bit mask */
-#define SS_B_x 0x01
-#define SS_B_g 0x02
-#define SS_U_d 0x04
-#define SS_U_a 0x08
-#define SS_B_a 0x10
-
-/* predefined format flags such as:  -l -f l u s -j */
-#define FF_Uf 0x0001 /* -f */
-#define FF_Uj 0x0002 /* -j */
-#define FF_Ul 0x0004 /* -l */
-#define FF_Bj 0x0008 /* j */
-#define FF_Bl 0x0010 /* l */
-#define FF_Bs 0x0020 /* s */
-#define FF_Bu 0x0040 /* u */
-#define FF_Bv 0x0080 /* v */
-#define FF_LX 0x0100 /* X */
-#define FF_Lm 0x0200 /* m */  /* overloaded: threads, sort, format */
-#define FF_Fc 0x0400 /* --context */  /* Flask security context format */
-
-/* predefined format modifier flags such as:  -l -f l u s -j */
-#define FM_c 0x0001 /* -c */
-#define FM_j 0x0002 /* -j */  /* only set when !sysv_j_format */
-#define FM_y 0x0004 /* -y */
-//#define FM_L 0x0008 /* -L */
-#define FM_P 0x0010 /* -P */
-#define FM_M 0x0020 /* -M */
-//#define FM_T 0x0040 /* -T */
-#define FM_F 0x0080 /* -F */  /* -F also sets the regular -f flags */
-
-/* sorting & formatting */
-/* U,B,G is Unix,BSD,Gnu and then there is the option itself */
-#define SF_U_O      1
-#define SF_U_o      2
-#define SF_B_O      3
-#define SF_B_o      4
-#define SF_B_m      5       /* overloaded: threads, sort, format */
-#define SF_G_sort   6
-#define SF_G_format 7
-
-/* headers */
-#define HEAD_SINGLE 0  /* default, must be 0 */
-#define HEAD_NONE   1
-#define HEAD_MULTI  2
-
-
-/********************** GENERAL TYPEDEF *******************/
-
-/* Other fields that might be useful:
- *
- * char *name;     user-defined column name (format specification)
- * int reverse;    sorting in reverse (sort specification)
- *
- * name in place of u
- * reverse in place of n
- */
-
-typedef union sel_union {
-  pid_t pid;
-  pid_t ppid;
-  uid_t uid;
-  gid_t gid;
-  dev_t tty;
-  char  cmd[16];  /* this is _not_ \0 terminated */
-} sel_union;
-
-typedef struct selection_node {
-  struct selection_node *next;
-  sel_union *u;  /* used if selection type has a list of values */
-  int n;         /* used if selection type has a list of values */
-  int typecode;
-} selection_node;
-
-typedef struct sort_node {
-  struct sort_node *next;
-  int (*sr)(const proc_t* P, const proc_t* Q); /* sort function */
-  int reverse;   /* can sort backwards */
-  int typecode;
-  int need;
-} sort_node;
-
-typedef struct format_node {
-  struct format_node *next;
-  char *name;                             /* user can override default name */
-  int (*pr)(char *restrict const outbuf, const proc_t *restrict const pp); // print function
-/*  int (* const sr)(const proc_t* P, const proc_t* Q); */ /* sort function */
-  int width;
-  int need;
-  int vendor;                             /* Vendor that invented this */
-  int flags;
-  int typecode;
-} format_node;
-
-typedef struct format_struct {
-  const char *spec; /* format specifier */
-  const char *head; /* default header in the POSIX locale */
-  int (* const pr)(char *restrict const outbuf, const proc_t *restrict const pp); // print function
-  int (* const sr)(const proc_t* P, const proc_t* Q); /* sort function */
-  const int width;
-  const int need;       /* data we will need (files to read, etc.) */
-  const int vendor; /* Where does this come from? */
-  const int flags;
-} format_struct;
-
-/* though ps-specific, needed by general file */
-typedef struct macro_struct {
-  const char *spec; /* format specifier */
-  const char *head; /* default header in the POSIX locale */
-} macro_struct;
-
-/**************** PS TYPEDEF ***********************/
-
-typedef struct aix_struct {
-  const int   desc; /* 1-character format code */
-  const char *spec; /* format specifier */
-  const char *head; /* default header in the POSIX locale */
-} aix_struct;
-
-typedef struct shortsort_struct {
-  const int   desc; /* 1-character format code */
-  const char *spec; /* format specifier */
-} shortsort_struct;
-
-/* Save these options for later: -o o -O O --format --sort */
-typedef struct sf_node {
-  struct sf_node *next;  /* next arg */
-  format_node *f_cooked;  /* convert each arg alone, then merge */
-  sort_node   *s_cooked;  /* convert each arg alone, then merge */
-  char *sf;
-  int sf_code;
-} sf_node;
-
-/********************* UNDECIDED GLOBALS **************/
-
-/* output.c */
-extern void show_one_proc(const proc_t *restrict const p, const format_node *restrict fmt);
-extern void print_format_specifiers(void);
-extern const aix_struct *search_aix_array(const int findme);
-extern const shortsort_struct *search_shortsort_array(const int findme);
-extern const format_struct *search_format_array(const char *findme);
-extern const macro_struct *search_macro_array(const char *findme);
-extern void init_output(void);
-extern int pr_nop(char *restrict const outbuf, const proc_t *restrict const pp);
-
-/* global.c */
-extern void reset_global(void);
-
-/* global.c */
-extern int             all_processes;
-extern const char     *bsd_j_format;
-extern const char     *bsd_l_format;
-extern const char     *bsd_s_format;
-extern const char     *bsd_u_format;
-extern const char     *bsd_v_format;
-extern int             bsd_c_option;
-extern int             bsd_e_option;
-extern uid_t           cached_euid;
-extern dev_t           cached_tty;
-extern char            forest_prefix[4 * 32*1024 + 100];
-extern int             forest_type;
-extern unsigned        format_flags;     /* -l -f l u s -j... */
-extern format_node    *format_list; /* digested formatting options */
-extern unsigned        format_modifiers; /* -c -j -y -P -L... */
-extern int             header_gap;
-extern int             header_type; /* none, single, multi... */
-extern int             include_dead_children;
-extern int             lines_to_next_header;
-extern int             max_line_width;
-extern const char     *namelist_file;
-extern int             negate_selection;
-extern int             page_size;  // "int" for math reasons?
-extern unsigned        personality;
-extern int             prefer_bsd_defaults;
-extern int             running_only;
-extern int             screen_cols;
-extern int             screen_rows;
-extern time_t          seconds_since_boot;
-extern selection_node *selection_list;
-extern unsigned        simple_select;
-extern sort_node      *sort_list;
-extern const char     *sysv_f_format;
-extern const char     *sysv_fl_format;
-extern const char     *sysv_j_format;
-extern const char     *sysv_l_format;
-extern unsigned        thread_flags;
-extern int             unix_f_option;
-extern int             user_is_number;
-extern int             wchan_is_number;
-
-/************************* PS GLOBALS *********************/
-
-/* sortformat.c */
-extern int defer_sf_option(const char *arg, int source);
-extern const char *process_sf_options(int localbroken);
-extern void reset_sortformat(void);
-
-/* select.c */
-extern int want_this_proc(proc_t *buf);
-extern const char *select_bits_setup(void);
-
-/* help.c */
-extern const char *help_message;
-
-/* global.c */
-extern void self_info(void);
-
-/* parser.c */
-extern int arg_parse(int argc, char *argv[]);
-
-#endif
diff --git a/ps/display.c b/ps/display.c
deleted file mode 100644
index 74d1119b..00000000
--- a/ps/display.c
+++ /dev/null
@@ -1,576 +0,0 @@
-/*
- * Copyright 1998-2003 by Albert Cahalan; all rights resered.
- * This file may be used subject to the terms and conditions of the
- * GNU Library General Public License Version 2, or any later version
- * at your option, as published by the Free Software Foundation.
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Library General Public License for more details.
- */
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-#include <unistd.h>
-
-#if (__GNU_LIBRARY__ >= 6)
-# include <locale.h>
-#endif
-
-/* username lookups */
-#include <sys/types.h>
-#include <pwd.h>
-#include <grp.h>
-
-/* major/minor number */
-#include <sys/sysmacros.h>
-
-#include <signal.h>   /* catch signals */
-
-#include "common.h"
-#include "../proc/wchan.h"
-#include "../proc/version.h"
-#include "../proc/readproc.h"
-#include "../proc/sysinfo.h"
-#include "../proc/sig.h"
-
-#ifndef SIGCHLD
-#define SIGCHLD SIGCLD
-#endif
-
-/* just reports a crash */
-static void signal_handler(int signo){
-  if(signo==SIGPIPE) _exit(0);  /* "ps | head" will cause this */
-  /* fprintf() is not reentrant, but we _exit() anyway */
-  fprintf(stderr,
-    "\n\n"
-    "Signal %d (%s) caught by ps (%s).\n"
-    "Please send bug reports to <procps@freelists.org>\n",
-    signo,
-    signal_number_to_name(signo),
-    procps_version
-  );
-  _exit(signo+128);
-}
-
-/////////////////////////////////////////////////////////////////////////////////////
-#undef DEBUG
-#ifdef DEBUG
-void init_stack_trace(char *prog_name);
-
-#include <ctype.h>
-
-void hex_dump(void *vp){
-  char *charlist;
-  int i = 0;
-  int line = 45;
-  char *cp = (char *)vp;
-
-  while(line--){
-      printf("%8lx  ", (unsigned long)cp);
-      charlist = cp;
-      cp += 16;
-      for(i=0; i<16; i++){
-        if((charlist[i]>31) && (charlist[i]<127)){
-          printf("%c", charlist[i]);
-        }else{
-          printf(".");
-        }
-      }
-      printf(" ");
-      for(i=0; i<16; i++) printf(" %2x",(unsigned int)((unsigned char)(charlist[i])));
-      printf("\n");
-      i=0;
-  }
-}
-
-static void show_tgid(char *s, int n, sel_union *data){
-  printf("%s  ", s);
-  while(--n){
-    printf("%d,", data[n].tgid);
-  }
-  printf("%d\n", data[0].tgid);
-}
-
-static void show_uid(char *s, int n, sel_union *data){
-  struct passwd *pw_data;
-  printf("%s  ", s);
-  while(--n){
-    pw_data = getpwuid(data[n].uid);
-    if(pw_data) printf("%s,", pw_data->pw_name);
-    else        printf("%d,", data[n].uid);
-  }
-  pw_data = getpwuid(data[n].uid);
-  if(pw_data) printf("%s\n", pw_data->pw_name);
-  else        printf("%d\n", data[n].uid);
-}
-
-static void show_gid(char *s, int n, sel_union *data){
-  struct group *gr_data;
-  printf("%s  ", s);
-  while(--n){
-    gr_data = getgrgid(data[n].gid);
-    if(gr_data) printf("%s,", gr_data->gr_name);
-    else        printf("%d,", data[n].gid);
-  }
-  gr_data = getgrgid(data[n].gid);
-  if(gr_data) printf("%s\n", gr_data->gr_name);
-  else        printf("%d\n", data[n].gid);
-}
-
-static void show_tty(char *s, int n, sel_union *data){
-  printf("%s  ", s);
-  while(--n){
-    printf("%d:%d,", (int)major(data[n].tty), (int)minor(data[n].tty));
-  }
-  printf("%d:%d\n", (int)major(data[n].tty), (int)minor(data[n].tty));
-}
-
-static void show_cmd(char *s, int n, sel_union *data){
-  printf("%s  ", s);
-  while(--n){
-    printf("%.8s,", data[n].cmd);
-  }
-  printf("%.8s\n", data[0].cmd);
-}
-
-static void arg_show(void){
-  selection_node *walk = selection_list;
-  while(walk){
-    switch(walk->typecode){
-    case SEL_RUID: show_uid("RUID", walk->n, walk->u); break;
-    case SEL_EUID: show_uid("EUID", walk->n, walk->u); break;
-    case SEL_SUID: show_uid("SUID", walk->n, walk->u); break;
-    case SEL_FUID: show_uid("FUID", walk->n, walk->u); break;
-    case SEL_RGID: show_gid("RGID", walk->n, walk->u); break;
-    case SEL_EGID: show_gid("EGID", walk->n, walk->u); break;
-    case SEL_SGID: show_gid("SGID", walk->n, walk->u); break;
-    case SEL_FGID: show_gid("FGID", walk->n, walk->u); break;
-    case SEL_PGRP: show_pid("PGRP", walk->n, walk->u); break;
-    case SEL_PID : show_pid("PID ", walk->n, walk->u); break;
-    case SEL_PPID: show_pid("PPID", walk->n, walk->u); break;
-    case SEL_TTY : show_tty("TTY ", walk->n, walk->u); break;
-    case SEL_SESS: show_pid("SESS", walk->n, walk->u); break;
-    case SEL_COMM: show_cmd("COMM", walk->n, walk->u); break;
-    default: printf("Garbage typecode value!\n");
-    }
-    walk = walk->next;
-  }
-}
-
-#endif
-//////////////////////////////////////////////////////////////////////////
-
-
-/***** check the header */
-/* Unix98: must not print empty header */
-static void check_headers(void){
-  format_node *walk = format_list;
-  int head_normal = 0;
-  if(header_type==HEAD_MULTI){
-    header_gap = screen_rows-1;  /* true BSD */
-    return;
-  }
-  if(header_type==HEAD_NONE){
-    lines_to_next_header = -1;  /* old Linux */
-    return;
-  }
-  while(walk){
-    if(!*(walk->name)){
-      walk = walk->next;
-      continue;
-    }
-    if(walk->pr){
-      head_normal++;
-      walk = walk->next;
-      continue;
-    }
-    walk = walk->next;
-  }
-  if(!head_normal) lines_to_next_header = -1; /* how UNIX does --noheader */
-}
-
-/***** check sort needs */
-/* see what files need to be read, etc. */
-static unsigned check_sort_needs(sort_node *walk){
-  unsigned needs = 0;
-  while(walk){
-    needs |= walk->need;
-    walk = walk->next;
-  }
-  return needs;
-}
-
-/***** check needs */
-/* see what files need to be read, etc. */
-static unsigned collect_format_needs(format_node *walk){
-  unsigned needs = 0;
-  while(walk){
-    needs |= walk->need;
-    walk = walk->next;
-  }
-  return needs;
-}
-
-static format_node *proc_format_list;
-static format_node *task_format_list;
-
-static unsigned needs_for_threads;
-static unsigned needs_for_sort;
-static unsigned proc_format_needs;
-static unsigned task_format_needs;
-
-#define needs_for_format (proc_format_needs|task_format_needs)
-
-#define PROC_ONLY_FLAGS (PROC_FILLENV|PROC_FILLARG|PROC_FILLCOM|PROC_FILLMEM|PROC_FILLCGROUP)
-
-/***** munge lists and determine openproc() flags */
-static void lists_and_needs(void){
-  check_headers();
-
-  // only care about the difference when showing both
-  if(thread_flags & TF_show_both){
-    format_node pfn, tfn; // junk, to handle special case at begin of list
-    format_node *walk = format_list;
-    format_node *p_end = &pfn;
-    format_node *t_end = &tfn;
-    while(walk){
-      format_node *new = malloc(sizeof(format_node));
-      memcpy(new,walk,sizeof(format_node));
-      p_end->next = walk;
-      t_end->next = new;
-      p_end       = walk;
-      t_end       = new;
-      switch(walk->flags & CF_PRINT_MASK){
-      case CF_PRINT_THREAD_ONLY:
-        p_end->pr   = pr_nop;
-        p_end->need = 0;
-        break;
-      case CF_PRINT_PROCESS_ONLY:
-        t_end->pr   = pr_nop;
-        t_end->need = 0;
-        break;
-      default:
-        fprintf(stderr, "please report this bug\n");
-        // FALL THROUGH
-      case CF_PRINT_AS_NEEDED:
-      case CF_PRINT_EVERY_TIME:
-        break;
-      }
-      walk = walk->next;
-    }
-    t_end->next = NULL;
-    p_end->next = NULL;
-    proc_format_list = pfn.next;
-    task_format_list = tfn.next;
-  }else{
-    proc_format_list = format_list;
-    task_format_list = format_list;
-  }
-
-  proc_format_needs = collect_format_needs(proc_format_list);
-  task_format_needs = collect_format_needs(task_format_list);
-
-  needs_for_sort = check_sort_needs(sort_list);
-
-  // move process-only flags to the process
-  proc_format_needs |= (task_format_needs &~ PROC_ONLY_FLAGS);
-  task_format_needs &= ~PROC_ONLY_FLAGS;
-
-  if(bsd_c_option){
-    proc_format_needs &= ~PROC_FILLARG;
-    needs_for_sort    &= ~PROC_FILLARG;
-  }
-  if(!unix_f_option){
-    proc_format_needs &= ~PROC_FILLCOM;
-    needs_for_sort    &= ~PROC_FILLCOM;
-  }
-  // convert ARG to COM as a standard
-  if(proc_format_needs & PROC_FILLARG){
-    proc_format_needs |= (PROC_FILLCOM | PROC_EDITCMDLCVT);
-    proc_format_needs &= ~PROC_FILLARG;
-  }
-  if(bsd_e_option){
-    if(proc_format_needs&PROC_FILLCOM) proc_format_needs |= PROC_FILLENV;
-  }
-
-  /* FIXME  broken filthy hack -- got to unify some stuff here */
-  if( ( (proc_format_needs|task_format_needs|needs_for_sort) & PROC_FILLWCHAN) && !wchan_is_number)
-    if (open_psdb(namelist_file)) wchan_is_number = 1;
-
-  if(thread_flags&TF_loose_tasks) needs_for_threads |= PROC_LOOSE_TASKS;
-}
-
-//////////////////////////////////////////////////////////////////////////
-
-/***** fill in %CPU; not in libproc because of include_dead_children */
-/* Note: for sorting, not display, so 0..0x7fffffff would be OK */
-static int want_this_proc_pcpu(proc_t *buf){
-  unsigned long long used_jiffies;
-  unsigned long pcpu = 0;
-  unsigned long long avail_jiffies;
-
-  if(!want_this_proc(buf)) return 0;
-
-  used_jiffies = buf->utime + buf->stime;
-  if(include_dead_children) used_jiffies += (buf->cutime + buf->cstime);
-
-  avail_jiffies = seconds_since_boot * Hertz - buf->start_time;
-  if(avail_jiffies) pcpu = (used_jiffies << 24) / avail_jiffies;
-
-  buf->pcpu = pcpu;  // fits in an int, summing children on 128 CPUs
-
-  return 1;
-}
-
-/***** just display */
-static void simple_spew(void){
-  static proc_t buf, buf2;       // static avoids memset
-  PROCTAB* ptp;
-
-  ptp = openproc(needs_for_format | needs_for_sort | needs_for_select | needs_for_threads);
-  if(!ptp) {
-    fprintf(stderr, "Error: can not access /proc.\n");
-    exit(1);
-  }
-  switch(thread_flags & (TF_show_proc|TF_loose_tasks|TF_show_task)){
-  case TF_show_proc:                   // normal non-thread output
-    while(readproc(ptp,&buf)){
-      if(want_this_proc(&buf)){
-        show_one_proc(&buf, proc_format_list);
-      }
-    }
-    break;
-  case TF_show_proc|TF_loose_tasks:    // H option
-    while(readproc(ptp,&buf)){
-      // must still have the process allocated
-      while(readtask(ptp,&buf,&buf2)){
-        if(!want_this_proc(&buf)) continue;
-        show_one_proc(&buf2, task_format_list);
-      }
-    }
-    break;
-  case TF_show_proc|TF_show_task:      // m and -m options
-    while(readproc(ptp,&buf)){
-      if(want_this_proc(&buf)){
-        show_one_proc(&buf, proc_format_list);
-        // must still have the process allocated
-        while(readtask(ptp,&buf,&buf2)) show_one_proc(&buf2, task_format_list);
-      }
-     }
-    break;
-  case TF_show_task:                   // -L and -T options
-    while(readproc(ptp,&buf)){
-      if(want_this_proc(&buf)){
-        // must still have the process allocated
-        while(readtask(ptp,&buf,&buf2)) show_one_proc(&buf2, task_format_list);
-      }
-   }
-    break;
-  }
-  closeproc(ptp);
-}
-
-/***** forest output requires sorting by ppid; add start_time by default */
-static void prep_forest_sort(void){
-  sort_node *tmp_list = sort_list;
-  const format_struct *incoming;
-
-  if(!sort_list) {     /* assume start time order */
-    incoming = search_format_array("start_time");
-    if(!incoming) { fprintf(stderr, "Could not find start_time!\n"); exit(1); }
-    tmp_list = malloc(sizeof(sort_node));
-    tmp_list->reverse = 0;
-    tmp_list->typecode = '?'; /* what was this for? */
-    tmp_list->sr = incoming->sr;
-    tmp_list->need = incoming->need;
-    tmp_list->next = sort_list;
-    sort_list = tmp_list;
-  }
-  /* this is required for the forest option */
-  incoming = search_format_array("ppid");
-  if(!incoming) { fprintf(stderr, "Could not find ppid!\n"); exit(1); }
-  tmp_list = malloc(sizeof(sort_node));
-  tmp_list->reverse = 0;
-  tmp_list->typecode = '?'; /* what was this for? */
-  tmp_list->sr = incoming->sr;
-  tmp_list->need = incoming->need;
-  tmp_list->next = sort_list;
-  sort_list = tmp_list;
-}
-
-/* we rely on the POSIX requirement for zeroed memory */
-//static proc_t *processes[98*1024];  // FIXME
-static proc_t **processes;
-
-/***** compare function for qsort */
-static int compare_two_procs(const void *a, const void *b){
-  sort_node *tmp_list = sort_list;
-  while(tmp_list){
-    int result;
-    result = (*tmp_list->sr)(*(const proc_t *const*)a, *(const proc_t *const*)b);
-    if(result) return (tmp_list->reverse) ? -result : result;
-    tmp_list = tmp_list->next;
-  }
-  return 0; /* no conclusion */
-}
-
-/***** show pre-sorted array of process pointers */
-static void show_proc_array(PROCTAB *restrict ptp, int n){
-  proc_t **p = processes;
-  while(n--){
-    if(thread_flags & TF_show_proc) show_one_proc(*p, proc_format_list);
-    if(thread_flags & TF_show_task){
-      static proc_t buf2;         // static avoids memset
-      // must still have the process allocated
-      while(readtask(ptp,*p,&buf2)) show_one_proc(&buf2, task_format_list);
-    }
-    p++;
-  }
-}
-
-/***** show tree */
-/* this needs some optimization work */
-#define ADOPTED(x) 1
-static void show_tree(const int self, const int n, const int level, const int have_sibling){
-  int i = 0;
-  if(level){
-    /* add prefix of "+" or "L" */
-    if(have_sibling) forest_prefix[level-1] = '+';
-    else             forest_prefix[level-1] = 'L';
-    forest_prefix[level] = '\0';
-  }
-  show_one_proc(processes[self],format_list);  /* first show self */
-  for(;;){  /* look for children */
-    if(i >= n) return; /* no children */
-    if(processes[i]->ppid == processes[self]->XXXID) break;
-    i++;
-  }
-  if(level){
-    /* change our prefix to "|" or " " for the children */
-    if(have_sibling) forest_prefix[level-1] = '|';
-    else             forest_prefix[level-1] = ' ';
-    forest_prefix[level] = '\0';
-  }
-  for(;;){
-    int self_pid;
-    int more_children = 1;
-    if(i >= n) break; /* over the edge */
-    self_pid=processes[self]->XXXID;
-    if(i+1 >= n)
-      more_children = 0;
-    else
-      if(processes[i+1]->ppid != self_pid) more_children = 0;
-    if(self_pid==1 && ADOPTED(processes[i]) && forest_type!='u')
-      show_tree(i++, n, level,   more_children);
-    else
-      show_tree(i++, n, level+1, more_children);
-    if(!more_children) break;
-  }
-  /* chop prefix that children added -- do we need this? */
-  forest_prefix[level] = '\0';
-//  memset(processes[self], '$', sizeof(proc_t));  /* debug */
-}
-
-/***** show forest */
-static void show_forest(const int n){
-  int i = n;
-  int j;
-  while(i--){   /* cover whole array looking for trees */
-    j = n;
-    while(j--){   /* search for parent: if none, i is a tree! */
-      if(processes[j]->XXXID == processes[i]->ppid) goto not_root;
-    }
-    show_tree(i,n,0,0);
-not_root:
-    ;
-  }
-  /* don't free the array because it takes time and ps will exit anyway */
-}
-
-#if 0
-static int want_this_proc_nop(proc_t *dummy){
-  (void)dummy;
-  return 1;
-}
-#endif
-
-/***** sorted or forest */
-static void fancy_spew(void){
-  proc_data_t *pd = NULL;
-  PROCTAB *restrict ptp;
-  int n = 0;  /* number of processes & index into array */
-
-  ptp = openproc(needs_for_format | needs_for_sort | needs_for_select | needs_for_threads);
-  if(!ptp) {
-    fprintf(stderr, "Error: can not access /proc.\n");
-    exit(1);
-  }
-
-  if(thread_flags & TF_loose_tasks){
-    pd = readproctab3(want_this_proc_pcpu, ptp);
-  }else{
-    pd = readproctab2(want_this_proc_pcpu, (void*)0xdeadbeaful, ptp);
-  }
-  n = pd->n;
-  processes = pd->tab;
-
-  if(!n) return;  /* no processes */
-  if(forest_type) prep_forest_sort();
-  qsort(processes, n, sizeof(proc_t*), compare_two_procs);
-  if(forest_type) show_forest(n);
-  else show_proc_array(ptp,n);
-  closeproc(ptp);
-}
-
-
-/***** no comment */
-int main(int argc, char *argv[]){
-#if (__GNU_LIBRARY__ >= 6)
-  setlocale (LC_CTYPE, "");
-#endif
-
-#ifdef DEBUG
-  init_stack_trace(argv[0]);
-#else
-  do {
-    struct sigaction sa;
-    int i = 32;
-    memset(&sa, 0, sizeof(sa));
-    sa.sa_handler = signal_handler;
-    sigfillset(&sa.sa_mask);
-    while(i--) switch(i){
-    default:
-      sigaction(i,&sa,NULL);
-    case 0:
-    case SIGINT:   /* ^C */
-    case SIGTSTP:  /* ^Z */
-    case SIGTTOU:  /* see stty(1) man page */
-    case SIGQUIT:  /* ^\ */
-    case SIGPROF:  /* profiling */
-    case SIGKILL:  /* can not catch */
-    case SIGSTOP:  /* can not catch */
-    case SIGWINCH: /* don't care if window size changes */
-      ;
-    }
-  } while (0);
-#endif
-
-  reset_global();  /* must be before parser */
-  arg_parse(argc,argv);
-
-/*  arg_show(); */
-  trace("screen is %ux%u\n",screen_cols,screen_rows);
-/*  printf("sizeof(proc_t) is %d.\n", sizeof(proc_t)); */
-  trace("======= ps output follows =======\n");
-
-  init_output(); /* must be between parser and output */
-
-  lists_and_needs();
-
-  if(forest_type || sort_list) fancy_spew(); /* sort or forest */
-  else simple_spew(); /* no sort, no forest */
-  show_one_proc((proc_t *)-1,format_list); /* no output yet? */
-  return 0;
-}
diff --git a/ps/global.c b/ps/global.c
deleted file mode 100644
index f795e018..00000000
--- a/ps/global.c
+++ /dev/null
@@ -1,498 +0,0 @@
-/*
- * Copyright 1998-2002 by Albert Cahalan; all rights resered.         
- * This file may be used subject to the terms and conditions of the
- * GNU Library General Public License Version 2, or any later version  
- * at your option, as published by the Free Software Foundation.
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Library General Public License for more details.
- */                                 
-#include <stdlib.h>
-#include <termios.h>
-#include <stdio.h>
-#include <unistd.h>
-#include <sys/ioctl.h>
-#include <sys/types.h>
-#include <pwd.h>
-#include <grp.h>
-#include <string.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-                     
-
-#include "common.h"
-
-#include <sys/sysmacros.h>
-#include "../proc/wchan.h"
-#include "../proc/version.h"
-#include "../proc/sysinfo.h"
-
-
-#ifndef __GNU_LIBRARY__
-#define __GNU_LIBRARY__ -1
-#endif
-#ifndef __GLIBC__
-#define __GLIBC__ -1
-#endif
-#ifndef __GLIBC_MINOR__
-#define __GLIBC_MINOR__ -1
-#endif
-
-
-static const char * saved_personality_text = "You found a bug!";
-
-int             all_processes = -1;
-const char     *bsd_j_format = (const char *)0xdeadbeef;
-const char     *bsd_l_format = (const char *)0xdeadbeef;
-const char     *bsd_s_format = (const char *)0xdeadbeef;
-const char     *bsd_u_format = (const char *)0xdeadbeef;
-const char     *bsd_v_format = (const char *)0xdeadbeef;
-int             bsd_c_option = -1;
-int             bsd_e_option = -1;
-uid_t           cached_euid = -1;
-dev_t           cached_tty = -1;
-char            forest_prefix[4 * 32*1024 + 100];     // FIXME
-int             forest_type = -1;
-unsigned        format_flags = 0xffffffff;   /* -l -f l u s -j... */
-format_node    *format_list = (format_node *)0xdeadbeef; /* digested formatting options */
-unsigned        format_modifiers = 0xffffffff;   /* -c -j -y -P -L... */
-int             header_gap = -1;
-int             header_type = -1;
-int             include_dead_children = -1;
-int             lines_to_next_header = -1;
-const char     *namelist_file = (const char *)0xdeadbeef;
-int             negate_selection = -1;
-int             running_only = -1;
-int             page_size = -1;  // "int" for math reasons?
-unsigned        personality = 0xffffffff;
-int             prefer_bsd_defaults = -1;
-int             screen_cols = -1;
-int             screen_rows = -1;
-time_t          seconds_since_boot = -1;
-selection_node *selection_list = (selection_node *)0xdeadbeef;
-unsigned        simple_select = 0xffffffff;
-sort_node      *sort_list = (sort_node *)0xdeadbeef; /* ready-to-use sort list */
-const char     *sysv_f_format = (const char *)0xdeadbeef;
-const char     *sysv_fl_format = (const char *)0xdeadbeef;
-const char     *sysv_j_format = (const char *)0xdeadbeef;
-const char     *sysv_l_format = (const char *)0xdeadbeef;
-unsigned        thread_flags = 0xffffffff;
-int             unix_f_option = -1;
-int             user_is_number = -1;
-int             wchan_is_number = -1;
-
-
-static void reset_selection_list(void){
-  selection_node *old;
-  selection_node *walk = selection_list;
-  if(selection_list == (selection_node *)0xdeadbeef){
-    selection_list = NULL;
-    return;
-  }
-  while(walk){
-    old = walk;
-    walk = old->next;
-    free(old->u);
-    free(old);
-  }
-  selection_list = NULL;
-}
-
-// The rules:
-// 1. Defaults are implementation-specific. (ioctl,termcap,guess)
-// 2. COLUMNS and LINES override the defaults. (standards compliance)
-// 3. Command line options override everything else.
-// 4. Actual output may be more if the above is too narrow.
-//
-// SysV tends to spew semi-wide output in all cases. The args
-// will be limited to 64 or 80 characters, without regard to
-// screen size. So lines of 120 to 160 chars are normal.
-// Tough luck if you want more or less than that! HP-UX has a
-// new "-x" option for 1024-char args in place of comm that
-// we'll implement at some point.
-//
-// BSD tends to make a good effort, then fall back to 80 cols.
-// Use "ww" to get infinity. This is nicer for "ps | less"
-// and "watch ps". It can run faster too.
-static void set_screen_size(void){
-  struct winsize ws;
-  char *columns; /* Unix98 environment variable */
-  char *lines;   /* Unix98 environment variable */
-
-  do{
-    int fd;
-    if(ioctl(STDOUT_FILENO, TIOCGWINSZ, &ws) != -1 && ws.ws_col>0 && ws.ws_row>0) break;
-    if(ioctl(STDERR_FILENO, TIOCGWINSZ, &ws) != -1 && ws.ws_col>0 && ws.ws_row>0) break;
-    if(ioctl(STDIN_FILENO,  TIOCGWINSZ, &ws) != -1 && ws.ws_col>0 && ws.ws_row>0) break;
-    fd = open("/dev/tty", O_NOCTTY|O_NONBLOCK|O_RDONLY);
-    if(fd != -1){
-      int ret = ioctl(fd, TIOCGWINSZ, &ws);
-      close(fd);
-      if(ret != -1 && ws.ws_col>0 && ws.ws_row>0) break;
-    }
-    // TODO: ought to do tgetnum("co") and tgetnum("li") here
-    ws.ws_col = 80;
-    ws.ws_row = 24;
-  }while(0);
-  screen_cols = ws.ws_col;  // hmmm, NetBSD subtracts 1
-  screen_rows = ws.ws_row;
-
-  // TODO: delete this line
-  if(!isatty(STDOUT_FILENO)) screen_cols = OUTBUF_SIZE;
-
-  columns = getenv("COLUMNS");
-  if(columns && *columns){
-    long t;
-    char *endptr;
-    t = strtol(columns, &endptr, 0);
-    if(!*endptr && (t>0) && (t<(long)OUTBUF_SIZE)) screen_cols = (int)t;
-  }
-
-  lines   = getenv("LINES");
-  if(lines && *lines){
-    long t;
-    char *endptr;
-    t = strtol(lines, &endptr, 0);
-    if(!*endptr && (t>0) && (t<(long)OUTBUF_SIZE)) screen_rows = (int)t;
-  }
-
-  if((screen_cols<9) || (screen_rows<2))
-    fprintf(stderr,"Your %dx%d screen size is bogus. Expect trouble.\n",
-      screen_cols, screen_rows
-    );
-}
-
-/**************** personality control **************/
-
-typedef struct personality_table_struct {
-  const char *name; /* personality name */
-  const void *jump; /* See gcc extension info.   :-)   */
-} personality_table_struct;
-
-static int compare_personality_table_structs(const void *a, const void *b){
-  return strcasecmp(((const personality_table_struct*)a)->name,((const personality_table_struct*)b)->name);
-}
-
-static const char *set_personality(void){
-  const char *s;
-  size_t sl;
-  char buf[16];
-  personality_table_struct findme = { buf, NULL};
-  personality_table_struct *found;
-  static const personality_table_struct personality_table[] = {
-  {"390",      &&case_390},
-  {"aix",      &&case_aix},
-  {"bsd",      &&case_bsd},
-  {"compaq",   &&case_compaq},
-  {"debian",   &&case_debian},
-  {"default",  &&case_default},
-  {"digital",  &&case_digital},
-  {"gnu",      &&case_gnu},
-  {"hp",       &&case_hp},
-  {"hpux",     &&case_hpux},
-  {"irix",     &&case_irix},
-  {"linux",    &&case_linux},
-  {"old",      &&case_old},
-  {"os390",    &&case_os390},
-  {"posix",    &&case_posix},
-  {"s390",     &&case_s390},
-  {"sco",      &&case_sco},
-  {"sgi",      &&case_sgi},
-  {"solaris2", &&case_solaris2},
-  {"sunos4",   &&case_sunos4},
-  {"svr4",     &&case_svr4},
-  {"sysv",     &&case_sysv},
-  {"tru64",    &&case_tru64},
-  {"unix",     &&case_unix},
-  {"unix95",   &&case_unix95},
-  {"unix98",   &&case_unix98},
-  {"unknown",  &&case_unknown}
-  };
-  const int personality_table_count = sizeof(personality_table)/sizeof(personality_table_struct);
-
-  personality = 0;
-  prefer_bsd_defaults = 0;
-
-  bsd_j_format = "OL_j";
-  bsd_l_format = "OL_l";
-  bsd_s_format = "OL_s";
-  bsd_u_format = "OL_u";
-  bsd_v_format = "OL_v";
-
-  /* When these are NULL, the code does SysV output modifier logic */
-  sysv_f_format  = NULL;
-  sysv_fl_format = NULL;
-  sysv_j_format  = NULL;
-  sysv_l_format  = NULL;
-
-  s = getenv("PS_PERSONALITY");
-  if(!s || !*s) s = getenv("CMD_ENV");
-  if(!s || !*s) s="unknown";   /* "Do The Right Thing[tm]" */
-  if(getenv("I_WANT_A_BROKEN_PS")) s="old";
-  sl = strlen(s);
-  if(sl > 15) return "Environment specified an unknown personality.";
-  strncpy(buf, s, sl);
-  buf[sl] = '\0';
-  saved_personality_text = strdup(buf);
-
-  found = bsearch(&findme, personality_table, personality_table_count,
-      sizeof(personality_table_struct), compare_personality_table_structs
-  );
-
-  if(!found) return "Environment specified an unknown personality.";
-
-  goto *(found->jump);    /* See gcc extension info.  :-)   */
-
-  case_bsd:
-    personality = PER_FORCE_BSD | PER_BSD_h | PER_BSD_m;
-    prefer_bsd_defaults = 1;
-    bsd_j_format = "FB_j";
-    bsd_l_format = "FB_l";
-    /* bsd_s_format not used */
-    bsd_u_format = "FB_u";
-    bsd_v_format = "FB_v";
-    return NULL;
-
-  case_old:
-    personality = PER_FORCE_BSD | PER_OLD_m;
-    prefer_bsd_defaults = 1;
-    return NULL;
-
-  case_debian:  /* Toss this? They don't seem to care much. */
-  case_gnu:
-    personality = PER_GOOD_o | PER_OLD_m;
-    prefer_bsd_defaults = 1;
-    sysv_f_format  = "RD_f";
-    /* sysv_fl_format = "RD_fl"; */   /* old Debian ps can't do this! */
-    sysv_j_format  = "RD_j";
-    sysv_l_format  = "RD_l";
-    return NULL;
-
-  case_linux:
-    personality = PER_GOOD_o | PER_ZAP_ADDR | PER_SANE_USER;
-    return NULL;
-
-  case_default: /* use defaults for ps, ignoring other environment variables */
-    return NULL;
-
-  case_unknown: /* defaults, but also check inferior environment variables */
-    if(
-      getenv("UNIX95")     /* Irix */
-      || getenv("POSIXLY_CORRECT")  /* most gnu stuff */
-      || (getenv("POSIX2") && !strcmp(getenv("POSIX2"), "on")) /* Unixware 7 */
-    ) personality = PER_BROKEN_o;
-    return NULL;
-
-  case_aix:
-    bsd_j_format = "FB_j";
-    bsd_l_format = "FB_l";
-    /* bsd_s_format not used */
-    bsd_u_format = "FB_u";
-    bsd_v_format = "FB_v";
-    return NULL;
-
-  case_tru64:
-  case_compaq:
-  case_digital:
-    // no PER_NO_DEFAULT_g even though man page claims it
-    // Reality: the g is a NOP
-    personality = PER_GOOD_o | PER_BSD_h;
-    prefer_bsd_defaults = 1;
-    sysv_f_format  = "F5FMT";
-    sysv_fl_format = "FL5FMT";
-    sysv_j_format  = "JFMT";
-    sysv_l_format  = "L5FMT";
-    bsd_j_format = "JFMT";
-    bsd_l_format = "LFMT";
-    bsd_s_format = "SFMT";
-    bsd_u_format = "UFMT";
-    bsd_v_format = "VFMT";
-    return NULL;
-
-  case_sunos4:
-    personality = PER_NO_DEFAULT_g;
-    prefer_bsd_defaults = 1;
-    bsd_j_format = "FB_j";
-    bsd_l_format = "FB_l";
-    /* bsd_s_format not used */
-    bsd_u_format = "FB_u";
-    bsd_v_format = "FB_v";
-    return NULL;
-
-  case_irix:
-  case_sgi:
-    s = getenv("_XPG");
-    if(s && s[0]>'0' && s[0]<='9') personality = PER_BROKEN_o;
-    else personality = PER_IRIX_l;
-    return NULL;
-
-  case_os390:  /* IBM's OS/390 OpenEdition on the S/390 mainframe */
-  case_s390:
-  case_390:
-    sysv_j_format  = "J390";  /* don't know what -jl and -jf do */
-    return NULL;
-
-  case_hp:
-  case_hpux:
-    personality = PER_BROKEN_o | PER_HPUX_x;
-    return NULL;
-
-  case_svr4:
-  case_sysv:
-  case_sco:
-    personality = PER_BROKEN_o | PER_SVR4_x;
-    return NULL;
-
-  case_posix:
-  case_solaris2:
-  case_unix95:
-  case_unix98:
-  case_unix:
-    personality = PER_BROKEN_o;
-    return NULL;
-}
-
-
-/************ Call this to reinitialize everything ***************/
-void reset_global(void){
-  static proc_t p;
-  reset_selection_list();
-  look_up_our_self(&p);
-  set_screen_size();
-  set_personality();
-  
-  all_processes         = 0;
-  bsd_c_option          = 0;
-  bsd_e_option          = 0;
-  cached_euid           = geteuid();
-  cached_tty            = p.tty;
-/* forest_prefix must be all zero because of POSIX */
-  forest_type           = 0;
-  format_flags          = 0;   /* -l -f l u s -j... */
-  format_list           = NULL; /* digested formatting options */
-  format_modifiers      = 0;   /* -c -j -y -P -L... */
-  header_gap            = -1;  /* send lines_to_next_header to -infinity */
-  header_type           = HEAD_SINGLE;
-  include_dead_children = 0;
-  lines_to_next_header  = 1;
-  namelist_file         = NULL;
-  negate_selection      = 0;
-  page_size             = getpagesize();
-  running_only          = 0;
-  seconds_since_boot    = uptime(0,0);
-  selection_list        = NULL;
-  simple_select         = 0;
-  sort_list             = NULL;
-  thread_flags          = 0;
-  unix_f_option         = 0;
-  user_is_number        = 0;
-  wchan_is_number       = 0;
-}
-
-static const char archdefs[] =
-#ifdef __alpha__
-" alpha"
-#endif
-#ifdef __arm__
-" arm"
-#endif
-#ifdef __hppa__
-" hppa"
-#endif
-#ifdef __i386__
-" i386"
-#endif
-#ifdef __ia64__
-" ia64"
-#endif
-#ifdef __mc68000__
-" mc68000"
-#endif
-#ifdef __mips64__
-" mips64"
-#endif
-#ifdef __mips__
-" mips"
-#endif
-#ifdef __powerpc__
-" powerpc"
-#endif
-#ifdef __sh3__
-" sh3"
-#endif
-#ifdef __sh__
-" sh"
-#endif
-#ifdef __sparc__
-" sparc"
-#endif
-#ifdef __sparc_v9__
-" sparc_v9"
-#endif
-#ifdef __x86_64__
-" x86_64"
-#endif
-"";
-
-/*********** spew variables ***********/
-void self_info(void){
-  fprintf(stderr,
-    "BSD j    %s\n"
-    "BSD l    %s\n"
-    "BSD s    %s\n"
-    "BSD u    %s\n"
-    "BSD v    %s\n"
-    "SysV -f  %s\n"
-    "SysV -fl %s\n"
-    "SysV -j  %s\n"
-    "SysV -l  %s\n"
-    "\n",
-    bsd_j_format   ? bsd_j_format   : "(none)",
-    bsd_l_format   ? bsd_l_format   : "(none)",
-    bsd_s_format   ? bsd_s_format   : "(none)",
-    bsd_u_format   ? bsd_u_format   : "(none)",
-    bsd_v_format   ? bsd_v_format   : "(none)",
-    sysv_f_format  ? sysv_f_format  : "(none)",
-    sysv_fl_format ? sysv_fl_format : "(none)",
-    sysv_j_format  ? sysv_j_format  : "(none)",
-    sysv_l_format  ? sysv_l_format  : "(none)"
-  );
-
-  display_version();
-  fprintf(stderr, "Linux version %d.%d.%d\n",
-    LINUX_VERSION_MAJOR(linux_version_code),
-    LINUX_VERSION_MINOR(linux_version_code),
-    LINUX_VERSION_PATCH(linux_version_code)
-  );
-  /* __libc_print_version(); */  /* how can we get the run-time version? */
-  fprintf(stderr, "Compiled with: glibc %d.%d, gcc %d.%d\n\n",
-    __GLIBC__, __GLIBC_MINOR__, __GNUC__, __GNUC_MINOR__
-  );
-
-  fprintf(stderr,
-    "header_gap=%d lines_to_next_header=%d\n"
-    "screen_cols=%d screen_rows=%d\n"
-    "\n",
-    header_gap, lines_to_next_header,
-    screen_cols, screen_rows
-  );
-
-  fprintf(stderr,
-    "personality=0x%08x (from \"%s\")\n"
-    "EUID=%d TTY=%d,%d Hertz=%Ld page_size=%d\n",
-    personality, saved_personality_text,
-    cached_euid, (int)major(cached_tty), (int)minor(cached_tty), Hertz,
-    (int)(page_size)
-  );
-
-  fprintf(stderr,
-    "sizeof(proc_t)=%d sizeof(long)=%d sizeof(KLONG)=%d\n",
-    (int)sizeof(proc_t), (int)sizeof(long), (int)sizeof(KLONG)
-  );
-
-  fprintf(stderr, "archdefs:%s\n", archdefs);
-
-  open_psdb(namelist_file);
-  fprintf(stderr,"namelist_file=\"%s\"\n",namelist_file?namelist_file:"<no System.map file>");
-}
diff --git a/ps/help.c b/ps/help.c
deleted file mode 100644
index 2f39a9da..00000000
--- a/ps/help.c
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright 1998-2004 by Albert Cahalan; all rights reserved.
- * This file may be used subject to the terms and conditions of the
- * GNU Library General Public License Version 2, or any later version
- * at your option, as published by the Free Software Foundation.
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Library General Public License for more details.
- */
-
-/*
- * The help message must not become longer, because it must fit
- * on an 80x24 screen _with_ the error message and command prompt.
- */
-
-const char *help_message =
-"********* simple selection *********  ********* selection by list *********\n"
-"-A all processes                      -C by command name\n"
-"-N negate selection                   -G by real group ID (supports names)\n"
-"-a all w/ tty except session leaders  -U by real user ID (supports names)\n"
-"-d all except session leaders         -g by session OR by effective group name\n"
-"-e all processes                      -p by process ID\n"
-"T  all processes on this terminal     -s processes in the sessions given\n"
-"a  all w/ tty, including other users  -t by tty\n"
-"g  OBSOLETE -- DO NOT USE             -u by effective user ID (supports names)\n"
-"r  only running processes             U  processes for specified users\n"
-"x  processes w/o controlling ttys     t  by tty\n"
-"*********** output format **********  *********** long options ***********\n"
-"-o,o user-defined  -f full            --Group --User --pid --cols --ppid\n"
-"-j,j job control   s  signal          --group --user --sid --rows --info\n"
-"-O,O preloaded -o  v  virtual memory  --cumulative --format --deselect\n"
-"-l,l long          u  user-oriented   --sort --tty --forest --version\n"
-"-F   extra full    X  registers       --heading --no-heading --context\n"
-"                    ********* misc options *********\n"
-"-V,V  show version      L  list format codes  f  ASCII art forest\n"
-"-m,m,-L,-T,H  threads   S  children in sum    -y change -l format\n"
-"-M,Z  security data     c  true command name  -c scheduling class\n"
-"-w,w  wide output       n  numeric WCHAN,UID  -H process hierarchy\n"
-;
-
-
-
-/* Missing:
- *
- * -P e k
- *
- */
diff --git a/ps/it b/ps/it
deleted file mode 100644
index 07fd6dce..00000000
--- a/ps/it
+++ /dev/null
@@ -1,35 +0,0 @@
-From ddainese@dsi.unive.it Sun Apr 18 14:12:27 1999
-
-here is a first translation of the text:
----------------------------------------------------------------------
-const char *help_message =
-"****** seleziona i processi *******   * seleziona una lista specificando: *\n"
-"-A tutti                              -C il nome del comando\n"
-"-N nega la selezione                  -G il real group ID (supporta i nomi)\n"
-"-a con tty, tranne i session leader   -U il real user ID (supporta i nomi)\n"
-"-d tutti, tranne i session leader     -g il session leader OPPURE il gruppo\n"
-"-e tutti                              -p l'ID del processo\n"
-"T  su questo terminale                -s la sessione\n"
-"a  con tty, di tutti gli utenti       -t il tty\n"
-"g  tutti, anche i leader di gruppo    -u l'effective user ID (supporta i nomi)\n"
-"r  in stato running                   U  una lista di utenti\n"
-"x  senza tty                          t  il tty\n"
-"******** formato dell'output ******   ********** opzioni lunghe **********\n"
-"-o,o definito dall'utente                --Group --User --pid --cols\n"
-"-j,j job              s segnali          --group --user --sid --rows\n"
-"-O,O -o preimpostato  v memoria virtuale --cumulative --format --deselect\n"
-"-l,l lungo            u utenti           --sort --tty --forest --version\n"
-"-f   completo         X registri         --heading --no-heading\n"
-"                    ******** opzioni varie *********\n"
-"-V,V versione           L  codici di formato       f  foresta di ASCII\n"
-"-m,m vista ad albero    S  figli in sum           -y  cambia il formato -l\n"
-"-n,N namelist file      c  nome reale del comando  n  WCHAN,UID numerici\n"
-"-w,w output ampio       e  mostra l'environment   -H  gerarchia dei processi\n"
-;
----------------------------------------------------------------------
-
-Unfortunately it isn't really understandable for a newbie, because
-there is too little space for a good translation; to make it more
-meaningful, I would need about an entire line for every option, thus
-if you really want the help text stays under 22 lines, it must
-contains only 22 options. What do you think about it?
diff --git a/ps/output.c b/ps/output.c
deleted file mode 100644
index 54b0585f..00000000
--- a/ps/output.c
+++ /dev/null
@@ -1,2010 +0,0 @@
-/*
- * Copyright 1999-2004 by Albert Cahalan; all rights reserved.
- *
- * This file may be used subject to the terms and conditions of the
- * GNU Library General Public License Version 2, or any later version
- * at your option, as published by the Free Software Foundation.
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Library General Public License for more details.
- */
-
-/*
- * This file is really gross, and I know it. I looked into several
- * alternate ways to deal with the mess, and they were all ugly.
- *
- * FreeBSD has a fancy hack using offsets into a struct -- that
- * saves code but it is _really_ gross. See the PO macro below.
- *
- * We could have a second column width for wide output format.
- * For example, Digital prints the real-time signals.
- */
-
-
-/*
- * Data table idea:
- *
- * table 1 maps aix to specifier
- * table 2 maps shortsort to specifier
- * table 3 maps macro to specifiers
- * table 4 maps specifier to title,datatype,offset,vendor,helptext
- * table 5 maps datatype to justification,width,widewidth,sorting,printing
- *
- * Here, "datatype" could be user,uid,u16,pages,deltaT,signals,tty,longtty...
- * It must be enough to determine printing and sorting.
- *
- * After the tables, increase width as needed to fit the header.
- *
- * Table 5 could go in a file with the output functions.
- */
-
-#include <ctype.h>
-#include <fcntl.h>
-#include <grp.h>
-#include <limits.h>
-#include <pwd.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sys/ioctl.h>
-#include <sys/resource.h>
-#include <sys/types.h>
-#include <sys/mman.h>
-#include <time.h>
-#include <unistd.h>
-#include <dlfcn.h>
-
-#include "../proc/readproc.h"
-#include "../proc/sysinfo.h"
-#include "../proc/wchan.h"
-#include "../proc/procps.h"
-#include "../proc/devname.h"
-#include "../proc/escape.h"
-#include "common.h"
-
-/* TODO:
- * Stop assuming system time is local time.
- */
-
-#define COLWID 240 /* satisfy snprintf, which is faster than sprintf */
-
-static unsigned max_rightward = 0x12345678; /* space for RIGHT stuff */
-static unsigned max_leftward = 0x12345678; /* space for LEFT stuff */
-
-
-
-static int wide_signals;  /* true if we have room */
-
-static time_t seconds_since_1970;
-static time_t time_of_boot;
-static unsigned long page_shift;
-
-
-/*************************************************************************/
-/************ Lots of sort functions, starting with the NOP **************/
-
-static int sr_nop(const proc_t* a, const proc_t* b){
-  (void)a;(void)b; /* shut up gcc */
-  return 0;
-}
-
-#define CMP_STR(NAME) \
-static int sr_ ## NAME(const proc_t* P, const proc_t* Q) { \
-    return strcmp(P->NAME, Q->NAME); \
-}
-
-#define CMP_INT(NAME) \
-static int sr_ ## NAME (const proc_t* P, const proc_t* Q) { \
-    if (P->NAME < Q->NAME) return -1; \
-    if (P->NAME > Q->NAME) return  1; \
-    return 0; \
-}
-
-/* fast versions, for values which either:
- * a. differ by no more than 0x7fffffff
- * b. only need to be grouped same w/ same
- */
-#define CMP_SMALL(NAME) \
-static int sr_ ## NAME (const proc_t* P, const proc_t* Q) { \
-    return (int)(P->NAME) - (int)(Q->NAME); \
-}
-#define CMP_SMALL2(NAME,WHAT) \
-static int sr_ ## NAME (const proc_t* P, const proc_t* Q) { \
-    return (int)(P->WHAT) - (int)(Q->WHAT); \
-}
-
-CMP_INT(rtprio)
-CMP_SMALL(sched)
-CMP_INT(cutime)
-CMP_INT(cstime)
-CMP_SMALL(priority)                                             /* nice */
-CMP_SMALL(nlwp)
-CMP_SMALL(nice)                                                 /* priority */
-CMP_INT(rss)      /* resident set size from stat file */ /* vm_rss, resident */
-CMP_INT(alarm)
-CMP_INT(size)      /* total pages */                     /* vm_size, vsize */
-CMP_INT(resident)  /* resident pages */                     /* vm_rss, rss */
-CMP_INT(share)     /* shared pages */
-CMP_INT(trs)       /* executable pages */
-CMP_INT(lrs)       /* obsolete "library" pages above 0x60000000 */
-CMP_INT(drs)       /* other pages (assumed data?) */
-CMP_INT(dt)        /* dirty pages */
-
-CMP_INT(vm_size)    /* kB VM */                             /* size, vsize */
-CMP_INT(vm_lock)    /* kB locked */
-CMP_INT(vm_rss)     /* kB rss */                          /* rss, resident */
-CMP_INT(vm_data)    /* kB "data" == data-stack */
-CMP_INT(vm_stack)   /* kB stack */
-CMP_INT(vm_exe)     /* kB "exec" == exec-lib */
-CMP_INT(vm_lib)     /* kB "libraries" */
-CMP_INT(vsize)      /* pages VM */                        /* size, vm_size */
-CMP_INT(rss_rlim)
-CMP_SMALL(flags)
-CMP_INT(min_flt)
-CMP_INT(maj_flt)
-CMP_INT(cmin_flt)
-CMP_INT(cmaj_flt)
-CMP_INT(utime)
-CMP_INT(stime)    /* Old: sort by systime. New: show start time. Uh oh. */
-CMP_INT(start_code)
-CMP_INT(end_code)
-CMP_INT(start_stack)
-CMP_INT(kstk_esp)
-CMP_INT(kstk_eip)
-CMP_INT(start_time)
-CMP_INT(wchan)
-
-/* CMP_STR(*environ) */
-/* CMP_STR(*cmdline) */
-
-CMP_STR(ruser)
-CMP_STR(euser)
-CMP_STR(suser)
-CMP_STR(fuser)
-CMP_STR(rgroup)
-CMP_STR(egroup)
-CMP_STR(sgroup)
-CMP_STR(fgroup)
-CMP_STR(cmd)
-/* CMP_STR(ttyc) */    /* FIXME -- use strncmp with 8 max */
-
-CMP_INT(ruid)
-CMP_INT(rgid)
-CMP_INT(euid)
-CMP_INT(egid)
-CMP_INT(suid)
-CMP_INT(sgid)
-CMP_INT(fuid)
-CMP_INT(fgid)
-CMP_SMALL2(procs,tgid)
-CMP_SMALL2(tasks,tid)
-CMP_SMALL(ppid)
-CMP_SMALL(pgrp)
-CMP_SMALL(session)
-CMP_INT(tty)
-CMP_SMALL(tpgid)
-
-CMP_SMALL(pcpu)
-
-CMP_SMALL(state)
-
-/* approximation to: kB of address space that could end up in swap */
-static int sr_swapable(const proc_t* P, const proc_t* Q) {
-  unsigned long p_swapable = P->vm_data + P->vm_stack;
-  unsigned long q_swapable = Q->vm_data + Q->vm_stack;
-  if (p_swapable < q_swapable) return -1;
-  if (p_swapable > q_swapable) return  1;
-  return 0;
-}
-
-
-/***************************************************************************/
-/************ Lots of format functions, starting with the NOP **************/
-
-// so popular it can't be "static"
-int pr_nop(char *restrict const outbuf, const proc_t *restrict const pp){
-  (void)pp;
-  return snprintf(outbuf, COLWID, "%c", '-');
-}
-
-
-/********* Unix 98 ************/
-
-/***
-
-Only comm and args are allowed to contain blank characters; all others are
-not. Any implementation-dependent variables will be specified in the system
-documentation along with the default header and indicating if the field
-may contain blank characters.
-
-Some headers do not have a standardized specifier!
-
-%CPU	pcpu	The % of cpu time used recently, with unspecified "recently".
-ADDR		The address of the process.
-C		Processor utilisation for scheduling.
-CMD		The command name, or everything with -f.
-COMMAND	args	Command + args. May chop as desired. May use either version.
-COMMAND	comm	argv[0]
-ELAPSED	etime	Elapsed time since the process was started. [[dd-]hh:]mm:ss
-F		Flags (octal and additive)
-GROUP	group	Effective group ID, prefer text over decimal.
-NI	nice	Decimal system scheduling priority, see nice(1).
-PGID	pgid	The decimal value of the process group ID.
-PID	pid	Decimal PID.
-PPID	ppid	Decimal PID.
-PRI		Priority. Higher numbers mean lower priority.
-RGROUP	rgroup	Real group ID, prefer text over decimal.
-RUSER	ruser	Real user ID, prefer text over decimal.
-S		The state of the process.
-STIME		Starting time of the process.
-SZ		The size in blocks of the core image of the process.
-TIME	time	Cumulative CPU time. [dd-]hh:mm:ss
-TT	tty	Name of tty in format used by who(1).
-TTY		The controlling terminal for the process.
-UID		UID, or name when -f
-USER	user	Effective user ID, prefer text over decimal.
-VSZ	vsz	Virtual memory size in decimal kB.
-WCHAN		Where waiting/sleeping or blank if running.
-
-The nice value is used to compute the priority.
-
-For some undefined ones, Digital does:
-
-F       flag    Process flags -- but in hex!
-PRI     pri     Process priority
-S       state   Symbolic process status
-TTY     tt,tty,tname,longtname  -- all do "ttyp1", "console", "??"
-UID     uid     Process user ID (effective UID)
-WCHAN   wchan   Address of event on which a
-
-For some undefined ones, Sun does:
-
-ADDR	addr	memory address of the process
-C	c	Processor utilization  for  scheduling  (obsolete).
-CMD
-F	f
-S	s	state: OSRZT
-STIME		start time, printed w/o blanks. If 24h old, months & days
-SZ		size (in pages) of the swappable process's image in main memory
-TTY
-UID	uid
-WCHAN	wchan
-
-For some undefined ones, SCO does:
-ADDR	addr	Virtual address of the process' entry in the process table.
-SZ		swappable size in kB of the virtual data and stack
-STIME	stime	hms or md time format
-***/
-
-/* Source & destination are known. Return bytes or screen characters? */
-//
-//       OldLinux   FreeBSD    HPUX
-// ' '    '    '     '  '      '  '
-// 'L'    ' \_ '     '`-'      '  '
-// '+'    ' \_ '     '|-'      '  '
-// '|'    ' |  '     '| '      '  '
-//
-static int forest_helper(char *restrict const outbuf){
-  char *p = forest_prefix;
-  char *q = outbuf;
-  int rightward=max_rightward;
-  if(!*p) return 0;
-  /* Arrrgh! somebody defined unix as 1 */
-  if(forest_type == 'u') goto unixy;
-  while(*p){
-    switch(*p){
-    case ' ': strcpy(q, "    ");  break;
-    case 'L': strcpy(q, " \\_ "); break;
-    case '+': strcpy(q, " \\_ "); break;
-    case '|': strcpy(q, " |  ");  break;
-    case '\0': return q-outbuf;    /* redundant & not used */
-    }
-    if (rightward-4 < 0) {
-      *(q+rightward)='\0';
-      return max_rightward;
-    }
-    q += 4;
-    rightward -= 4;
-    p++;
-  }
-  return q-outbuf;   /* gcc likes this here */
-unixy:
-  while(*p){
-    switch(*p){
-    case ' ': strcpy(q, "  "); break;
-    case 'L': strcpy(q, "  "); break;
-    case '+': strcpy(q, "  "); break;
-    case '|': strcpy(q, "  "); break;
-    case '\0': return q-outbuf;    /* redundant & not used */
-    }
-    if (rightward-2 < 0) {
-      *(q+rightward)='\0';
-      return max_rightward;
-    }
-    q += 2;
-    rightward -= 2;
-    p++;
-  }
-  return q-outbuf;   /* gcc likes this here */
-}
-
-
-/* XPG4-UNIX, according to Digital:
-The "args" and "command" specifiers show what was passed to the command.
-Modifications to the arguments are not shown.
-*/
-
-/*
- * pp->cmd       short accounting name (comm & ucomm)
- * pp->cmdline   long name with args (args & command)
- * pp->environ   environment
- */
-
-// FIXME: some of these may hit the guard page in forest mode
-
-/*
- * "args", "cmd", "command" are all the same:  long  unless  c
- * "comm", "ucmd", "ucomm"  are all the same:  short unless -f
- * ( determinations are made in display.c, we mostly deal with results ) */
-static int pr_args(char *restrict const outbuf, const proc_t *restrict const pp){
-  char *endp = outbuf;
-  int rightward = max_rightward;
-  int fh = forest_helper(outbuf);
-
-  endp += fh;
-  rightward -= fh;
-
-  if(pp->cmdline && !bsd_c_option)
-    endp += escaped_copy(endp, *pp->cmdline, OUTBUF_SIZE, &rightward);
-  else
-    endp += escape_command(endp, pp, OUTBUF_SIZE, &rightward, ESC_DEFUNCT);
-
-  if(bsd_e_option && rightward>1) {
-    if(pp->environ && *pp->environ)
-      endp += escape_strlist(endp, pp->environ, OUTBUF_SIZE, &rightward);
-  }
-  return max_rightward-rightward;
-}
-
-/*
- * "args", "cmd", "command" are all the same:  long  unless  c
- * "comm", "ucmd", "ucomm"  are all the same:  short unless -f
- * ( determinations are made in display.c, we mostly deal with results ) */
-static int pr_comm(char *restrict const outbuf, const proc_t *restrict const pp){
-  char *endp = outbuf;
-  int rightward = max_rightward;
-  int fh = forest_helper(outbuf);
-
-  endp += fh;
-  rightward -= fh;
-
-  if(pp->cmdline && unix_f_option)
-    endp += escaped_copy(endp, *pp->cmdline, OUTBUF_SIZE, &rightward);
-  else
-    endp += escape_command(endp, pp, OUTBUF_SIZE, &rightward, ESC_DEFUNCT);
-
-  if(bsd_e_option && rightward>1) {
-    if(pp->environ && *pp->environ)
-      endp += escape_strlist(endp, pp->environ, OUTBUF_SIZE, &rightward);
-  }
-  return max_rightward-rightward;
-}
-
-static int pr_cgroup(char *restrict const outbuf,const proc_t *restrict const pp) {
-  int rightward = max_rightward;
-
-  if(pp->cgroup) {
-    escaped_copy(outbuf, *pp->cgroup, OUTBUF_SIZE, &rightward);
-    return max_rightward-rightward;
-  }
-  else
-    return pr_nop(outbuf,pp);
-}
-
-/* Non-standard, from SunOS 5 */
-static int pr_fname(char *restrict const outbuf, const proc_t *restrict const pp){
-  char *endp = outbuf;
-  int rightward = max_rightward;
-  int fh = forest_helper(outbuf);
-
-  endp += fh;
-  rightward -= fh;
-
-  if (rightward>8)  /* 8=default, but forest maybe feeds more */
-    rightward = 8;
-
-  endp += escape_str(endp, pp->cmd, OUTBUF_SIZE, &rightward);
-  //return endp - outbuf;
-  return max_rightward-rightward;
-}
-
-/* elapsed wall clock time, [[dd-]hh:]mm:ss format (not same as "time") */
-static int pr_etime(char *restrict const outbuf, const proc_t *restrict const pp){
-  unsigned long t;
-  unsigned dd,hh,mm,ss;
-  char *cp = outbuf;
-  t = seconds_since_boot - (unsigned long)(pp->start_time / Hertz);
-  ss = t%60;
-  t /= 60;
-  mm = t%60;
-  t /= 60;
-  hh = t%24;
-  t /= 24;
-  dd = t;
-  cp +=(     dd      ?  snprintf(cp, COLWID, "%u-", dd)           :  0 );
-  cp +=( (dd || hh)  ?  snprintf(cp, COLWID, "%02u:", hh)         :  0 );
-  cp +=                 snprintf(cp, COLWID, "%02u:%02u", mm, ss)       ;
-  return (int)(cp-outbuf);
-}
-
-/* elapsed wall clock time in seconds */
-static int pr_etimes(char *restrict const outbuf, const proc_t *restrict const pp){
-  unsigned t = seconds_since_boot - (unsigned long)(pp->start_time / Hertz);
-  return snprintf(outbuf, COLWID, "%u", t);
-}
-
-/* "Processor utilisation for scheduling."  --- we use %cpu w/o fraction */
-static int pr_c(char *restrict const outbuf, const proc_t *restrict const pp){
-  unsigned long long total_time;   /* jiffies used by this process */
-  unsigned pcpu = 0;               /* scaled %cpu, 99 means 99% */
-  unsigned long long seconds;      /* seconds of process life */
-  total_time = pp->utime + pp->stime;
-  if(include_dead_children) total_time += (pp->cutime + pp->cstime);
-  seconds = seconds_since_boot - pp->start_time / Hertz;
-  if(seconds) pcpu = (total_time * 100ULL / Hertz) / seconds;
-  if (pcpu > 99U) pcpu = 99U;
-  return snprintf(outbuf, COLWID, "%2u", pcpu);
-}
-/* normal %CPU in ##.# format. */
-static int pr_pcpu(char *restrict const outbuf, const proc_t *restrict const pp){
-  unsigned long long total_time;   /* jiffies used by this process */
-  unsigned pcpu = 0;               /* scaled %cpu, 999 means 99.9% */
-  unsigned long long seconds;      /* seconds of process life */
-  total_time = pp->utime + pp->stime;
-  if(include_dead_children) total_time += (pp->cutime + pp->cstime);
-  seconds = seconds_since_boot - pp->start_time / Hertz;
-  if(seconds) pcpu = (total_time * 1000ULL / Hertz) / seconds;
-  if (pcpu > 999U)
-    return snprintf(outbuf, COLWID, "%u", pcpu/10U);
-  return snprintf(outbuf, COLWID, "%u.%u", pcpu/10U, pcpu%10U);
-}
-/* this is a "per-mill" format, like %cpu with no decimal point */
-static int pr_cp(char *restrict const outbuf, const proc_t *restrict const pp){
-  unsigned long long total_time;   /* jiffies used by this process */
-  unsigned pcpu = 0;               /* scaled %cpu, 999 means 99.9% */
-  unsigned long long seconds;      /* seconds of process life */
-  total_time = pp->utime + pp->stime;
-  if(include_dead_children) total_time += (pp->cutime + pp->cstime);
-  seconds = seconds_since_boot - pp->start_time / Hertz ;
-  if(seconds) pcpu = (total_time * 1000ULL / Hertz) / seconds;
-  if (pcpu > 999U) pcpu = 999U;
-  return snprintf(outbuf, COLWID, "%3u", pcpu);
-}
-
-static int pr_pgid(char *restrict const outbuf, const proc_t *restrict const pp){
-  return snprintf(outbuf, COLWID, "%u", pp->pgrp);
-}
-static int pr_ppid(char *restrict const outbuf, const proc_t *restrict const pp){
-  return snprintf(outbuf, COLWID, "%u", pp->ppid);
-}
-
-
-/* cumulative CPU time, [dd-]hh:mm:ss format (not same as "etime") */
-static int pr_time(char *restrict const outbuf, const proc_t *restrict const pp){
-  unsigned long t;
-  unsigned dd,hh,mm,ss;
-  int c;
-  t = (pp->utime + pp->stime) / Hertz;
-  ss = t%60;
-  t /= 60;
-  mm = t%60;
-  t /= 60;
-  hh = t%24;
-  t /= 24;
-  dd = t;
-  c  =( dd ? snprintf(outbuf, COLWID, "%u-", dd) : 0              );
-  c +=( snprintf(outbuf+c, COLWID, "%02u:%02u:%02u", hh, mm, ss)    );
-  return c;
-}
-
-/* HP-UX puts this (I forget, vsz or vsize?) in kB and uses "sz" for pages.
- * Unix98 requires "vsz" to be kB.
- * Tru64 does both vsize and vsz like "1.23M"
- *
- * Our pp->vm_size is kB and our pp->vsize is pages.
- *
- * TODO: add flag for "1.23M" behavior, on this and other columns.
- */
-static int pr_vsz(char *restrict const outbuf, const proc_t *restrict const pp){
-  return snprintf(outbuf, COLWID, "%lu", pp->vm_size);
-}
-
-//////////////////////////////////////////////////////////////////////////////////////
-
-// "PRI" is created by "opri", or by "pri" when -c is used.
-//
-// Unix98 only specifies that a high "PRI" is low priority.
-// Sun and SCO add the -c behavior. Sun defines "pri" and "opri".
-// Linux may use "priority" for historical purposes.
-//
-// According to the kernel's fs/proc/array.c and kernel/sched.c source,
-// the kernel reports it in /proc via this:
-//        p->prio - MAX_RT_PRIO
-// such that "RT tasks are offset by -200. Normal tasks are centered
-// around 0, value goes from -16 to +15" but who knows if that is
-// before or after the conversion...
-//
-// <linux/sched.h> says:
-// MAX_RT_PRIO is currently 100.       (so we see 0 in /proc)
-// RT tasks have a p->prio of 0 to 99. (so we see -100 to -1)
-// non-RT tasks are from 100 to 139.   (so we see 0 to 39)
-// Lower values have higher priority, as in the UNIX standard.
-//
-// In any case, pp->priority+100 should get us back to what the kernel
-// has for p->prio.
-//
-// Test results with the "yes" program on a 2.6.x kernel:
-//
-// # ps -C19,_20 -o pri,opri,intpri,priority,ni,pcpu,pid,comm
-// PRI PRI PRI PRI  NI %CPU  PID COMMAND
-//   0  99  99  39  19 10.6 8686 19
-//  34  65  65   5 -20 94.7 8687 _20
-//
-// Grrr. So the UNIX standard "PRI" must NOT be from "pri".
-// Either of the others will do. We use "opri" for this.
-// (and use "pri" when the "-c" option is used)
-// Probably we should have Linux-specific "pri_for_l" and "pri_for_lc"
-//
-// sched_get_priority_min.2 says the Linux static priority is
-// 1..99 for RT and 0 for other... maybe 100 is kernel-only?
-//
-// A nice range would be -99..0 for RT and 1..40 for normal,
-// which is pp->priority+1. (3-digit max, positive is normal,
-// negative or 0 is RT, and meets the standard for PRI)
-//
-
-// legal as UNIX "PRI"
-// "priority"         (was -20..20, now -100..39)
-static int pr_priority(char *restrict const outbuf, const proc_t *restrict const pp){    /* -20..20 */
-    return snprintf(outbuf, COLWID, "%ld", pp->priority);
-}
-
-// legal as UNIX "PRI"
-// "intpri" and "opri" (was 39..79, now  -40..99)
-static int pr_opri(char *restrict const outbuf, const proc_t *restrict const pp){        /* 39..79 */
-    return snprintf(outbuf, COLWID, "%ld", 60 + pp->priority);
-}
-
-// legal as UNIX "PRI"
-// "pri_foo"   --  match up w/ nice values of sleeping processes (-120..19)
-static int pr_pri_foo(char *restrict const outbuf, const proc_t *restrict const pp){
-    return snprintf(outbuf, COLWID, "%ld", pp->priority - 20);
-}
-
-// legal as UNIX "PRI"
-// "pri_bar"   --  makes RT pri show as negative       (-99..40)
-static int pr_pri_bar(char *restrict const outbuf, const proc_t *restrict const pp){
-    return snprintf(outbuf, COLWID, "%ld", pp->priority + 1);
-}
-
-// legal as UNIX "PRI"
-// "pri_baz"   --  the kernel's ->prio value, as of Linux 2.6.8     (1..140)
-static int pr_pri_baz(char *restrict const outbuf, const proc_t *restrict const pp){
-    return snprintf(outbuf, COLWID, "%ld", pp->priority + 100);
-}
-
-
-// not legal as UNIX "PRI"
-// "pri"               (was 20..60, now    0..139)
-static int pr_pri(char *restrict const outbuf, const proc_t *restrict const pp){         /* 20..60 */
-    return snprintf(outbuf, COLWID, "%ld", 39 - pp->priority);
-}
-
-// not legal as UNIX "PRI"
-// "pri_api"   --  match up w/ RT API    (-40..99)
-static int pr_pri_api(char *restrict const outbuf, const proc_t *restrict const pp){
-    return snprintf(outbuf, COLWID, "%ld", -1 - pp->priority);
-}
-
-static int pr_nice(char *restrict const outbuf, const proc_t *restrict const pp){
-  if(pp->sched!=0 && pp->sched!=-1) return snprintf(outbuf, COLWID, "-");
-  return snprintf(outbuf, COLWID, "%ld", pp->nice);
-}
-
-// HP-UX   "cls": RT RR RR2 ???? HPUX FIFO KERN
-// Solaris "class": SYS TS FX IA RT FSS (FIFO is RR w/ Inf quant)
-//                  FIFO+RR share RT; FIFO has Inf quant
-//                  IA=interactive; FX=fixed; TS=timeshare; SYS=system
-//                  FSS=fairshare; INTS=interrupts
-// Tru64   "policy": FF RR TS
-// IRIX    "class": RT TS B BC WL GN
-//                  RT=real-time; TS=time-share; B=batch; BC=batch-critical
-//                  WL=weightless; GN=gang-scheduled
-//                  see miser(1) for this; PRI has some letter codes too
-static int pr_class(char *restrict const outbuf, const proc_t *restrict const pp){
-  switch(pp->sched){
-  case -1: return snprintf(outbuf, COLWID, "-");   // not reported
-  case  0: return snprintf(outbuf, COLWID, "TS");  // SCHED_OTHER SCHED_NORMAL
-  case  1: return snprintf(outbuf, COLWID, "FF");  // SCHED_FIFO
-  case  2: return snprintf(outbuf, COLWID, "RR");  // SCHED_RR
-  case  3: return snprintf(outbuf, COLWID, "B");   // SCHED_BATCH
-  case  4: return snprintf(outbuf, COLWID, "ISO"); // reserved for SCHED_ISO (Con Kolivas)
-  case  5: return snprintf(outbuf, COLWID, "IDL"); // SCHED_IDLE
-  case  6: return snprintf(outbuf, COLWID, "#6");  //
-  case  7: return snprintf(outbuf, COLWID, "#7");  //
-  case  8: return snprintf(outbuf, COLWID, "#8");  //
-  case  9: return snprintf(outbuf, COLWID, "#9");  //
-  default: return snprintf(outbuf, COLWID, "?");   // unknown value
-  }
-}
-// Based on "type", FreeBSD would do:
-//    REALTIME  "real:%u", prio
-//    NORMAL    "normal"
-//    IDLE      "idle:%u", prio
-//    default   "%u:%u", type, prio
-// We just print the priority, and have other keywords for type.
-static int pr_rtprio(char *restrict const outbuf, const proc_t *restrict const pp){
-  if(pp->sched==0 || pp->sched==-1) return snprintf(outbuf, COLWID, "-");
-  return snprintf(outbuf, COLWID, "%ld", pp->rtprio);
-}
-static int pr_sched(char *restrict const outbuf, const proc_t *restrict const pp){
-  if(pp->sched==-1) return snprintf(outbuf, COLWID, "-");
-  return snprintf(outbuf, COLWID, "%ld", pp->sched);
-}
-
-////////////////////////////////////////////////////////////////////////////////
-
-static int pr_wchan(char *restrict const outbuf, const proc_t *restrict const pp){
-/*
- * Unix98 says "blank if running" and also "no blanks"! :-(
- * Unix98 also says to use '-' if something is meaningless.
- * Digital uses both '*' and '-', with undocumented differences.
- * (the '*' for -1 (rare) and the '-' for 0)
- * Sun claims to use a blank AND use '-', in the same man page.
- * Perhaps "blank" should mean '-'.
- *
- * AIX uses '-' for running processes, the location when there is
- * only one thread waiting in the kernel, and '*' when there is
- * more than one thread waiting in the kernel.
- *
- * The output should be truncated to maximal columns width -- overflow
- * is not supported for the "wchan".
- */
-  const char *w;
-  size_t len;
-  if(!(pp->wchan & 0xffffff)) return memcpy(outbuf,"-",2),1;
-  if(wchan_is_number) return snprintf(outbuf, COLWID, "%x", (unsigned)(pp->wchan) & 0xffffffu);
-  w = lookup_wchan(pp->wchan, pp->XXXID);
-  len = strlen(w);
-  if(len>max_rightward) len=max_rightward;
-  memcpy(outbuf, w, len);
-  outbuf[len] = '\0';
-  return len;
-}
-
-static int pr_wname(char *restrict const outbuf, const proc_t *restrict const pp){
-/* SGI's IRIX always uses a number for "wchan", so "wname" is provided too.
- *
- * We use '-' for running processes, the location when there is
- * only one thread waiting in the kernel, and '*' when there is
- * more than one thread waiting in the kernel.
- *
- * The output should be truncated to maximal columns width -- overflow
- * is not supported for the "wchan".
- */
-  const char *w;
-  size_t len;
-  if(!(pp->wchan & 0xffffff)) return memcpy(outbuf,"-",2),1;
-  w = lookup_wchan(pp->wchan, pp->XXXID);
-  len = strlen(w);
-  if(len>max_rightward) len=max_rightward;
-  memcpy(outbuf, w, len);
-  outbuf[len] = '\0';
-  return len;
-}
-
-static int pr_nwchan(char *restrict const outbuf, const proc_t *restrict const pp){
-  if(!(pp->wchan & 0xffffff)) return memcpy(outbuf,"-",2),1;
-  return snprintf(outbuf, COLWID, "%x", (unsigned)(pp->wchan) & 0xffffffu);
-}
-
-/* Terrible trunctuation, like BSD crap uses: I999 J999 K999 */
-/* FIXME: disambiguate /dev/tty69 and /dev/pts/69. */
-static int pr_tty4(char *restrict const outbuf, const proc_t *restrict const pp){
-/* snprintf(outbuf, COLWID, "%02x:%02x", pp->tty>>8, pp->tty&0xff); */
-  return dev_to_tty(outbuf, 4, pp->tty, pp->XXXID, ABBREV_DEV|ABBREV_TTY|ABBREV_PTS);
-}
-
-/* Unix98: format is unspecified, but must match that used by who(1). */
-static int pr_tty8(char *restrict const outbuf, const proc_t *restrict const pp){
-/* snprintf(outbuf, COLWID, "%02x:%02x", pp->tty>>8, pp->tty&0xff); */
-  return dev_to_tty(outbuf, COLWID, pp->tty, pp->XXXID, ABBREV_DEV);
-}
-
-#if 0
-/* This BSD state display may contain spaces, which is illegal. */
-static int pr_oldstate(char *restrict const outbuf, const proc_t *restrict const pp){
-    return snprintf(outbuf, COLWID, "%s", status(pp));
-}
-#endif
-
-// This state display is Unix98 compliant and has lots of info like BSD.
-static int pr_stat(char *restrict const outbuf, const proc_t *restrict const pp){
-    int end = 0;
-    outbuf[end++] = pp->state;
-//  if(pp->rss==0 && pp->state!='Z')  outbuf[end++] = 'W'; // useless "swapped out"
-    if(pp->nice < 0)                  outbuf[end++] = '<';
-    if(pp->nice > 0)                  outbuf[end++] = 'N';
-// In this order, NetBSD would add:
-//     traced   'X'
-//     systrace 'x'
-//     exiting  'E' (not printed for zombies)
-//     vforked  'V'
-//     system   'K' (and do not print 'L' too)
-    if(pp->vm_lock)                   outbuf[end++] = 'L';
-    if(pp->session == pp->tgid)       outbuf[end++] = 's'; // session leader
-    if(pp->nlwp > 1)                  outbuf[end++] = 'l'; // multi-threaded
-    if(pp->pgrp == pp->tpgid)         outbuf[end++] = '+'; // in foreground process group
-    outbuf[end] = '\0';
-    return end;
-}
-
-/* This minimal state display is Unix98 compliant, like SCO and SunOS 5 */
-static int pr_s(char *restrict const outbuf, const proc_t *restrict const pp){
-    outbuf[0] = pp->state;
-    outbuf[1] = '\0';
-    return 1;
-}
-
-static int pr_flag(char *restrict const outbuf, const proc_t *restrict const pp){
-    /* Unix98 requires octal flags */
-    /* this user-hostile and volatile junk gets 1 character */
-    return snprintf(outbuf, COLWID, "%o", (unsigned)(pp->flags>>6U)&0x7U);
-}
-
-// plus these: euid,ruid,egroup,rgroup (elsewhere in this file)
-
-/*********** non-standard ***********/
-
-/*** BSD
-sess	session pointer
-(SCO has:Process session leader ID as a decimal value. (SESSION))
-jobc	job control count
-cpu	short-term cpu usage factor (for scheduling)
-sl	sleep time (in seconds; 127 = infinity)
-re	core residency time (in seconds; 127 = infinity)
-pagein	pageins (same as majflt)
-lim	soft memory limit
-tsiz	text size (in Kbytes)
-***/
-
-static int pr_stackp(char *restrict const outbuf, const proc_t *restrict const pp){
-    return snprintf(outbuf, COLWID, "%08x", (unsigned)(pp->start_stack));
-}
-
-static int pr_esp(char *restrict const outbuf, const proc_t *restrict const pp){
-    return snprintf(outbuf, COLWID, "%08x", (unsigned)(pp->kstk_esp));
-}
-
-static int pr_eip(char *restrict const outbuf, const proc_t *restrict const pp){
-    return snprintf(outbuf, COLWID, "%08x", (unsigned)(pp->kstk_eip));
-}
-
-/* This function helps print old-style time formats */
-static int old_time_helper(char *dst, unsigned long long t, unsigned long long rel) {
-  if(!t)            return snprintf(dst, COLWID, "    -");
-  if(t == ~0ULL)    return snprintf(dst, COLWID, "   xx");
-  if((long long)(t-=rel) < 0)  t=0ULL;
-  if(t>9999ULL)     return snprintf(dst, COLWID, "%5Lu", t/100ULL);
-  else              return snprintf(dst, COLWID, "%2u.%02u", (unsigned)t/100U, (unsigned)t%100U);
-}
-
-static int pr_bsdtime(char *restrict const outbuf, const proc_t *restrict const pp){
-    unsigned long long t;
-    unsigned u;
-    t = pp->utime + pp->stime;
-    if(include_dead_children) t += (pp->cutime + pp->cstime);
-    u = t / Hertz;
-    return snprintf(outbuf, COLWID, "%3u:%02u", u/60U, u%60U);
-}
-
-static int pr_bsdstart(char *restrict const outbuf, const proc_t *restrict const pp){
-  time_t start;
-  time_t seconds_ago;
-  start = getbtime() + pp->start_time / Hertz;
-  seconds_ago = seconds_since_1970 - start;
-  if(seconds_ago < 0) seconds_ago=0;
-  if(seconds_ago > 3600*24)  strcpy(outbuf, ctime(&start)+4);
-  else                       strcpy(outbuf, ctime(&start)+10);
-  outbuf[6] = '\0';
-  return 6;
-}
-
-static int pr_alarm(char *restrict const outbuf, const proc_t *restrict const pp){
-    return old_time_helper(outbuf, pp->alarm, 0ULL);
-}
-
-/* HP-UX puts this in pages and uses "vsz" for kB */
-static int pr_sz(char *restrict const outbuf, const proc_t *restrict const pp){
-  return snprintf(outbuf, COLWID, "%lu", (pp->vm_size)/(page_size/1024));
-}
-
-
-/*
- * FIXME: trs,drs,tsiz,dsiz,m_trs,m_drs,vm_exe,vm_data,trss
- * I suspect some/all of those are broken. They seem to have been
- * inherited by Linux and AIX from early BSD systems. FreeBSD only
- * retains tsiz. The prefixed versions come from Debian.
- * Sun and Digital have none of this crap. The code here comes
- * from an old Linux ps, and might not be correct for ELF executables.
- *
- * AIX            TRS    size of resident-set (real memory) of text
- * AIX            TSIZ   size of text (shared-program) image
- * FreeBSD        tsiz   text size (in Kbytes)
- * 4.3BSD NET/2   trss   text resident set size (in Kbytes)
- * 4.3BSD NET/2   tsiz   text size (in Kbytes)
- */
-
-/* kB data size. See drs, tsiz & trs. */
-static int pr_dsiz(char *restrict const outbuf, const proc_t *restrict const pp){
-    long dsiz = 0;
-    if(pp->vsize) dsiz += (pp->vsize - pp->end_code + pp->start_code) >> 10;
-    return snprintf(outbuf, COLWID, "%ld", dsiz);
-}
-
-/* kB text (code) size. See trs, dsiz & drs. */
-static int pr_tsiz(char *restrict const outbuf, const proc_t *restrict const pp){
-    long tsiz = 0;
-    if(pp->vsize) tsiz += (pp->end_code - pp->start_code) >> 10;
-    return snprintf(outbuf, COLWID, "%ld", tsiz);
-}
-
-/* kB _resident_ data size. See dsiz, tsiz & trs. */
-static int pr_drs(char *restrict const outbuf, const proc_t *restrict const pp){
-    long drs = 0;
-    if(pp->vsize) drs += (pp->vsize - pp->end_code + pp->start_code) >> 10;
-    return snprintf(outbuf, COLWID, "%ld", drs);
-}
-
-/* kB text _resident_ (code) size. See tsiz, dsiz & drs. */
-static int pr_trs(char *restrict const outbuf, const proc_t *restrict const pp){
-    long trs = 0;
-    if(pp->vsize) trs += (pp->end_code - pp->start_code) >> 10;
-    return snprintf(outbuf, COLWID, "%ld", trs);
-}
-
-/* approximation to: kB of address space that could end up in swap */
-static int pr_swapable(char *restrict const outbuf, const proc_t *restrict const pp){
-  return snprintf(outbuf, COLWID, "%ld", pp->vm_data + pp->vm_stack);
-}
-
-/* nasty old Debian thing */
-static int pr_size(char *restrict const outbuf, const proc_t *restrict const pp){
-  return snprintf(outbuf, COLWID, "%ld", pp->size);
-}
-
-
-static int pr_minflt(char *restrict const outbuf, const proc_t *restrict const pp){
-    long flt = pp->min_flt;
-    if(include_dead_children) flt += pp->cmin_flt;
-    return snprintf(outbuf, COLWID, "%ld", flt);
-}
-
-static int pr_majflt(char *restrict const outbuf, const proc_t *restrict const pp){
-    long flt = pp->maj_flt;
-    if(include_dead_children) flt += pp->cmaj_flt;
-    return snprintf(outbuf, COLWID, "%ld", flt);
-}
-
-static int pr_lim(char *restrict const outbuf, const proc_t *restrict const pp){
-    if(pp->rss_rlim == RLIM_INFINITY){
-      outbuf[0] = 'x';
-      outbuf[1] = 'x';
-      outbuf[2] = '\0';
-      return 2;
-    }
-    return snprintf(outbuf, COLWID, "%5ld", pp->rss_rlim >> 10);
-}
-
-/* should print leading tilde ('~') if process is bound to the CPU */
-static int pr_psr(char *restrict const outbuf, const proc_t *restrict const pp){
-  return snprintf(outbuf, COLWID, "%d", pp->processor);
-}
-
-static int pr_rss(char *restrict const outbuf, const proc_t *restrict const pp){
-  return snprintf(outbuf, COLWID, "%lu", pp->vm_rss);
-}
-
-/* pp->vm_rss * 1000 would overflow on 32-bit systems with 64 GB memory */
-static int pr_pmem(char *restrict const outbuf, const proc_t *restrict const pp){
-  unsigned long pmem = 0;
-  pmem = pp->vm_rss * 1000ULL / kb_main_total;
-  if (pmem > 999) pmem = 999;
-  return snprintf(outbuf, COLWID, "%2u.%u", (unsigned)(pmem/10), (unsigned)(pmem%10));
-}
-
-static int pr_lstart(char *restrict const outbuf, const proc_t *restrict const pp){
-  time_t t;
-  t = getbtime() + pp->start_time / Hertz;
-  return snprintf(outbuf, COLWID, "%24.24s", ctime(&t));
-}
-
-/* Unix98 specifies a STIME header for a column that shows the start
- * time of the process, but does not specify a format or format specifier.
- * From the general Unix98 rules, we know there must not be any spaces.
- * Most systems violate that rule, though the Solaris documentation
- * claims to print the column without spaces. (NOT!)
- *
- * So this isn't broken, but could be renamed to u98_std_stime,
- * as long as it still shows as STIME when using the -f option.
- */
-static int pr_stime(char *restrict const outbuf, const proc_t *restrict const pp){
-  struct tm *proc_time;
-  struct tm *our_time;
-  time_t t;
-  const char *fmt;
-  int tm_year;
-  int tm_yday;
-  our_time = localtime(&seconds_since_1970);   /* not reentrant */
-  tm_year = our_time->tm_year;
-  tm_yday = our_time->tm_yday;
-  t = getbtime() + pp->start_time / Hertz;
-  proc_time = localtime(&t); /* not reentrant, this corrupts our_time */
-  fmt = "%H:%M";                                   /* 03:02 23:59 */
-  if(tm_yday != proc_time->tm_yday) fmt = "%b%d";  /* Jun06 Aug27 */
-  if(tm_year != proc_time->tm_year) fmt = "%Y";    /* 1991 2001 */
-  return strftime(outbuf, 42, fmt, proc_time);
-}
-
-static int pr_start(char *restrict const outbuf, const proc_t *restrict const pp){
-  time_t t;
-  char *str;
-  t = getbtime() + pp->start_time / Hertz;
-  str = ctime(&t);
-  if(str[8]==' ')  str[8]='0';
-  if(str[11]==' ') str[11]='0';
-  if((unsigned long)t+60*60*24 > (unsigned long)seconds_since_1970)
-    return snprintf(outbuf, COLWID, "%8.8s", str+11);
-  return snprintf(outbuf, COLWID, "  %6.6s", str+4);
-}
-
-
-#ifdef SIGNAL_STRING
-static int help_pr_sig(char *restrict const outbuf, const char *restrict const sig){
-  long len = 0;
-  len = strlen(sig);
-  if(wide_signals){
-    if(len>8) return snprintf(outbuf, COLWID, "%s", sig);
-    return snprintf(outbuf, COLWID, "00000000%s", sig);
-  }
-  if(len-strspn(sig,"0") > 8)
-    return snprintf(outbuf, COLWID, "<%s", sig+len-8);
-  return snprintf(outbuf, COLWID,  "%s", sig+len-8);
-}
-#else
-static int help_pr_sig(unsigned long long sig){
-  if(wide_signals) return snprintf(outbuf, COLWID, "%016Lx", sig);
-  if(sig>>32)      return snprintf(outbuf, COLWID, "<%08Lx", sig&0xffffffffLL);
-  return                  snprintf(outbuf, COLWID,  "%08Lx", sig&0xffffffffLL);
-}
-#endif
-
-// This one is always thread-specific pending. (from Dragonfly BSD)
-static int pr_tsig(char *restrict const outbuf, const proc_t *restrict const pp){
-  return help_pr_sig(outbuf, pp->_sigpnd);
-}
-// This one is (wrongly?) thread-specific when printing thread lines,
-// but process-pending otherwise.
-static int pr_sig(char *restrict const outbuf, const proc_t *restrict const pp){
-  return help_pr_sig(outbuf, pp->signal);
-}
-static int pr_sigmask(char *restrict const outbuf, const proc_t *restrict const pp){
-  return help_pr_sig(outbuf, pp->blocked);
-}
-static int pr_sigignore(char *restrict const outbuf, const proc_t *restrict const pp){
-  return help_pr_sig(outbuf, pp->sigignore);
-}
-static int pr_sigcatch(char *restrict const outbuf, const proc_t *restrict const pp){
-  return help_pr_sig(outbuf, pp->sigcatch);
-}
-
-
-////////////////////////////////////////////////////////////////////////////////
-
-/*
- * internal terms:  ruid  euid  suid  fuid
- * kernel vars:      uid  euid  suid fsuid
- * command args:    ruid   uid svuid   n/a
- */
-
-static int pr_egid(char *restrict const outbuf, const proc_t *restrict const pp){
-  return snprintf(outbuf, COLWID, "%d", pp->egid);
-}
-static int pr_rgid(char *restrict const outbuf, const proc_t *restrict const pp){
-  return snprintf(outbuf, COLWID, "%d", pp->rgid);
-}
-static int pr_sgid(char *restrict const outbuf, const proc_t *restrict const pp){
-  return snprintf(outbuf, COLWID, "%d", pp->sgid);
-}
-static int pr_fgid(char *restrict const outbuf, const proc_t *restrict const pp){
-  return snprintf(outbuf, COLWID, "%d", pp->fgid);
-}
-
-static int pr_euid(char *restrict const outbuf, const proc_t *restrict const pp){
-  return snprintf(outbuf, COLWID, "%d", pp->euid);
-}
-static int pr_ruid(char *restrict const outbuf, const proc_t *restrict const pp){
-  return snprintf(outbuf, COLWID, "%d", pp->ruid);
-}
-static int pr_suid(char *restrict const outbuf, const proc_t *restrict const pp){
-  return snprintf(outbuf, COLWID, "%d", pp->suid);
-}
-static int pr_fuid(char *restrict const outbuf, const proc_t *restrict const pp){
-  return snprintf(outbuf, COLWID, "%d", pp->fuid);
-}
-
-// The Open Group Base Specifications Issue 6 (IEEE Std 1003.1, 2004 Edition)
-// requires that user and group names print as decimal numbers if there is
-// not enough room in the column, so tough luck if you don't like it.
-//
-// The UNIX and POSIX way to change column width is to rename it:
-//      ps -o pid,user=CumbersomeUserNames -o comm
-// The easy way is to directly specify the desired width:
-//      ps -o pid,user:19,comm
-//
-static int do_pr_name(char *restrict const outbuf, const char *restrict const name, unsigned u){
-  if(!user_is_number){
-    int rightward = OUTBUF_SIZE;	/* max cells */
-    int len;				/* real cells */
-
-    escape_str(outbuf, name, OUTBUF_SIZE, &rightward);
-    len = OUTBUF_SIZE-rightward;
-
-    if(len <= (int)max_rightward)
-      return len;  /* returns number of cells */
-  }
-  return snprintf(outbuf, COLWID, "%u", u);
-}
-
-static int pr_ruser(char *restrict const outbuf, const proc_t *restrict const pp){
-  return do_pr_name(outbuf, pp->ruser, pp->ruid);
-}
-static int pr_euser(char *restrict const outbuf, const proc_t *restrict const pp){
-  return do_pr_name(outbuf, pp->euser, pp->euid);
-}
-static int pr_fuser(char *restrict const outbuf, const proc_t *restrict const pp){
-  return do_pr_name(outbuf, pp->fuser, pp->fuid);
-}
-static int pr_suser(char *restrict const outbuf, const proc_t *restrict const pp){
-  return do_pr_name(outbuf, pp->suser, pp->suid);
-}
-
-static int pr_egroup(char *restrict const outbuf, const proc_t *restrict const pp){
-  return do_pr_name(outbuf, pp->egroup, pp->egid);
-}
-static int pr_rgroup(char *restrict const outbuf, const proc_t *restrict const pp){
-  return do_pr_name(outbuf, pp->rgroup, pp->rgid);
-}
-static int pr_fgroup(char *restrict const outbuf, const proc_t *restrict const pp){
-  return do_pr_name(outbuf, pp->fgroup, pp->fgid);
-}
-static int pr_sgroup(char *restrict const outbuf, const proc_t *restrict const pp){
-  return do_pr_name(outbuf, pp->sgroup, pp->sgid);
-}
-
-//////////////////////////////////////////////////////////////////////////////////
-
-// PID pid, TGID tgid
-static int pr_procs(char *restrict const outbuf, const proc_t *restrict const pp){
-  return snprintf(outbuf, COLWID, "%u", pp->tgid);
-}
-// LWP lwp, SPID spid, TID tid
-static int pr_tasks(char *restrict const outbuf, const proc_t *restrict const pp){
-  return snprintf(outbuf, COLWID, "%u", pp->tid);
-}
-// thcount THCNT
-static int pr_nlwp(char *restrict const outbuf, const proc_t *restrict const pp){
-    return snprintf(outbuf, COLWID, "%d", pp->nlwp);
-}
-
-static int pr_sess(char *restrict const outbuf, const proc_t *restrict const pp){
-  return snprintf(outbuf, COLWID, "%u", pp->session);
-}
-
-static int pr_supgid(char *restrict const outbuf, const proc_t *restrict const pp){
-  int rightward = max_rightward;
-  escaped_copy(outbuf, pp->supgid ? pp->supgid : "n/a", OUTBUF_SIZE, &rightward);
-  return max_rightward-rightward;
-}
-
-static int pr_supgrp(char *restrict const outbuf, const proc_t *restrict const pp){
-  int rightward = max_rightward;
-  escaped_copy(outbuf, pp->supgrp ? pp->supgrp : "n/a", OUTBUF_SIZE, &rightward);
-  return max_rightward-rightward;
-}
-
-static int pr_tpgid(char *restrict const outbuf, const proc_t *restrict const pp){
-  return snprintf(outbuf, COLWID, "%d", pp->tpgid);
-}
-
-/* SGI uses "cpu" to print the processor ID with header "P" */
-static int pr_sgi_p(char *restrict const outbuf, const proc_t *restrict const pp){          /* FIXME */
-  if(pp->state == 'R') return snprintf(outbuf, COLWID, "%d", pp->processor);
-  return snprintf(outbuf, COLWID, "*");
-}
-
-
-/****************** FLASK & seLinux security stuff **********************/
-// move the bulk of this to libproc sometime
-
-static int pr_context(char *restrict const outbuf, const proc_t *restrict const pp){
-  char filename[48];
-  size_t len;
-  ssize_t num_read;
-  int fd;
-
-// wchan file is suitable for testing
-//snprintf(filename, sizeof filename, "/proc/%d/wchan", pp->tgid);
-snprintf(filename, sizeof filename, "/proc/%d/attr/current", pp->tgid);
-
-  fd = open(filename, O_RDONLY, 0);
-  if(likely(fd==-1)) goto fail;
-  num_read = read(fd, outbuf, 666);
-  close(fd);
-  if(unlikely(num_read<=0)) goto fail;
-  outbuf[num_read] = '\0';
-
-  len = 0;
-  while(outbuf[len]>' ' && outbuf[len]<='~') len++;
-  outbuf[len] = '\0';
-  if(len) return len;
-
-fail:
-  outbuf[0] = '-';
-  outbuf[1] = '\0';
-  return 1;
-}
-
-#if 0
-// This needs more study, considering:
-// 1. the static linking option (maybe disable this in that case)
-// 2. the -z and -Z option issue
-// 3. width of output
-static int pr_context(char *restrict const outbuf, const proc_t *restrict const pp){
-  static int (*ps_getpidcon)(pid_t pid, char **context) = 0;
-  static int tried_load = 0;
-  size_t len;
-  char *context;
-
-  if(!ps_getpidcon && !tried_load){
-    void *handle = dlopen("libselinux.so.1", RTLD_NOW);
-    if(handle){
-      dlerror();
-      ps_getpidcon = dlsym(handle, "getpidcon");
-      if(dlerror())
-        ps_getpidcon = 0;
-    }
-    tried_load++;
-  }
-  if(ps_getpidcon && !ps_getpidcon(pp->tgid, &context)){
-    size_t max_len = OUTBUF_SIZE-1;
-    len = strlen(context);
-    if(len > max_len) len = max_len;
-    memcpy(outbuf, context, len);
-    outbuf[len] = '\0';
-    free(context);
-  }else{
-    outbuf[0] = '-';
-    outbuf[1] = '\0';
-    len = 1;
-  }
-  return len;
-}
-#endif
-
-
-////////////////////////////// Test code /////////////////////////////////
-
-// like "args"
-static int pr_t_unlimited(char *restrict const outbuf, const proc_t *restrict const pp){
-  static const char *const vals[] = {"[123456789-12345] <defunct>","ps","123456789-123456"};
-  (void)pp;
-  snprintf(outbuf, max_rightward+1, "%s", vals[lines_to_next_header%3u]);
-  return strlen(outbuf);
-}
-static int pr_t_unlimited2(char *restrict const outbuf, const proc_t *restrict const pp){
-  static const char *const vals[] = {"unlimited", "[123456789-12345] <defunct>","ps","123456789-123456"};
-  (void)pp;
-  snprintf(outbuf, max_rightward+1, "%s", vals[lines_to_next_header%4u]);
-  return strlen(outbuf);
-}
-
-// like "etime"
-static int pr_t_right(char *restrict const outbuf, const proc_t *restrict const pp){
-  static const char *const vals[] = {"999-23:59:59","99-23:59:59","9-23:59:59","59:59"};
-  (void)pp;
-  return snprintf(outbuf, COLWID, "%s", vals[lines_to_next_header%4u]);
-}
-static int pr_t_right2(char *restrict const outbuf, const proc_t *restrict const pp){
-  static const char *const vals[] = {"999-23:59:59","99-23:59:59","9-23:59:59"};
-  (void)pp;
-  return snprintf(outbuf, COLWID, "%s", vals[lines_to_next_header%3u]);
-}
-
-// like "tty"
-static int pr_t_left(char *restrict const outbuf, const proc_t *restrict const pp){
-  static const char *const vals[] = {"tty7","pts/9999","iseries/vtty42","ttySMX0","3270/tty4"};
-  (void)pp;
-  return snprintf(outbuf, COLWID, "%s", vals[lines_to_next_header%5u]);
-}
-static int pr_t_left2(char *restrict const outbuf, const proc_t *restrict const pp){
-  static const char *const vals[] = {"tty7","pts/9999","ttySMX0","3270/tty4"};
-  (void)pp;
-  return snprintf(outbuf, COLWID, "%s", vals[lines_to_next_header%4u]);
-}
-
-/***************************************************************************/
-/*************************** other stuff ***********************************/
-
-/*
- * Old header specifications.
- *
- * short   Up  "  PID TTY STAT  TIME COMMAND"
- * long  l Pp  " FLAGS   UID   PID  PPID PRI  NI   SIZE   RSS WCHAN       STA TTY TIME COMMAND
- * user  u up  "USER       PID %CPU %MEM  SIZE   RSS TTY STAT START   TIME COMMAND
- * jobs  j gPp " PPID   PID  PGID   SID TTY TPGID  STAT   UID   TIME COMMAND
- * sig   s p   "  UID   PID SIGNAL   BLOCKED  IGNORED  CATCHED  STAT TTY   TIME COMMAND
- * vm    v r   "  PID TTY STAT  TIME  PAGEIN TSIZ DSIZ  RSS   LIM %MEM COMMAND
- * m     m r   "  PID TTY MAJFLT MINFLT   TRS   DRS  SIZE  SWAP   RSS  SHRD   LIB  DT COMMAND
- * regs  X p   "NR   PID    STACK      ESP      EIP TMOUT ALARM STAT TTY   TIME COMMAND
- */
-
-/*
- * Unix98 requires that the heading for tty is TT, though XPG4, Digital,
- * and BSD use TTY. The Unix98 headers are:
- *              args,comm,etime,group,nice,pcpu,pgid
- *              pid,ppid,rgroup,ruser,time,tty,user,vsz
- *
- * BSD c:   "command" becomes accounting name ("comm" or "ucomm")
- * BSD n:   "user" becomes "uid" and "wchan" becomes "nwchan" (number)
- */
-
-/* Justification control for flags field. */
-#define USER      CF_USER   // left if text, right if numeric
-#define LEFT      CF_LEFT
-#define RIGHT     CF_RIGHT
-#define UNLIMITED CF_UNLIMITED
-#define WCHAN     CF_WCHAN  // left if text, right if numeric
-#define SIGNAL    CF_SIGNAL // right in 9, or 16 if room
-#define PIDMAX    CF_PIDMAX
-#define TO        CF_PRINT_THREAD_ONLY
-#define PO        CF_PRINT_PROCESS_ONLY
-#define ET        CF_PRINT_EVERY_TIME
-#define AN        CF_PRINT_AS_NEEDED // no idea
-
-/* short names to save space */
-#define MEM PROC_FILLMEM     /* read statm  */
-#define ARG PROC_FILLARG     /* read cmdline (cleared if c option) */
-#define COM PROC_FILLCOM     /* read cmdline (cleared if not -f option) */
-#define ENV PROC_FILLENV     /* read environ */
-#define USR PROC_FILLUSR     /* uid_t -> user names */
-#define GRP PROC_FILLGRP     /* gid_t -> group names */
-#define WCH PROC_FILLWCHAN   /* do WCHAN lookup */
-
-#define SGRP PROC_FILLSTATUS | PROC_FILLSUPGRP  /* supgid -> supgrp (names) */
-#define CGRP PROC_FILLCGROUP | PROC_EDITCGRPCVT /* read cgroup */
-
-/* TODO
- *      pull out annoying BSD aliases into another table (to macro table?)
- *      add sorting functions here (to unify names)
- */
-
-/* temporary hack -- mark new stuff grabbed from Debian ps */
-#define LNx LNX
-
-/* there are about 211 listed */
-
-/* Many of these are placeholders for unsupported options. */
-static const format_struct format_array[] = {
-/* code       header     print()      sort()    width need vendor flags  */
-{"%cpu",      "%CPU",    pr_pcpu,     sr_pcpu,    4,   0,    BSD, ET|RIGHT}, /*pcpu*/
-{"%mem",      "%MEM",    pr_pmem,     sr_nop,     4,   0,    BSD, PO|RIGHT}, /*pmem*/
-{"_left",     "LLLLLLLL", pr_t_left,  sr_nop,     8,   0,    TST, ET|LEFT},
-{"_left2",    "L2L2L2L2", pr_t_left2, sr_nop,     8,   0,    TST, ET|LEFT},
-{"_right",    "RRRRRRRRRRR", pr_t_right, sr_nop, 11,   0,    TST, ET|RIGHT},
-{"_right2",   "R2R2R2R2R2R", pr_t_right2, sr_nop, 11,  0,    TST, ET|RIGHT},
-{"_unlimited","U",   pr_t_unlimited,  sr_nop,    16,   0,    TST, ET|UNLIMITED},
-{"_unlimited2","U2", pr_t_unlimited2, sr_nop,    16,   0,    TST, ET|UNLIMITED},
-{"acflag",    "ACFLG",   pr_nop,      sr_nop,     5,   0,    XXX, AN|RIGHT}, /*acflg*/
-{"acflg",     "ACFLG",   pr_nop,      sr_nop,     5,   0,    BSD, AN|RIGHT}, /*acflag*/
-{"addr",      "ADDR",    pr_nop,      sr_nop,     4,   0,    XXX, AN|RIGHT},
-{"addr_1",    "ADDR",    pr_nop,      sr_nop,     1,   0,    LNX, AN|LEFT},
-{"alarm",     "ALARM",   pr_alarm,    sr_alarm,   5,   0,    LNX, AN|RIGHT},
-{"argc",      "ARGC",    pr_nop,      sr_nop,     4,   0,    LNX, PO|RIGHT},
-{"args",      "COMMAND", pr_args,     sr_cmd,    27, ARG,    U98, PO|UNLIMITED}, /*command*/
-{"atime",     "TIME",    pr_time,     sr_nop,     8,   0,    SOE, ET|RIGHT}, /*cputime*/ /* was 6 wide */
-{"blocked",   "BLOCKED", pr_sigmask,  sr_nop,     9,   0,    BSD, TO|SIGNAL}, /*sigmask*/
-{"bnd",       "BND",     pr_nop,      sr_nop,     1,   0,    AIX, TO|RIGHT},
-{"bsdstart",  "START",   pr_bsdstart, sr_nop,     6,   0,    LNX, ET|RIGHT},
-{"bsdtime",   "TIME",    pr_bsdtime,  sr_nop,     6,   0,    LNX, ET|RIGHT},
-{"c",         "C",       pr_c,        sr_pcpu,    2,   0,    SUN, ET|RIGHT},
-{"caught",    "CAUGHT",  pr_sigcatch, sr_nop,     9,   0,    BSD, TO|SIGNAL}, /*sigcatch*/
-{"cgroup",    "CGROUP",  pr_cgroup,   sr_nop,    27,CGRP,    LNX, PO|UNLIMITED},
-{"class",     "CLS",     pr_class,    sr_sched,   3,   0,    XXX, TO|LEFT},
-{"cls",       "CLS",     pr_class,    sr_sched,   3,   0,    HPU, TO|RIGHT}, /*says HPUX or RT*/
-{"cmaj_flt",  "-",       pr_nop,      sr_cmaj_flt, 1,  0,    LNX, AN|RIGHT},
-{"cmd",       "CMD",     pr_args,     sr_cmd,    27, ARG,    DEC, PO|UNLIMITED}, /*ucomm*/
-{"cmin_flt",  "-",       pr_nop,      sr_cmin_flt, 1,  0,    LNX, AN|RIGHT},
-{"cnswap",    "-",       pr_nop,      sr_nop,     1,   0,    LNX, AN|RIGHT},
-{"comm",      "COMMAND", pr_comm,     sr_cmd,    15, COM,    U98, PO|UNLIMITED}, /*ucomm*/
-{"command",   "COMMAND", pr_args,     sr_cmd,    27, ARG,    XXX, PO|UNLIMITED}, /*args*/
-{"context",   "CONTEXT", pr_context,  sr_nop,    31,   0,    LNX, ET|LEFT},
-{"cp",        "CP",      pr_cp,       sr_pcpu,    3,   0,    DEC, ET|RIGHT}, /*cpu*/
-{"cpu",       "CPU",     pr_nop,      sr_nop,     3,   0,    BSD, AN|RIGHT}, /* FIXME ... HP-UX wants this as the CPU number for SMP? */
-{"cpuid",     "CPUID",   pr_psr,      sr_nop,     5,   0,    BSD, TO|RIGHT}, // OpenBSD: 8 wide!
-{"cputime",   "TIME",    pr_time,     sr_nop,     8,   0,    DEC, ET|RIGHT}, /*time*/
-{"cstime",    "-",       pr_nop,      sr_cstime,  1,   0,    LNX, AN|RIGHT},
-{"ctid",      "CTID",    pr_nop,      sr_nop,     5,   0,    SUN, ET|RIGHT}, // resource contracts?
-{"cursig",    "CURSIG",  pr_nop,      sr_nop,     6,   0,    DEC, AN|RIGHT},
-{"cutime",    "-",       pr_nop,      sr_cutime,  1,   0,    LNX, AN|RIGHT},
-{"cwd",       "CWD",     pr_nop,      sr_nop,     3,   0,    LNX, AN|LEFT},
-{"drs",       "DRS",     pr_drs,      sr_drs,     5, MEM,    LNX, PO|RIGHT},
-{"dsiz",      "DSIZ",    pr_dsiz,     sr_nop,     4,   0,    LNX, PO|RIGHT},
-{"egid",      "EGID",    pr_egid,     sr_egid,    5,   0,    LNX, ET|RIGHT},
-{"egroup",    "EGROUP",  pr_egroup,   sr_egroup,  8, GRP,    LNX, ET|USER},
-{"eip",       "EIP",     pr_eip,      sr_kstk_eip, 8,  0,    LNX, TO|RIGHT},
-{"emul",      "EMUL",    pr_nop,      sr_nop,    13,   0,    BSD, PO|LEFT}, /* "FreeBSD ELF32" and such */
-{"end_code",  "E_CODE",  pr_nop,      sr_end_code, 8,  0,    LNx, PO|RIGHT},
-{"environ","ENVIRONMENT",pr_nop,      sr_nop,    11, ENV,    LNx, PO|UNLIMITED},
-{"esp",       "ESP",     pr_esp,      sr_kstk_esp, 8,  0,    LNX, TO|RIGHT},
-{"etime",     "ELAPSED", pr_etime,    sr_nop,    11,   0,    U98, ET|RIGHT}, /* was 7 wide */
-{"etimes",    "ELAPSED", pr_etimes,   sr_nop,     7,   0,    BSD, ET|RIGHT}, /* FreeBSD */
-{"euid",      "EUID",    pr_euid,     sr_euid,    5,   0,    LNX, ET|RIGHT},
-{"euser",     "EUSER",   pr_euser,    sr_euser,   8, USR,    LNX, ET|USER},
-{"f",         "F",       pr_flag,     sr_flags,   1,   0,    XXX, ET|RIGHT}, /*flags*/
-{"fgid",      "FGID",    pr_fgid,     sr_fgid,    5,   0,    LNX, ET|RIGHT},
-{"fgroup",    "FGROUP",  pr_fgroup,   sr_fgroup,  8, GRP,    LNX, ET|USER},
-{"flag",      "F",       pr_flag,     sr_flags,   1,   0,    DEC, ET|RIGHT},
-{"flags",     "F",       pr_flag,     sr_flags,   1,   0,    BSD, ET|RIGHT}, /*f*/ /* was FLAGS, 8 wide */
-{"fname",     "COMMAND", pr_fname,    sr_nop,     8,   0,    SUN, PO|LEFT},
-{"fsgid",     "FSGID",   pr_fgid,     sr_fgid,    5,   0,    LNX, ET|RIGHT},
-{"fsgroup",   "FSGROUP", pr_fgroup,   sr_fgroup,  8, GRP,    LNX, ET|USER},
-{"fsuid",     "FSUID",   pr_fuid,     sr_fuid,    5,   0,    LNX, ET|RIGHT},
-{"fsuser",    "FSUSER",  pr_fuser,    sr_fuser,   8, USR,    LNX, ET|USER},
-{"fuid",      "FUID",    pr_fuid,     sr_fuid,    5,   0,    LNX, ET|RIGHT},
-{"fuser",     "FUSER",   pr_fuser,    sr_fuser,   8, USR,    LNX, ET|USER},
-{"gid",       "GID",     pr_egid,     sr_egid,    5,   0,    SUN, ET|RIGHT},
-{"group",     "GROUP",   pr_egroup,   sr_egroup,  8, GRP,    U98, ET|USER},
-{"ignored",   "IGNORED", pr_sigignore,sr_nop,     9,   0,    BSD, TO|SIGNAL}, /*sigignore*/
-{"inblk",     "INBLK",   pr_nop,      sr_nop,     5,   0,    BSD, AN|RIGHT}, /*inblock*/
-{"inblock",   "INBLK",   pr_nop,      sr_nop,     5,   0,    DEC, AN|RIGHT}, /*inblk*/
-{"intpri",    "PRI",     pr_opri,     sr_priority, 3,  0,    HPU, TO|RIGHT},
-{"jid",       "JID",     pr_nop,      sr_nop,     1,   0,    SGI, PO|RIGHT},
-{"jobc",      "JOBC",    pr_nop,      sr_nop,     4,   0,    XXX, AN|RIGHT},
-{"ktrace",    "KTRACE",  pr_nop,      sr_nop,     8,   0,    BSD, AN|RIGHT},
-{"ktracep",   "KTRACEP", pr_nop,      sr_nop,     8,   0,    BSD, AN|RIGHT},
-{"label",     "LABEL",   pr_context,  sr_nop,    31,  0,     SGI, ET|LEFT},
-{"lastcpu",   "C",       pr_psr,      sr_nop,     3,   0,    BSD, TO|RIGHT}, // DragonFly
-{"lim",       "LIM",     pr_lim,      sr_rss_rlim, 5,  0,    BSD, AN|RIGHT},
-{"login",     "LOGNAME", pr_nop,      sr_nop,     8,   0,    BSD, AN|LEFT}, /*logname*/   /* double check */
-{"logname",   "LOGNAME", pr_nop,      sr_nop,     8,   0,    XXX, AN|LEFT}, /*login*/
-{"longtname", "TTY",     pr_tty8,     sr_tty,     8,   0,    DEC, PO|LEFT},
-{"lstart",    "STARTED", pr_lstart,   sr_nop,    24,   0,    XXX, ET|RIGHT},
-{"luid",      "LUID",    pr_nop,      sr_nop,     5,   0,    LNX, ET|RIGHT}, /* login ID */
-{"luser",     "LUSER",   pr_nop,      sr_nop,     8, USR,    LNX, ET|USER}, /* login USER */
-{"lwp",       "LWP",     pr_tasks,    sr_tasks,   5,   0,    SUN, TO|PIDMAX|RIGHT},
-{"m_drs",     "DRS",     pr_drs,      sr_drs,     5, MEM,    LNx, PO|RIGHT},
-{"m_dt",      "DT",      pr_nop,      sr_dt,      4, MEM,    LNx, PO|RIGHT},
-{"m_lrs",     "LRS",     pr_nop,      sr_lrs,     5, MEM,    LNx, PO|RIGHT},
-{"m_resident", "RES",    pr_nop,      sr_resident, 5,MEM,    LNx, PO|RIGHT},
-{"m_share",   "SHRD",    pr_nop,      sr_share,   5, MEM,    LNx, PO|RIGHT},
-{"m_size",    "SIZE",    pr_size,     sr_size,    5, MEM,    LNX, PO|RIGHT},
-{"m_swap",    "SWAP",    pr_nop,      sr_nop,     5,   0,    LNx, PO|RIGHT},
-{"m_trs",     "TRS",     pr_trs,      sr_trs,     5, MEM,    LNx, PO|RIGHT},
-{"maj_flt",   "MAJFL",   pr_majflt,   sr_maj_flt, 6,   0,    LNX, AN|RIGHT},
-{"majflt",    "MAJFLT",  pr_majflt,   sr_maj_flt, 6,   0,    XXX, AN|RIGHT},
-{"min_flt",   "MINFL",   pr_minflt,   sr_min_flt, 6,   0,    LNX, AN|RIGHT},
-{"minflt",    "MINFLT",  pr_minflt,   sr_min_flt, 6,   0,    XXX, AN|RIGHT},
-{"msgrcv",    "MSGRCV",  pr_nop,      sr_nop,     6,   0,    XXX, AN|RIGHT},
-{"msgsnd",    "MSGSND",  pr_nop,      sr_nop,     6,   0,    XXX, AN|RIGHT},
-{"mwchan",    "MWCHAN",  pr_nop,      sr_nop,     6, WCH,    BSD, TO|WCHAN}, /* mutex (FreeBSD) */
-{"ni",        "NI",      pr_nice,     sr_nice,    3,   0,    BSD, TO|RIGHT}, /*nice*/
-{"nice",      "NI",      pr_nice,     sr_nice,    3,   0,    U98, TO|RIGHT}, /*ni*/
-{"nivcsw",    "IVCSW",   pr_nop,      sr_nop,     5,   0,    XXX, AN|RIGHT},
-{"nlwp",      "NLWP",    pr_nlwp,     sr_nlwp,    4,   0,    SUN, PO|RIGHT},
-{"nsignals",  "NSIGS",   pr_nop,      sr_nop,     5,   0,    DEC, AN|RIGHT}, /*nsigs*/
-{"nsigs",     "NSIGS",   pr_nop,      sr_nop,     5,   0,    BSD, AN|RIGHT}, /*nsignals*/
-{"nswap",     "NSWAP",   pr_nop,      sr_nop,     5,   0,    XXX, AN|RIGHT},
-{"nvcsw",     "VCSW",    pr_nop,      sr_nop,     5,   0,    XXX, AN|RIGHT},
-{"nwchan",    "WCHAN",   pr_nwchan,   sr_nop,     6,   0,    XXX, TO|RIGHT},
-{"opri",      "PRI",     pr_opri,     sr_priority, 3,  0,    SUN, TO|RIGHT},
-{"osz",       "SZ",      pr_nop,      sr_nop,     2,   0,    SUN, PO|RIGHT},
-{"oublk",     "OUBLK",   pr_nop,      sr_nop,     5,   0,    BSD, AN|RIGHT}, /*oublock*/
-{"oublock",   "OUBLK",   pr_nop,      sr_nop,     5,   0,    DEC, AN|RIGHT}, /*oublk*/
-{"p_ru",      "P_RU",    pr_nop,      sr_nop,     6,   0,    BSD, AN|RIGHT},
-{"paddr",     "PADDR",   pr_nop,      sr_nop,     6,   0,    BSD, AN|RIGHT},
-{"pagein",    "PAGEIN",  pr_majflt,   sr_maj_flt, 6,   0,    XXX, AN|RIGHT},
-{"pcpu",      "%CPU",    pr_pcpu,     sr_pcpu,    4,   0,    U98, ET|RIGHT}, /*%cpu*/
-{"pending",   "PENDING", pr_sig,      sr_nop,     9,   0,    BSD, ET|SIGNAL}, /*sig*/
-{"pgid",      "PGID",    pr_pgid,     sr_pgrp,    5,   0,    U98, PO|PIDMAX|RIGHT},
-{"pgrp",      "PGRP",    pr_pgid,     sr_pgrp,    5,   0,    LNX, PO|PIDMAX|RIGHT},
-{"pid",       "PID",     pr_procs,    sr_procs,   5,   0,    U98, PO|PIDMAX|RIGHT},
-{"pmem",      "%MEM",    pr_pmem,     sr_nop,     4,   0,    XXX, PO|RIGHT}, /*%mem*/
-{"poip",      "-",       pr_nop,      sr_nop,     1,   0,    BSD, AN|RIGHT},
-{"policy",    "POL",     pr_class,    sr_sched,   3,   0,    DEC, TO|LEFT},
-{"ppid",      "PPID",    pr_ppid,     sr_ppid,    5,   0,    U98, PO|PIDMAX|RIGHT},
-{"pri",       "PRI",     pr_pri,      sr_nop,     3,   0,    XXX, TO|RIGHT},
-{"pri_api",   "API",     pr_pri_api,  sr_nop,     3,   0,    LNX, TO|RIGHT},
-{"pri_bar",   "BAR",     pr_pri_bar,  sr_nop,     3,   0,    LNX, TO|RIGHT},
-{"pri_baz",   "BAZ",     pr_pri_baz,  sr_nop,     3,   0,    LNX, TO|RIGHT},
-{"pri_foo",   "FOO",     pr_pri_foo,  sr_nop,     3,   0,    LNX, TO|RIGHT},
-{"priority",  "PRI",     pr_priority, sr_priority, 3,  0,    LNX, TO|RIGHT},
-{"prmgrp",    "PRMGRP",  pr_nop,      sr_nop,    12,   0,    HPU, PO|RIGHT},
-{"prmid",     "PRMID",   pr_nop,      sr_nop,    12,   0,    HPU, PO|RIGHT},
-{"project",   "PROJECT", pr_nop,      sr_nop,    12,   0,    SUN, PO|LEFT}, // see prm* andctid
-{"projid",    "PROJID",  pr_nop,      sr_nop,     5,   0,    SUN, PO|RIGHT},
-{"pset",      "PSET",    pr_nop,      sr_nop,     4,   0,    DEC, TO|RIGHT},
-{"psr",       "PSR",     pr_psr,      sr_nop,     3,   0,    DEC, TO|RIGHT},
-{"psxpri",    "PPR",     pr_nop,      sr_nop,     3,   0,    DEC, TO|RIGHT},
-{"re",        "RE",      pr_nop,      sr_nop,     3,   0,    BSD, AN|RIGHT},
-{"resident",  "RES",     pr_nop,      sr_resident, 5,MEM,    LNX, PO|RIGHT},
-{"rgid",      "RGID",    pr_rgid,     sr_rgid,    5,   0,    XXX, ET|RIGHT},
-{"rgroup",    "RGROUP",  pr_rgroup,   sr_rgroup,  8, GRP,    U98, ET|USER}, /* was 8 wide */
-{"rlink",     "RLINK",   pr_nop,      sr_nop,     8,   0,    BSD, AN|RIGHT},
-{"rss",       "RSS",     pr_rss,      sr_rss,     5,   0,    XXX, PO|RIGHT}, /* was 5 wide */
-{"rssize",    "RSS",     pr_rss,      sr_vm_rss,  5,   0,    DEC, PO|RIGHT}, /*rsz*/
-{"rsz",       "RSZ",     pr_rss,      sr_vm_rss,  5,   0,    BSD, PO|RIGHT}, /*rssize*/
-{"rtprio",    "RTPRIO",  pr_rtprio,   sr_rtprio,  6,   0,    BSD, TO|RIGHT},
-{"ruid",      "RUID",    pr_ruid,     sr_ruid,    5,   0,    XXX, ET|RIGHT},
-{"ruser",     "RUSER",   pr_ruser,    sr_ruser,   8, USR,    U98, ET|USER},
-{"s",         "S",       pr_s,        sr_state,   1,   0,    SUN, TO|LEFT}, /*stat,state*/
-{"sched",     "SCH",     pr_sched,    sr_sched,   3,   0,    AIX, TO|RIGHT},
-{"scnt",      "SCNT",    pr_nop,      sr_nop,     4,   0,    DEC, AN|RIGHT},  /* man page misspelling of scount? */
-{"scount",    "SC",      pr_nop,      sr_nop,     4,   0,    AIX, AN|RIGHT},  /* scnt==scount, DEC claims both */
-{"sess",      "SESS",    pr_sess,     sr_session, 5,   0,    XXX, PO|PIDMAX|RIGHT},
-{"session",   "SESS",    pr_sess,     sr_session, 5,   0,    LNX, PO|PIDMAX|RIGHT},
-{"sgi_p",     "P",       pr_sgi_p,    sr_nop,     1,   0,    LNX, TO|RIGHT}, /* "cpu" number */
-{"sgi_rss",   "RSS",     pr_rss,      sr_nop,     4,   0,    LNX, PO|LEFT}, /* SZ:RSS */
-{"sgid",      "SGID",    pr_sgid,     sr_sgid,    5,   0,    LNX, ET|RIGHT},
-{"sgroup",    "SGROUP",  pr_sgroup,   sr_sgroup,  8, GRP,    LNX, ET|USER},
-{"share",     "-",       pr_nop,      sr_share,   1, MEM,    LNX, PO|RIGHT},
-{"sid",       "SID",     pr_sess,     sr_session, 5,   0,    XXX, PO|PIDMAX|RIGHT}, /* Sun & HP */
-{"sig",       "PENDING", pr_sig,      sr_nop,     9,   0,    XXX, ET|SIGNAL}, /*pending -- Dragonfly uses this for whole-proc and "tsig" for thread */
-{"sig_block", "BLOCKED",  pr_sigmask, sr_nop,     9,   0,    LNX, TO|SIGNAL},
-{"sig_catch", "CATCHED", pr_sigcatch, sr_nop,     9,   0,    LNX, TO|SIGNAL},
-{"sig_ignore", "IGNORED",pr_sigignore, sr_nop,    9,   0,    LNX, TO|SIGNAL},
-{"sig_pend",  "SIGNAL",   pr_sig,     sr_nop,     9,   0,    LNX, ET|SIGNAL},
-{"sigcatch",  "CAUGHT",  pr_sigcatch, sr_nop,     9,   0,    XXX, TO|SIGNAL}, /*caught*/
-{"sigignore", "IGNORED", pr_sigignore,sr_nop,     9,   0,    XXX, TO|SIGNAL}, /*ignored*/
-{"sigmask",   "BLOCKED", pr_sigmask,  sr_nop,     9,   0,    XXX, TO|SIGNAL}, /*blocked*/
-{"size",      "SZ",      pr_swapable, sr_swapable, 5,  0,    SCO, PO|RIGHT},
-{"sl",        "SL",      pr_nop,      sr_nop,     3,   0,    XXX, AN|RIGHT},
-{"spid",      "SPID",    pr_tasks,    sr_tasks,   5,   0,    SGI, TO|PIDMAX|RIGHT},
-{"stackp",    "STACKP",  pr_stackp,   sr_start_stack, 8, 0,  LNX, PO|RIGHT}, /*start_stack*/
-{"start",     "STARTED", pr_start,    sr_nop,     8,   0,    XXX, ET|RIGHT},
-{"start_code", "S_CODE",  pr_nop,     sr_start_code, 8, 0,   LNx, PO|RIGHT},
-{"start_stack", "STACKP", pr_stackp,  sr_start_stack, 8, 0,  LNX, PO|RIGHT}, /*stackp*/
-{"start_time", "START",  pr_stime,    sr_start_time, 5, 0,   LNx, ET|RIGHT},
-{"stat",      "STAT",    pr_stat,     sr_state,   4,   0,    BSD, TO|LEFT}, /*state,s*/
-{"state",     "S",       pr_s,        sr_state,   1,   0,    XXX, TO|LEFT}, /*stat,s*/ /* was STAT */
-{"status",    "STATUS",  pr_nop,      sr_nop,     6,   0,    DEC, AN|RIGHT},
-{"stime",     "STIME",   pr_stime,    sr_stime,   5,   0,    XXX, ET|RIGHT}, /* was 6 wide */
-{"suid",      "SUID",    pr_suid,     sr_suid,    5,   0,    LNx, ET|RIGHT},
-{"supgid",    "SUPGID",  pr_supgid,   sr_nop,    20,   0,    LNX, PO|UNLIMITED},
-{"supgrp",    "SUPGRP",  pr_supgrp,   sr_nop,    40,SGRP,    LNX, PO|UNLIMITED},
-{"suser",     "SUSER",   pr_suser,    sr_suser,   8, USR,    LNx, ET|USER},
-{"svgid",     "SVGID",   pr_sgid,     sr_sgid,    5,   0,    XXX, ET|RIGHT},
-{"svgroup",   "SVGROUP", pr_sgroup,   sr_sgroup,  8, GRP,    LNX, ET|USER},
-{"svuid",     "SVUID",   pr_suid,     sr_suid,    5,   0,    XXX, ET|RIGHT},
-{"svuser",    "SVUSER",  pr_suser,    sr_suser,   8, USR,    LNX, ET|USER},
-{"systime",   "SYSTEM",  pr_nop,      sr_nop,     6,   0,    DEC, ET|RIGHT},
-{"sz",        "SZ",      pr_sz,       sr_nop,     5,   0,    HPU, PO|RIGHT},
-{"taskid",    "TASKID",  pr_nop,      sr_nop,     5,   0,    SUN, TO|PIDMAX|RIGHT}, // is this a thread ID?
-{"tdev",      "TDEV",    pr_nop,      sr_nop,     4,   0,    XXX, AN|RIGHT},
-{"thcount",   "THCNT",   pr_nlwp,     sr_nlwp,    5,   0,    AIX, PO|RIGHT},
-{"tgid",      "TGID",    pr_procs,    sr_procs,   5,   0,    LNX, PO|PIDMAX|RIGHT},
-{"tid",       "TID",     pr_tasks,    sr_tasks,   5,   0,    AIX, TO|PIDMAX|RIGHT},
-{"time",      "TIME",    pr_time,     sr_nop,     8,   0,    U98, ET|RIGHT}, /*cputime*/ /* was 6 wide */
-{"timeout",   "TMOUT",   pr_nop,      sr_nop,     5,   0,    LNX, AN|RIGHT}, // 2.0.xx era
-{"tmout",     "TMOUT",   pr_nop,      sr_nop,     5,   0,    LNX, AN|RIGHT}, // 2.0.xx era
-{"tname",     "TTY",     pr_tty8,     sr_tty,     8,   0,    DEC, PO|LEFT},
-{"tpgid",     "TPGID",   pr_tpgid,    sr_tpgid,   5,   0,    XXX, PO|PIDMAX|RIGHT},
-{"trs",       "TRS",     pr_trs,      sr_trs,     4, MEM,    AIX, PO|RIGHT},
-{"trss",      "TRSS",    pr_trs,      sr_trs,     4, MEM,    BSD, PO|RIGHT}, /* 4.3BSD NET/2 */
-{"tsess",     "TSESS",   pr_nop,      sr_nop,     5,   0,    BSD, PO|PIDMAX|RIGHT},
-{"tsession",  "TSESS",   pr_nop,      sr_nop,     5,   0,    DEC, PO|PIDMAX|RIGHT},
-{"tsid",      "TSID",    pr_nop,      sr_nop,     5,   0,    BSD, PO|PIDMAX|RIGHT},
-{"tsig",      "PENDING", pr_tsig,     sr_nop,     9,   0,    BSD, ET|SIGNAL}, /* Dragonfly used this for thread-specific, and "sig" for whole-proc */
-{"tsiz",      "TSIZ",    pr_tsiz,     sr_nop,     4,   0,    BSD, PO|RIGHT},
-{"tt",        "TT",      pr_tty8,     sr_tty,     8,   0,    BSD, PO|LEFT},
-{"tty",       "TT",      pr_tty8,     sr_tty,     8,   0,    U98, PO|LEFT}, /* Unix98 requires "TT" but has "TTY" too. :-( */  /* was 3 wide */
-{"tty4",      "TTY",     pr_tty4,     sr_tty,     4,   0,    LNX, PO|LEFT},
-{"tty8",      "TTY",     pr_tty8,     sr_tty,     8,   0,    LNX, PO|LEFT},
-{"u_procp",   "UPROCP",  pr_nop,      sr_nop,     6,   0,    DEC, AN|RIGHT},
-{"ucmd",      "CMD",     pr_comm,     sr_cmd,    15, COM,    DEC, PO|UNLIMITED}, /*ucomm*/
-{"ucomm",     "COMMAND", pr_comm,     sr_cmd,    15, COM,    XXX, PO|UNLIMITED}, /*comm*/
-{"uid",       "UID",     pr_euid,     sr_euid,    5,   0,    XXX, ET|RIGHT},
-{"uid_hack",  "UID",     pr_euser,    sr_euser,   8, USR,    XXX, ET|USER},
-{"umask",     "UMASK",   pr_nop,      sr_nop,     5,   0,    DEC, AN|RIGHT},
-{"uname",     "USER",    pr_euser,    sr_euser,   8, USR,    DEC, ET|USER}, /* man page misspelling of user? */
-{"upr",       "UPR",     pr_nop,      sr_nop,     3,   0,    BSD, TO|RIGHT}, /*usrpri*/
-{"uprocp",    "UPROCP",  pr_nop,      sr_nop,     8,   0,    BSD, AN|RIGHT},
-{"user",      "USER",    pr_euser,    sr_euser,   8, USR,    U98, ET|USER}, /* BSD n forces this to UID */
-{"usertime",  "USER",    pr_nop,      sr_nop,     4,   0,    DEC, ET|RIGHT},
-{"usrpri",    "UPR",     pr_nop,      sr_nop,     3,   0,    DEC, TO|RIGHT}, /*upr*/
-{"util",      "C",       pr_c,        sr_pcpu,    2,   0,    SGI, ET|RIGHT}, // not sure about "C"
-{"utime",     "UTIME",   pr_nop,      sr_utime,   6,   0,    LNx, ET|RIGHT},
-{"vm_data",   "DATA",    pr_nop,      sr_vm_data, 5,   0,    LNx, PO|RIGHT},
-{"vm_exe",    "EXE",     pr_nop,      sr_vm_exe,  5,   0,    LNx, PO|RIGHT},
-{"vm_lib",    "LIB",     pr_nop,      sr_vm_lib,  5,   0,    LNx, PO|RIGHT},
-{"vm_lock",   "LCK",     pr_nop,      sr_vm_lock, 3,   0,    LNx, PO|RIGHT},
-{"vm_stack",  "STACK",   pr_nop,      sr_vm_stack, 5,  0,    LNx, PO|RIGHT},
-{"vsize",     "VSZ",     pr_vsz,      sr_vsize,   6,   0,    DEC, PO|RIGHT}, /*vsz*/
-{"vsz",       "VSZ",     pr_vsz,      sr_vm_size, 6,   0,    U98, PO|RIGHT}, /*vsize*/
-{"wchan",     "WCHAN",   pr_wchan,    sr_wchan,   6, WCH,    XXX, TO|WCHAN}, /* BSD n forces this to nwchan */ /* was 10 wide */
-{"wname",     "WCHAN",   pr_wname,    sr_nop,     6, WCH,    SGI, TO|WCHAN}, /* opposite of nwchan */
-{"xstat",     "XSTAT",   pr_nop,      sr_nop,     5,   0,    BSD, AN|RIGHT},
-{"zone",      "ZONE",    pr_context,  sr_nop,    31,   0,    SUN, ET|LEFT}, // Solaris zone == Linux context?
-{"zoneid",    "ZONEID",  pr_nop,      sr_nop,    31,   0,    SUN, ET|RIGHT},// Linux only offers context names
-{"~",         "-",       pr_nop,      sr_nop,     1,   0,    LNX, AN|RIGHT}  /* NULL would ruin alphabetical order */
-};
-
-#undef USER
-#undef LEFT
-#undef RIGHT
-#undef UNLIMITED
-#undef WCHAN
-#undef SIGNAL
-#undef PIDMAX
-#undef PO
-#undef TO
-#undef AN
-#undef ET
-
-static const int format_array_count = sizeof(format_array)/sizeof(format_struct);
-
-
-/****************************** Macro formats *******************************/
-/* First X field may be NR, which is p->start_code>>26 printed with %2ld */
-/* That seems useless though, and Debian already killed it. */
-/* The ones marked "Digital" have the name defined, not just the data. */
-static const macro_struct macro_array[] = {
-{"DFMT",     "pid,tname,state,cputime,cmd"},         /* Digital's default */
-{"DefBSD",   "pid,tname,stat,bsdtime,args"},               /* Our BSD default */
-{"DefSysV",  "pid,tname,time,cmd"},                     /* Our SysV default */
-{"END_BSD",  "state,tname,cputime,comm"},                 /* trailer for O */
-{"END_SYS5", "state,tname,time,command"},                 /* trailer for -O */
-{"F5FMT",    "uname,pid,ppid,c,start,tname,time,cmd"},       /* Digital -f */
-
-{"FB_",      "pid,tt,stat,time,command"},                          /* FreeBSD default */
-{"FB_j",     "user,pid,ppid,pgid,sess,jobc,stat,tt,time,command"},     /* FreeBSD j */
-{"FB_l",     "uid,pid,ppid,cpu,pri,nice,vsz,rss,wchan,stat,tt,time,command"},   /* FreeBSD l */
-{"FB_u",     "user,pid,pcpu,pmem,vsz,rss,tt,stat,start,time,command"},     /* FreeBSD u */
-{"FB_v",     "pid,stat,time,sl,re,pagein,vsz,rss,lim,tsiz,pcpu,pmem,command"},   /* FreeBSD v */
-
-{"FD_",      "pid,tty,time,comm"},                                 /* Fictional Debian SysV default */
-{"FD_f",     "user,pid,ppid,start_time,tty,time,comm"},                /* Fictional Debian -f */
-{"FD_fj",    "user,pid,ppid,start_time,tty,time,pgid,sid,comm"},        /* Fictional Debian -jf */
-{"FD_j",     "pid,tty,time,pgid,sid,comm"},                                  /* Fictional Debian -j */
-{"FD_l",     "flags,state,uid,pid,ppid,priority,nice,vsz,wchan,tty,time,comm"},    /* Fictional Debian -l */
-{"FD_lj",    "flags,state,uid,pid,ppid,priority,nice,vsz,wchan,tty,time,pgid,sid,comm"}, /* Fictional Debian -jl */
-
-{"FL5FMT",   "f,state,uid,pid,ppid,pcpu,pri,nice,rss,wchan,start,time,command"},  /* Digital -fl */
-
-{"FLASK_context",   "pid,context,command"},  /* Flask Linux context, --context */
-
-{"HP_",      "pid,tty,time,comm"},  /* HP default */
-{"HP_f",     "user,pid,ppid,cpu,stime,tty,time,args"},  /* HP -f */
-{"HP_fl",    "flags,state,user,pid,ppid,cpu,intpri,nice,addr,sz,wchan,stime,tty,time,args"},  /* HP -fl */
-{"HP_l",     "flags,state,uid,pid,ppid,cpu,intpri,nice,addr,sz,wchan,tty,time,comm"},  /* HP -l */
-
-{"J390",     "pid,sid,pgrp,tname,atime,args"},   /* OS/390 -j */
-{"JFMT",     "user,pid,ppid,pgid,sess,jobc,state,tname,cputime,command"},   /* Digital j and -j */
-{"L5FMT",    "f,state,uid,pid,ppid,c,pri,nice,addr,sz,wchan,tt,time,ucmd"},   /* Digital -l */
-{"LFMT",     "uid,pid,ppid,cp,pri,nice,vsz,rss,wchan,state,tname,cputime,command"},   /* Digital l */
-
-{"OL_X",     "pid,start_stack,esp,eip,timeout,alarm,stat,tname,bsdtime,args"},      /* Old i386 Linux X */
-{"OL_j",     "ppid,pid,pgid,sid,tname,tpgid,stat,uid,bsdtime,args"},                   /* Old Linux j */
-{"OL_l",     "flags,uid,pid,ppid,priority,nice,vsz,rss,wchan,stat,tname,bsdtime,args"},     /* Old Linux l */
-{"OL_m",     "pid,tname,majflt,minflt,m_trs,m_drs,m_size,m_swap,rss,m_share,vm_lib,m_dt,args"}, /* Old Linux m */
-{"OL_s",     "uid,pid,pending,sig_block,sig_ignore,caught,stat,tname,bsdtime,args"},  /* Old Linux s */
-{"OL_u",     "user,pid,pcpu,pmem,vsz,rss,tname,stat,start_time,bsdtime,args"},       /* Old Linux u */
-{"OL_v",     "pid,tname,stat,bsdtime,maj_flt,m_trs,m_drs,rss,pmem,args"},            /* Old Linux v */
-
-{"RD_",      "pid,tname,state,bsdtime,comm"},                                       /* Real Debian default */
-{"RD_f",     "uid,pid,ppid,start_time,tname,bsdtime,args"},                         /* Real Debian -f */
-{"RD_fj",    "uid,pid,ppid,start_time,tname,bsdtime,pgid,sid,args"},                /* Real Debian -jf */
-{"RD_j",     "pid,tname,state,bsdtime,pgid,sid,comm"},                               /* Real Debian -j */
-{"RD_l",     "flags,state,uid,pid,ppid,priority,nice,wchan,tname,bsdtime,comm"},           /* Real Debian -l */
-{"RD_lj",    "flags,state,uid,pid,ppid,priority,nice,wchan,tname,bsdtime,pgid,sid,comm"},  /* Real Debian -jl */
-
-{"RUSAGE",   "minflt,majflt,nswap,inblock,oublock,msgsnd,msgrcv,nsigs,nvcsw,nivcsw"}, /* Digital -o "RUSAGE" */
-{"SCHED",    "user,pcpu,pri,usrpri,nice,psxpri,psr,policy,pset"},                /* Digital -o "SCHED" */
-{"SFMT",     "uid,pid,cursig,sig,sigmask,sigignore,sigcatch,stat,tname,command"},  /* Digital s */
-
-{"Std_f",    "uid_hack,pid,ppid,c,stime,tname,time,cmd"},                     /* new -f */
-{"Std_fl",   "f,s,uid_hack,pid,ppid,c,opri,ni,addr,sz,wchan,stime,tname,time,cmd"}, /* -fl */
-{"Std_l",    "f,s,uid,pid,ppid,c,opri,ni,addr,sz,wchan,tname,time,ucmd"},  /* new -l */
-
-{"THREAD",   "user,pcpu,pri,scnt,wchan,usertime,systime"},                /* Digital -o "THREAD" */
-{"UFMT",     "uname,pid,pcpu,pmem,vsz,rss,tt,state,start,time,command"},   /* Digital u */
-{"VFMT",     "pid,tt,state,time,sl,pagein,vsz,rss,pcpu,pmem,command"},   /* Digital v */
-{"~", "~"} /* NULL would ruin alphabetical order */
-};
-
-static const int macro_array_count = sizeof(macro_array)/sizeof(macro_struct);
-
-
-/*************************** AIX formats ********************/
-/* Convert AIX format codes to normal format specifiers. */
-static const aix_struct aix_array[] = {
-{'C', "pcpu",   "%CPU"},
-{'G', "group",  "GROUP"},
-{'P', "ppid",   "PPID"},
-{'U', "user",   "USER"},
-{'a', "args",   "COMMAND"},
-{'c', "comm",   "COMMAND"},
-{'g', "rgroup", "RGROUP"},
-{'n', "nice",   "NI"},
-{'p', "pid",    "PID"},
-{'r', "pgid",   "PGID"},
-{'t', "etime",  "ELAPSED"},
-{'u', "ruser",  "RUSER"},
-{'x', "time",   "TIME"},
-{'y', "tty",    "TTY"},
-{'z', "vsz",    "VSZ"},
-{'~', "~",      "~"} /* NULL would ruin alphabetical order */
-};
-static const int aix_array_count = sizeof(aix_array)/sizeof(aix_struct);
-
-
-/********************* sorting ***************************/
-/* Convert short sorting codes to normal format specifiers. */
-static const shortsort_struct shortsort_array[] = {
-{'C', "pcpu"       },
-{'G', "tpgid"      },
-{'J', "cstime"     },
-/* {'K', "stime"      }, */  /* conflict, system vs. start time */
-{'M', "maj_flt"    },
-{'N', "cmaj_flt"   },
-{'P', "ppid"       },
-{'R', "resident"   },
-{'S', "share"      },
-{'T', "start_time" },
-{'U', "uid"        }, /* euid */
-{'c', "cmd"        },
-{'f', "flags"      },
-{'g', "pgrp"       },
-{'j', "cutime"     },
-{'k', "utime"      },
-{'m', "min_flt"    },
-{'n', "cmin_flt"   },
-{'o', "session"    },
-{'p', "pid"        },
-{'r', "rss"        },
-{'s', "size"       },
-{'t', "tty"        },
-{'u', "user"       },
-{'v', "vsize"      },
-{'y', "priority"   }, /* nice */
-{'~', "~"          } /* NULL would ruin alphabetical order */
-};
-static const int shortsort_array_count = sizeof(shortsort_array)/sizeof(shortsort_struct);
-
-
-/*********** print format_array **********/
-/* called by the parser in another file */
-void print_format_specifiers(void){
-  const format_struct *walk = format_array;
-  while(*(walk->spec) != '~'){
-    if(walk->pr != pr_nop) printf("%-12.12s %-8.8s\n", walk->spec, walk->head);
-    walk++;
-  }
-}
-
-/************ comparison functions for bsearch *************/
-
-static int compare_format_structs(const void *a, const void *b){
-  return strcmp(((const format_struct*)a)->spec,((const format_struct*)b)->spec);
-}
-
-static int compare_macro_structs(const void *a, const void *b){
-  return strcmp(((const macro_struct*)a)->spec,((const macro_struct*)b)->spec);
-}
-
-/******** look up structs as needed by the sort & format parsers ******/
-
-const shortsort_struct *search_shortsort_array(const int findme){
-  const shortsort_struct *walk = shortsort_array;
-  while(walk->desc != '~'){
-    if(walk->desc == findme) return walk;
-    walk++;
-  }
-  return NULL;
-}
-
-const aix_struct *search_aix_array(const int findme){
-  const aix_struct *walk = aix_array;
-  while(walk->desc != '~'){
-    if(walk->desc == findme) return walk;
-    walk++;
-  }
-  return NULL;
-}
-
-const format_struct *search_format_array(const char *findme){
-  format_struct key;
-  key.spec = findme;
-  return bsearch(&key, format_array, format_array_count,
-    sizeof(format_struct), compare_format_structs
-  );
-}
-
-const macro_struct *search_macro_array(const char *findme){
-  macro_struct key;
-  key.spec = findme;
-  return bsearch(&key, macro_array, macro_array_count,
-    sizeof(macro_struct), compare_macro_structs
-  );
-}
-
-static unsigned int active_cols;  /* some multiple of screen_cols */
-
-/***** Last chance, avoid needless trunctuation. */
-static void check_header_width(void){
-  format_node *walk = format_list;
-  unsigned int total = 0;
-  int was_normal = 0;
-  unsigned int i = 0;
-  unsigned int sigs = 0;
-  while(walk){
-    switch((walk->flags) & CF_JUST_MASK){
-    default:
-      total += walk->width;
-      total += was_normal;
-      was_normal = 1;
-      break;
-    case CF_SIGNAL:
-      sigs++;
-      total += walk->width;
-      total += was_normal;
-      was_normal = 1;
-      break;
-    case CF_UNLIMITED:  /* could chop this a bit */
-      if(walk->next) total += walk->width;
-      else total += 3; /* not strlen(walk->name) */
-      total += was_normal;
-      was_normal = 1;
-      break;
-    case 0:  /* AIX */
-      total += walk->width;
-      was_normal = 0;
-      break;
-    }
-    walk = walk->next;
-  }
-  for(;;){
-    i++;
-    active_cols = screen_cols * i;
-    if(active_cols>=total) break;
-    if(screen_cols*i >= OUTBUF_SIZE/2) break; /* can't go over */
-  }
-  wide_signals = (total+sigs*7 <= active_cols);
-}
-
-
-/********** show one process (NULL proc prints header) **********/
-
-//#define SPACE_AMOUNT page_size
-#define SPACE_AMOUNT 144
-
-static char *saved_outbuf;
-
-void show_one_proc(const proc_t *restrict const p, const format_node *restrict fmt){
-  /* unknown: maybe set correct & actual to 1, remove +/- 1 below */
-  int correct  = 0;  /* screen position we should be at */
-  int actual   = 0;  /* screen position we are at */
-  int amount   = 0;  /* amount of text that this data is */
-  int leftpad  = 0;  /* amount of space this column _could_ need */
-  int space    = 0;  /* amount of space we actually need to print */
-  int dospace  = 0;  /* previous column determined that we need a space */
-  int legit    = 0;  /* legitimately stolen extra space */
-  int sz       = 0;  /* real size of data in outbuffer */
-  int tmpspace = 0;
-  char *restrict const outbuf = saved_outbuf;
-  static int did_stuff = 0;  /* have we ever printed anything? */
-
-  if(unlikely(-1==(long)p)){    /* true only once, at the end */
-    if(did_stuff) return;
-    /* have _never_ printed anything, but might need a header */
-    if(!--lines_to_next_header){
-      lines_to_next_header = header_gap;
-      show_one_proc(NULL,fmt);
-    }
-    /* fprintf(stderr, "No processes available.\n"); */  /* legal? */
-    exit(1);
-  }
-  if(likely(p)){  /* not header, maybe we should call ourselves for it */
-    if(unlikely(!--lines_to_next_header)){
-      lines_to_next_header = header_gap;
-      show_one_proc(NULL,fmt);
-    }
-  }
-  did_stuff = 1;
-  if(unlikely(active_cols>(int)OUTBUF_SIZE)) fprintf(stderr,"Fix bigness error.\n");
-
-  /* print row start sequence */
-  for(;;){
-    legit = 0;
-    /* set width suggestion which might be ignored */
-//    if(likely(fmt->next)) max_rightward = fmt->width;
-//    else max_rightward = active_cols-((correct>actual) ? correct : actual);
-
-    if(likely(fmt->next)){
-      max_rightward = fmt->width;
-      tmpspace = 0;
-    }else{
-      tmpspace = correct-actual;
-      if (tmpspace<1){
-        tmpspace = dospace;
-        max_rightward = active_cols-actual-tmpspace;
-      }else{
-	max_rightward = active_cols - ( (correct>actual) ? correct : actual );
-      }
-    }
-    max_leftward  = fmt->width + actual - correct; /* TODO check this */
-
-//    fprintf(stderr, "cols: %d, max_rightward: %d, max_leftward: %d, actual: %d, correct: %d\n",
-//		    active_cols, max_rightward, max_leftward, actual, correct);
-
-    /* prepare data and calculate leftpad */
-    if(likely(p) && likely(fmt->pr)) amount = (*fmt->pr)(outbuf,p);
-    else amount = strlen(strcpy(outbuf, fmt->name)); /* AIX or headers */
-
-    switch((fmt->flags) & CF_JUST_MASK){
-    case 0:  /* for AIX, assigned outside this file */
-      leftpad = 0;
-      break;
-    case CF_LEFT:          /* bad */
-      leftpad = 0;
-      break;
-    case CF_RIGHT:     /* OK */
-      leftpad = fmt->width - amount;
-      if(leftpad < 0) leftpad = 0;
-      break;
-    case CF_SIGNAL:
-      /* if the screen is wide enough, use full 16-character output */
-      if(wide_signals){
-        leftpad = 16 - amount;
-        legit = 7;
-      }else{
-        leftpad =  9 - amount;
-      }
-      if(leftpad < 0) leftpad = 0;
-      break;
-    case CF_USER:       /* bad */
-      leftpad = fmt->width - amount;
-      if(leftpad < 0) leftpad = 0;
-      if(!user_is_number) leftpad = 0;
-      break;
-    case CF_WCHAN:       /* bad */
-      if(wchan_is_number){
-        leftpad = fmt->width - amount;
-        if(leftpad < 0) leftpad = 0;
-        break;
-      }else{
-        if ((active_cols-actual-tmpspace)<1)
-          outbuf[1] = '\0';  /* oops, we (mostly) lose this column... */
-        leftpad = 0;
-        break;
-      }
-    case CF_UNLIMITED:
-    {
-      if(active_cols-actual-tmpspace < 1)
-        outbuf[1] = '\0';    /* oops, we (mostly) lose this column... */
-      leftpad = 0;
-      break;
-    }
-    default:
-      fprintf(stderr, "bad alignment code\n");
-      break;
-    }
-    /* At this point:
-     *
-     * correct   from previous column
-     * actual    from previous column
-     * amount    not needed (garbage due to chopping)
-     * leftpad   left padding for this column alone (not make-up or gap)
-     * space     not needed (will recalculate now)
-     * dospace   if we require space between this and the prior column
-     * legit     space we were allowed to steal, and thus did steal
-     */
-    space = correct - actual + leftpad;
-    if(space<1) space=dospace;
-    if(unlikely(space>SPACE_AMOUNT)) space=SPACE_AMOUNT;  // only so much available
-
-    /* real size -- don't forget in 'amount' is number of cells */
-    sz = strlen(outbuf);
-
-    /* print data, set x position stuff */
-    if(unlikely(!fmt->next)){
-      /* Last column. Write padding + data + newline all together. */
-      outbuf[sz] = '\n';
-      fwrite(outbuf-space, space+sz+1, 1, stdout);
-      break;
-    }
-    /* Not the last column. Write padding + data together. */
-    fwrite(outbuf-space, space+sz, 1, stdout);
-    actual  += space+amount;
-    correct += fmt->width;
-    correct += legit;        /* adjust for SIGNAL expansion */
-    if(fmt->pr && fmt->next->pr){ /* neither is AIX filler */
-      correct++;
-      dospace = 1;
-    }else{
-      dospace = 0;
-    }
-    fmt = fmt->next;
-    /* At this point:
-     *
-     * correct   screen position we should be at
-     * actual    screen position we are at
-     * amount    not needed
-     * leftpad   not needed
-     * space     not needed
-     * dospace   if have determined that we need a space next time
-     * legit     not needed
-     */
-  }
-}
-
-
-#ifdef TESTING
-static void sanity_check(void){
-  format_struct *fs = format_array;
-  while((fs->spec)[0] != '~'){
-    if(strlen(fs->head) > fs->width) printf("%d %s\n",strlen(fs->head),fs->spec);
-    fs++;
-  }
-}
-#endif
-
-
-void init_output(void){
-  int outbuf_pages;
-  char *outbuf;
-
-  switch(page_size){
-  case 65536: page_shift = 16; break;
-  case 32768: page_shift = 15; break;
-  case 16384: page_shift = 14; break;
-  case  8192: page_shift = 13; break;
-  default: fprintf(stderr, "Unknown page size! (assume 4096)\n");
-  case  4096: page_shift = 12; break;
-  case  2048: page_shift = 11; break;
-  case  1024: page_shift = 10; break;
-  }
-
-  // add page_size-1 to round up
-  outbuf_pages = (OUTBUF_SIZE+SPACE_AMOUNT+page_size-1)/page_size;
-  outbuf = mmap(
-    0,
-    page_size * (outbuf_pages+1), // 1 more, for guard page at high addresses
-    PROT_READ | PROT_WRITE,
-    MAP_PRIVATE | MAP_ANONYMOUS,
-    -1,
-    0
-  );
-  memset(outbuf, ' ', SPACE_AMOUNT);
-  if(SPACE_AMOUNT==page_size) mprotect(outbuf, page_size, PROT_READ);
-  mprotect(outbuf + page_size*outbuf_pages, page_size, PROT_NONE); // gaurd page
-  saved_outbuf = outbuf + SPACE_AMOUNT;
-  // available space:  page_size*outbuf_pages-SPACE_AMOUNT
-
-  seconds_since_1970 = time(NULL);
-
-  meminfo();
-
-  check_header_width();
-}
diff --git a/ps/parser.c b/ps/parser.c
deleted file mode 100644
index 70d94fe1..00000000
--- a/ps/parser.c
+++ /dev/null
@@ -1,1251 +0,0 @@
-/*
- * Copyright 1998-2003 by Albert Cahalan; all rights reserved.
- * This file may be used subject to the terms and conditions of the
- * GNU Library General Public License Version 2, or any later version
- * at your option, as published by the Free Software Foundation.
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Library General Public License for more details.
- */
-
-/* Ought to have debug print stuff like this:
- * #define Print(fmt, args...) printf("Debug: " fmt, ## args)
- */
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-
-/* username lookups */
-#include <sys/types.h>
-#include <pwd.h>
-#include <grp.h>
-
-#include <sys/stat.h>
-#include <unistd.h>
-
-#include "common.h"
-#include "../proc/version.h"
-
-#define ARG_GNU  0
-#define ARG_END  1
-#define ARG_PGRP 2
-#define ARG_SYSV 3
-#define ARG_PID  4
-#define ARG_BSD  5
-#define ARG_FAIL 6
-#define ARG_SESS 7
-
-static int w_count = 0;
-
-static int ps_argc;    /* global argc */
-static char **ps_argv; /* global argv */
-static int thisarg;    /* index into ps_argv */
-static char *flagptr;  /* current location in ps_argv[thisarg] */
-static int not_pure_unix = 0;  /* set by BSD and GNU options */
-static int force_bsd = 0;  /* set when normal parsing fails */
-
-#define exclusive(x) if((ps_argc != 2) || strcmp(ps_argv[1],x))\
-  return "The " x " option is exclusive."
-
-
-/********** utility functions **********/
-
-/*
- * Both "-Oppid" and "-O ppid" should be legal, though Unix98
- * does not require it. BSD and Digital Unix allow both.
- * Return the argument or NULL;
- */
-static const char *get_opt_arg(void){
-  if(*(flagptr+1)){     /* argument is part of ps_argv[thisarg] */
-    not_pure_unix = 1;
-    return flagptr+1;
-  }
-  if(thisarg+2 > ps_argc) return NULL;   /* there is nothing left */
-  /* argument follows ps_argv[thisarg] */
-  if(*(ps_argv[thisarg+1]) == '\0') return NULL;
-  return ps_argv[++thisarg];
-}
-
-/********** parse lists (of UID, tty, GID, PID...) **********/
-
-static const char *parse_pid(char *str, sel_union *ret){
-  char *endp;
-  unsigned long num;
-  static const char pidrange[]  = "Process ID out of range.";
-  static const char pidsyntax[] = "Process ID list syntax error.";
-  num = strtoul(str, &endp, 0);
-  if(*endp != '\0')      return pidsyntax;
-  if(num<1)              return pidrange;
-  if(num > 0x7fffffffUL) return pidrange;
-  ret->pid = num;
-  return 0;
-}
-
-static const char *parse_uid(char *str, sel_union *ret){
-  struct passwd *passwd_data;
-  char *endp;
-  unsigned long num;
-  static const char uidrange[] = "User ID out of range.";
-  static const char uidexist[] = "User name does not exist.";
-  num = strtoul(str, &endp, 0);
-  if(*endp != '\0'){  /* hmmm, try as login name */
-    passwd_data = getpwnam(str);
-    if(!passwd_data)    return uidexist;
-    num = passwd_data->pw_uid;
-  }
-  if(num > 0xfffffffeUL) return uidrange;
-  ret->uid = num;
-  return 0;
-}
-
-static const char *parse_gid(char *str, sel_union *ret){
-  struct group *group_data;
-  char *endp;
-  unsigned long num;
-  static const char gidrange[] = "Group ID out of range.";
-  static const char gidexist[] = "Group name does not exist.";
-  num = strtoul(str, &endp, 0);
-  if(*endp != '\0'){  /* hmmm, try as login name */
-    group_data = getgrnam(str);
-    if(!group_data)    return gidexist;
-    num = group_data->gr_gid;
-  }
-  if(num > 0xfffffffeUL) return gidrange;
-  ret->gid = num;
-  return 0;
-}
-
-static const char *parse_cmd(char *str, sel_union *ret){
-  strncpy(ret->cmd, str, sizeof ret->cmd);  // strncpy pads to end
-  ret->cmd[sizeof(ret->cmd)-1] = '\0';      // but let's be safe
-  return 0;
-}
-
-static const char *parse_tty(char *str, sel_union *ret){
-  struct stat sbuf;
-  static const char missing[] = "TTY could not be found.";
-  static const char not_tty[] = "List member was not a TTY.";
-  char path[4096];
-  if(str[0]=='/'){
-    if(stat(str, &sbuf) >= 0) goto found_it;
-    return missing;
-  }
-#define lookup(p) \
-  snprintf(path,4096,p,str); \
-  if(stat(path, &sbuf) >= 0) goto found_it
-
-  lookup("/dev/pts/%s");  /* New Unix98 ptys go first */
-  lookup("/dev/%s");
-  lookup("/dev/tty%s");
-  lookup("/dev/pty%s");
-  lookup("/dev/%snsole"); /* "co" means "console", maybe do all VCs too? */
-  if(!strcmp(str,"-")){   /* "-" means no tty (from AIX) */
-    ret->tty = 0;  /* processes w/o tty */
-    return 0;
-  }
-  if(!strcmp(str,"?")){   /* "?" means no tty, which bash eats (Reno BSD?) */
-    ret->tty = 0;  /* processes w/o tty */
-    return 0;
-  }
-  if(!*(str+1) && (stat(str,&sbuf)>=0)){  /* Kludge! Assume bash ate '?'. */
-    ret->tty = 0;  /* processes w/o tty */
-    return 0;
-  }
-#undef lookup
-  return missing;
-found_it:
-  if(!S_ISCHR(sbuf.st_mode)) return not_tty;
-  ret->tty = sbuf.st_rdev;
-  return 0;
-}
-
-/*
- * Used to parse lists in a generic way. (function pointers)
- */
-static const char *parse_list(const char *arg, const char *(*parse_fn)(char *, sel_union *) ){
-  selection_node *node;
-  char *buf;                      /* temp copy of arg to hack on */
-  char *sep_loc;                  /* separator location: " \t," */
-  char *walk;
-  int items;
-  int need_item;
-  const char *err;       /* error code that could or did happen */
-  /*** prepare to operate ***/
-  node = malloc(sizeof(selection_node));
-  node->u = malloc(strlen(arg)*sizeof(sel_union)); /* waste is insignificant */
-  node->n = 0;
-  buf = malloc(strlen(arg)+1);
-  strcpy(buf, arg);
-  /*** sanity check and count items ***/
-  need_item = 1; /* true */
-  items = 0;
-  walk = buf;
-  err = "Improper list.";
-  do{
-    switch(*walk){
-    case ' ': case ',': case '\t': case '\0':
-      if(need_item) goto parse_error;
-      need_item=1;
-      break;
-    default:
-      if(need_item) items++;
-      need_item=0;
-    }
-  } while (*++walk);
-  if(need_item) goto parse_error;
-  node->n = items;
-  /*** actually parse the list ***/
-  walk = buf;
-  while(items--){
-    sep_loc = strpbrk(walk," ,\t");
-    if(sep_loc) *sep_loc = '\0';
-    if(( err=(parse_fn)(walk, node->u+items) )) goto parse_error;
-    walk = sep_loc + 1; /* point to next item, if any */
-  }
-  free(buf);
-  node->next = selection_list;
-  selection_list = node;
-  return NULL;
-parse_error:
-  free(buf);
-  free(node->u);
-  free(node);
-  return err;
-}
-
-/***************** parse SysV options, including Unix98  *****************/
-static const char *parse_sysv_option(void){
-  const char *arg;
-  const char *err;
-
-  flagptr = ps_argv[thisarg];
-  while(*++flagptr){
-    // Find any excuse to ignore stupid Unix98 misfeatures.
-    //
-    // This list of options is ONLY for those defined by the
-    // "IEEE Std 1003.1, 2004 Edition", "ISO/IEC 9945:2003",
-    // or "Version 2 of the Single Unix Specification".
-    //
-    // It may be time to re-think the existance of this list.
-    // In the meantime, please do not add to it. The list is
-    // intended to ONLY contain flags defined by the POSIX and UNIX
-    // standards published by The Open Group, IEEE, and ISO.
-    if(!strchr("aAdefgGlnoptuU", *flagptr)) not_pure_unix = 1;  // dude, -Z ain't in POSIX
-
-    switch(*flagptr){
-    case 'A':
-      trace("-A selects all processes.\n");
-      all_processes = 1;
-      break;
-    case 'C': /* end */
-      trace("-C select by process name.\n");  /* Why only HP/UX and us? */
-      arg=get_opt_arg();
-      if(!arg) return "List of command names must follow -C.";
-      err=parse_list(arg, parse_cmd);
-      if(err) return err;
-      selection_list->typecode = SEL_COMM;
-      return NULL; /* can't have any more options */
-    case 'F':  /* DYNIX/ptx -f plus sz,rss,psr=ENG between c and stime */
-      trace("-F does fuller listing\n");
-      format_modifiers |= FM_F;
-      format_flags |= FF_Uf;
-      unix_f_option = 1; /* does this matter? */
-      break;
-    case 'G': /* end */
-      trace("-G select by RGID (supports names)\n");
-      arg=get_opt_arg();
-      if(!arg) return "List of real groups must follow -G.";
-      err=parse_list(arg, parse_gid);
-      if(err) return err;
-      selection_list->typecode = SEL_RGID;
-      return NULL; /* can't have any more options */
-    case 'H':     /* another nice HP/UX feature */
-      trace("-H Process hierarchy (like ASCII art forest option)\n");
-      forest_type = 'u';
-      break;
-#if 0
-    case 'J':  // specify list of job IDs in hex (IRIX) -- like HP "-R" maybe?
-      trace("-J select by job ID\n");  // want a JID ("jid") for "-j" too
-      arg=get_opt_arg();
-      if(!arg) return "List of jobs must follow -J.";
-      err=parse_list(arg, parse_jid);
-      if(err) return err;
-      selection_list->typecode = SEL_JID;
-      return NULL; /* can't have any more options */
-#endif
-    case 'L':  /*  */
-      /* In spite of the insane 2-level thread system, Sun appears to
-       * have made this option Linux-compatible. If a process has N
-       * threads, ps will produce N lines of output. (not N+1 lines)
-       * Zombies are the only exception, with NLWP==0 and 1 output line.
-       * SCO UnixWare uses -L too.
-       */
-      trace("-L Print LWP (thread) info.\n");
-      thread_flags |= TF_U_L;
-//      format_modifiers |= FM_L;
-      break;
-    case 'M':  // typically the SE Linux context
-      trace("-M Print security label for Mandatory Access Control.\n");
-      format_modifiers |= FM_M;
-      break;
-    case 'N':
-      trace("-N negates.\n");
-      negate_selection = 1;
-      break;
-    case 'O': /* end */
-      trace("-O is preloaded -o.\n");
-      arg=get_opt_arg();
-      if(!arg) return "Format or sort specification must follow -O.";
-      defer_sf_option(arg, SF_U_O);
-      return NULL; /* can't have any more options */
-    case 'P':     /* SunOS 5 "psr" or unknown HP/UX feature */
-      trace("-P adds columns of PRM info (HP-UX), PSR (SunOS), or capabilities (IRIX)\n");
-      format_modifiers |= FM_P;
-      break;
-#if 0
-    case 'R':    // unknown HP/UX feature, like IRIX "-J" maybe?
-      trace("-R select by PRM group\n");
-      arg=get_opt_arg();
-      if(!arg) return "List of PRM groups must follow -R.";
-      err=parse_list(arg, parse_prm);
-      if(err) return err;
-      selection_list->typecode = SEL_PRM;
-      return NULL; /* can't have any more options */
-#endif
-    case 'T':
-      /* IRIX 6.5 docs suggest POSIX threads get shown individually.
-       * This would make -T be like -L, -m, and m. (but an extra column)
-       * Testing (w/ normal processes) shows 1 line/process, not 2.
-       * Also, testing shows PID==SPID for all normal processes.
-       */
-      trace("-T adds strange SPID column (old sproc() threads?)\n");
-      thread_flags |= TF_U_T;
-//      format_modifiers |= FM_T;
-      break;
-    case 'U': /* end */
-      trace("-U select by RUID (supports names).\n");
-      arg=get_opt_arg();
-      if(!arg) return "List of real groups must follow -U.";
-      err=parse_list(arg, parse_uid);
-      if(err) return err;
-      selection_list->typecode = SEL_RUID;
-      return NULL; /* can't have any more options */
-    case 'V': /* single */
-      trace("-V prints version.\n");
-      exclusive("-V");
-      display_version();
-      exit(0);
-    // This must be verified against SVR4-MP. (UnixWare or Powermax)
-    // Leave it undocumented until that problem is solved.
-    case 'Z':     /* full Mandatory Access Control level info */
-      trace("-Z shows full MAC info\n");
-      format_modifiers |= FM_M;
-      break;
-    case 'a':
-      trace("-a select all with a tty, but omit session leaders.\n");
-      simple_select |= SS_U_a;
-      break;
-    case 'c':
-      /* HP-UX and SunOS 5 scheduling info modifier */
-      trace("-c changes scheduling info.\n");
-      format_modifiers |= FM_c;
-      break;
-    case 'd':
-      trace("-d select all, but omit session leaders.\n");
-      simple_select |= SS_U_d;
-      break;
-    case 'e':
-      trace("-e selects all processes.\n");
-      all_processes = 1;
-      break;
-    case 'f':
-      trace("-f does full listing\n");
-      format_flags |= FF_Uf;
-      unix_f_option = 1; /* does this matter? */
-      break;
-    case 'g': /* end */
-      trace("-g selects by session leader OR by group name\n");
-      arg=get_opt_arg();
-      if(!arg) return "List of session leaders OR effective group names must follow -g.";
-      err=parse_list(arg, parse_pid);
-      if(!err){
-        selection_list->typecode = SEL_SESS;
-        return NULL; /* can't have any more options */
-      }
-      err=parse_list(arg, parse_gid);
-      if(!err){
-        selection_list->typecode = SEL_EGID;
-        return NULL; /* can't have any more options */
-      }
-      return "List of session leaders OR effective group IDs was invalid.";
-    case 'j':
-      trace("-j jobs format.\n");
-      /* old Debian used RD_j and Digital uses JFMT */
-      if(sysv_j_format) format_flags |= FF_Uj;
-      else format_modifiers |= FM_j;
-      break;
-    case 'l':
-      trace("-l long format.\n");
-      format_flags |= FF_Ul;
-      break;
-    case 'm':
-      trace("-m shows threads.\n");
-      /* note that AIX shows 2 lines for a normal process */
-      thread_flags |= TF_U_m;
-      break;
-    case 'n': /* end */
-      trace("-n sets namelist file.\n");
-      arg=get_opt_arg();
-      if(!arg) return "Alternate System.map file must follow -n.";
-      namelist_file = arg;
-      return NULL; /* can't have any more options */
-    case 'o': /* end */
-      /* Unix98 has gross behavior regarding this. From the following: */
-      /*            ps -o pid,nice=NICE,tty=TERMINAL,comm              */
-      /* The result must be 2 columns: "PID NICE,tty=TERMINAL,comm"    */
-      /* Yes, the second column has the name "NICE,tty=TERMINAL,comm"  */
-      /* This parser looks for any excuse to ignore that braindamage.  */
-      trace("-o user-defined format.\n");
-      arg=get_opt_arg();
-      if(!arg) return "Format specification must follow -o.";
-      not_pure_unix |= defer_sf_option(arg, SF_U_o);
-      return NULL; /* can't have any more options */
-    case 'p': /* end */
-      trace("-p select by PID.\n");
-      arg=get_opt_arg();
-      if(!arg) return "List of process IDs must follow -p.";
-      err=parse_list(arg, parse_pid);
-      if(err) return err;
-      selection_list->typecode = SEL_PID;
-      return NULL; /* can't have any more options */
-#if 0
-    case 'r':
-      trace("-r some Digital Unix thing about warnings...\n");
-      trace("   or SCO's option to chroot() for new /proc and /dev.\n");
-      return "The -r option is reserved.";
-      break;
-#endif
-    case 's': /* end */
-      trace("-s Select processes belonging to the sessions given.\n");
-      arg=get_opt_arg();
-      if(!arg) return "List of session IDs must follow -s.";
-      err=parse_list(arg, parse_pid);
-      if(err) return err;
-      selection_list->typecode = SEL_SESS;
-      return NULL; /* can't have any more options */
-    case 't': /* end */
-      trace("-t select by tty.\n");
-      arg=get_opt_arg();
-      if(!arg) return "List of terminals (pty, tty...) must follow -t.";
-      err=parse_list(arg, parse_tty);
-      if(err) return err;
-      selection_list->typecode = SEL_TTY;
-      return NULL; /* can't have any more options */
-    case 'u': /* end */
-      trace("-u select by user ID (the EUID?) (supports names).\n");
-      arg=get_opt_arg();
-      if(!arg) return "List of users must follow -u.";
-      err=parse_list(arg, parse_uid);
-      if(err) return err;
-      selection_list->typecode = SEL_EUID;
-      return NULL; /* can't have any more options */
-    case 'w':
-      trace("-w wide output.\n");
-      w_count++;
-      break;
-    case 'x':  /* behind personality until "ps -ax" habit is uncommon */
-      if(personality & PER_SVR4_x){
-        // Same as -y, but for System V Release 4 MP
-        trace("-x works like Sun Solaris & SCO Unixware -y option\n");
-        format_modifiers |= FM_y;
-        break;
-      }
-      if(personality & PER_HPUX_x){
-        trace("-x extends the command line\n");
-        w_count += 2;
-        unix_f_option = 1;
-        break;
-      }
-      return "Must set personality to get -x option.";
-    case 'y':  /* Sun's -l hack (also: Irix "lnode" resource control info) */
-      trace("-y Print lnone info in UID/USER column or do Sun -l hack.\n");
-      format_modifiers |= FM_y;
-      break;
-#if 0
-    // This must be verified against SVR4-MP (UnixWare or Powermax)
-    case 'z':     /* alias of Mandatory Access Control level info */
-      trace("-z shows aliased MAC info\n");
-      format_modifiers |= FM_M;
-      break;
-    // Solaris 10 does this
-    case 'z':     /* select by zone */
-      trace("-z secects by zone\n");
-      arg=get_opt_arg();
-      if(!arg) return "List of zones (contexts, labels, whatever?) must follow -z.";
-      err=parse_list(arg, parse_zone);
-      if(err) return err;
-      selection_list->typecode = SEL_ZONE;
-      return NULL; /* can't have any more options */
-#endif
-    case '-':
-      return "Embedded '-' among SysV options makes no sense.";
-      break;
-    case '\0':
-      return "Please report the \"SysV \\0 can't happen\" bug.";
-      break;
-    default:
-      return "Unsupported SysV option.";
-    } /* switch */
-  } /* while */
-  return NULL;
-}
-
-/************************* parse BSD options **********************/
-static const char *parse_bsd_option(void){
-  const char *arg;
-  const char *err;
-
-  flagptr = ps_argv[thisarg];  /* assume we _have_ a '-' */
-  if(flagptr[0]=='-'){
-    if(!force_bsd) return "Can't happen!  Problem #1.";
-  }else{
-    flagptr--; /* off beginning, will increment before use */
-    if(personality & PER_FORCE_BSD){
-      if(!force_bsd) return "Can't happen!  Problem #2.";
-    }else{
-      if(force_bsd) return "2nd chance parse failed, not BSD or SysV.";
-    }
-  }
-
-  while(*++flagptr){
-    switch(*flagptr){
-    case '0' ... '9': /* end */
-      trace("0..9  Old BSD-style select by process ID\n");
-      arg=flagptr;
-      err=parse_list(arg, parse_pid);
-      if(err) return err;
-      selection_list->typecode = SEL_PID;
-      return NULL; /* can't have any more options */
-#if 0
-    case 'A':
-      /* maybe this just does a larger malloc() ? */
-      trace("A Increases the argument space (Digital Unix)\n");
-      return "Option A is reserved.";
-      break;
-    case 'C':
-      /* should divide result by 1-(e**(foo*log(bar))) */
-      trace("C Use raw CPU time for %%CPU instead of decaying ave\n");
-      return "Option C is reserved.";
-      break;
-#endif
-    case 'H':    // The FreeBSD way (NetBSD:s OpenBSD:k FreeBSD:H  -- NIH???)
-      trace("H Print LWP (thread) info.\n");   // was: Use /vmcore as c-dumpfile\n");
-      thread_flags |= TF_B_H;
-      //format_modifiers |= FM_L;    // FIXME: determine if we need something like this
-      break;
-    case 'L': /* single */
-      trace("L List all format specifiers\n");
-      exclusive("L");
-      print_format_specifiers();
-      exit(0);
-    case 'M':   // undocumented for now: these are proliferating!
-      trace("M MacOS X thread display, like AIX/Tru64\n");
-      thread_flags |= TF_B_m;
-      break;
-    case 'N': /* end */
-      trace("N Specify namelist file\n");
-      arg=get_opt_arg();
-      if(!arg) return "Alternate System.map file must follow N.";
-      namelist_file = arg;
-      return NULL; /* can't have any more options */
-    case 'O': /* end */
-      trace("O Like o + defaults, add new columns after PID. Also sort.\n");
-      arg=get_opt_arg();
-      if(!arg) return "Format or sort specification must follow O.";
-      defer_sf_option(arg, SF_B_O);
-      return NULL; /* can't have any more options */
-      break;
-    case 'S':
-      trace("S include dead kids in sum\n");
-      include_dead_children = 1;
-      break;
-    case 'T':
-      trace("T Select all processes on this terminal\n");
-      /* put our tty on a tiny list */
-      {
-        selection_node *node;
-        node = malloc(sizeof(selection_node));
-        node->u = malloc(sizeof(sel_union));
-        node->u[0].tty = cached_tty;
-        node->typecode = SEL_TTY;
-        node->n = 1;
-        node->next = selection_list;
-        selection_list = node;
-      }
-      break;
-    case 'U': /* end */
-      trace("U Select processes for specified users.\n");
-      arg=get_opt_arg();
-      if(!arg) return "List of users must follow U.";
-      err=parse_list(arg, parse_uid);
-      if(err) return err;
-      selection_list->typecode = SEL_EUID;
-      return NULL; /* can't have any more options */
-    case 'V': /* single */
-      trace("V show version info\n");
-      exclusive("V");
-      display_version();
-      exit(0);
-    case 'W':
-      trace("W N/A get swap info from ... not /dev/drum.\n");
-      return "Obsolete W option not supported. (You have a /dev/drum?)";
-      break;
-    case 'X':
-      trace("X Old Linux i386 register format\n");
-      format_flags |= FF_LX;
-      break;
-    case 'Z':  /* FreeBSD does MAC like SGI's Irix does it */
-      trace("Z Print security label for Mandatory Access Control.\n");
-      format_modifiers |= FM_M;
-      break;
-    case 'a':
-      trace("a Select all w/tty, including other users\n");
-      simple_select |= SS_B_a;
-      break;
-    case 'c':
-      trace("c true command name\n");
-      bsd_c_option = 1;
-      break;
-//  case 'd':
-//    trace("d FreeBSD-style tree\n");
-//    forest_type = 'f';
-//    break;
-    case 'e':
-      trace("e environment\n");
-      bsd_e_option = 1;
-      break;
-    case 'f':
-      trace("f ASCII art forest\n");
-      forest_type = 'b';
-      break;
-    case 'g':
-      trace("g _all_, even group leaders!.\n");
-      simple_select |= SS_B_g;
-      break;
-    case 'h':
-      trace("h Repeat header... yow.\n");
-      if(header_type) return "Only one heading option may be specified.";
-      if(personality & PER_BSD_h) header_type = HEAD_MULTI;
-      else                        header_type = HEAD_NONE;
-      break;
-    case 'j':
-      trace("j job control format\n");
-      format_flags |= FF_Bj;
-      break;
-    case 'k':
-      // OpenBSD: don't hide "kernel threads" -- like the swapper?
-      // trace("k Print LWP (thread) info.\n");   // was: Use /vmcore as c-dumpfile\n");
-
-      // NetBSD, and soon (?) FreeBSD: sort-by-keyword
-      trace("k Specify sorting keywords.\n");
-      arg=get_opt_arg();
-      if(!arg) return "Long sort specification must follow 'k'.";
-      defer_sf_option(arg, SF_G_sort);
-      return NULL; /* can't have any more options */
-    case 'l':
-      trace("l Display long format\n");
-      format_flags |= FF_Bl;
-      break;
-    case 'm':
-      trace("m all threads, sort on mem use, show mem info\n");
-      if(personality & PER_OLD_m){
-        format_flags |= FF_Lm;
-        break;
-      }
-      if(personality & PER_BSD_m){
-        defer_sf_option("pmem", SF_B_m);
-        break;
-      }
-      thread_flags |= TF_B_m;
-      break;
-    case 'n':
-      trace("n Numeric output for WCHAN, and USER replaced by UID\n");
-      wchan_is_number = 1;
-      user_is_number = 1;
-      /* TODO add tty_is_number too? */
-      break;
-    case 'o': /* end */
-      trace("o Specify user-defined format\n");
-      arg=get_opt_arg();
-      if(!arg) return "Format specification must follow o.";
-      defer_sf_option(arg, SF_B_o);
-      return NULL; /* can't have any more options */
-    case 'p': /* end */
-      trace("p Select by process ID\n");
-      arg=get_opt_arg();
-      if(!arg) return "List of process IDs must follow p.";
-      err=parse_list(arg, parse_pid);
-      if(err) return err;
-      selection_list->typecode = SEL_PID;
-      return NULL; /* can't have any more options */
-    case 'r':
-      trace("r Select running processes\n");
-      running_only = 1;
-      break;
-    case 's':
-      trace("s Display signal format\n");
-      format_flags |= FF_Bs;
-      break;
-    case 't': /* end */
-      trace("t Select by tty.\n");
-      /* List of terminals (tty, pty...) _should_ follow t. */
-      arg=get_opt_arg();
-      if(!arg){
-        /* Wow, obsolete BSD syntax. Put our tty on a tiny list. */
-        selection_node *node;
-        node = malloc(sizeof(selection_node));
-        node->u = malloc(sizeof(sel_union));
-        node->u[0].tty = cached_tty;
-        node->typecode = SEL_TTY;
-        node->n = 1;
-        node->next = selection_list;
-        selection_list = node;
-        return NULL;
-      }
-      err=parse_list(arg, parse_tty);
-      if(err) return err;
-      selection_list->typecode = SEL_TTY;
-      return NULL; /* can't have any more options */
-    case 'u':
-      trace("u Display user-oriented\n");
-      format_flags |= FF_Bu;
-      break;
-    case 'v':
-      trace("v Display virtual memory\n");
-      format_flags |= FF_Bv;
-      break;
-    case 'w':
-      trace("w wide output\n");
-      w_count++;
-      break;
-    case 'x':
-      trace("x Select processes without controlling ttys\n");
-      simple_select |= SS_B_x;
-      break;
-    case '-':
-      return "Embedded '-' among BSD options makes no sense.";
-      break;
-    case '\0':
-      return "Please report the \"BSD \\0 can't happen\" bug.";
-      break;
-    default:
-      return "Unsupported option (BSD syntax)";
-    } /* switch */
-  } /* while */
-  return NULL;
-}
-
-/*************** gnu long options **********************/
-
-/*
- * Return the argument or NULL
- */
-static const char *grab_gnu_arg(void){
-  switch(*flagptr){     /* argument is part of ps_argv[thisarg] */
-  default:
-    return NULL;                     /* something bad */
-  case '=': case ':':
-    if(*++flagptr) return flagptr;   /* found it */
-    return NULL;                     /* empty '=' or ':' */
-  case '\0': /* try next argv[] */
-    ;
-  }
-  if(thisarg+2 > ps_argc) return NULL;   /* there is nothing left */
-  /* argument follows ps_argv[thisarg] */
-  if(*(ps_argv[thisarg+1]) == '\0') return NULL;
-  return ps_argv[++thisarg];
-}
-
-typedef struct gnu_table_struct {
-  const char *name; /* long option name */
-  const void *jump; /* See gcc extension info.   :-)   */
-} gnu_table_struct;
-
-static int compare_gnu_table_structs(const void *a, const void *b){
-  return strcmp(((const gnu_table_struct*)a)->name,((const gnu_table_struct*)b)->name);
-}
-
-/* Option arguments are after ':', after '=', or in argv[n+1] */
-static const char *parse_gnu_option(void){
-  const char *arg;
-  const char *err;
-  char *s;
-  size_t sl;
-  char buf[16];
-  gnu_table_struct findme = { buf, NULL};
-  gnu_table_struct *found;
-  static const gnu_table_struct gnu_table[] = {
-  {"Group",         &&case_Group},       /* rgid */
-  {"User",          &&case_User},        /* ruid */
-  {"cols",          &&case_cols},
-  {"columns",       &&case_columns},
-  {"context",       &&case_context},
-  {"cumulative",    &&case_cumulative},
-  {"deselect",      &&case_deselect},    /* -N */
-  {"forest",        &&case_forest},      /* f -H */
-  {"format",        &&case_format},
-  {"group",         &&case_group},       /* egid */
-  {"header",        &&case_header},
-  {"headers",       &&case_headers},
-  {"heading",       &&case_heading},
-  {"headings",      &&case_headings},
-  {"help",          &&case_help},
-  {"info",          &&case_info},
-  {"lines",         &&case_lines},
-  {"no-header",     &&case_no_header},
-  {"no-headers",    &&case_no_headers},
-  {"no-heading",    &&case_no_heading},
-  {"no-headings",   &&case_no_headings},
-  {"noheader",      &&case_noheader},
-  {"noheaders",     &&case_noheaders},
-  {"noheading",     &&case_noheading},
-  {"noheadings",    &&case_noheadings},
-  {"pid",           &&case_pid},
-  {"ppid",          &&case_ppid},
-  {"rows",          &&case_rows},
-  {"sid",           &&case_sid},
-  {"sort",          &&case_sort},
-  {"tty",           &&case_tty},
-  {"user",          &&case_user},        /* euid */
-  {"version",       &&case_version},
-  {"width",         &&case_width},
-  };
-  const int gnu_table_count = sizeof(gnu_table)/sizeof(gnu_table_struct);
-
-  s = ps_argv[thisarg]+2;
-  sl = strcspn(s,":=");
-  if(sl > 15) return "Unknown gnu long option.";
-  strncpy(buf, s, sl);
-  buf[sl] = '\0';
-  flagptr = s+sl;
-
-  found = bsearch(&findme, gnu_table, gnu_table_count,
-      sizeof(gnu_table_struct), compare_gnu_table_structs
-  );
-
-  if(!found) return "Unknown gnu long option.";
-
-  goto *(found->jump);    /* See gcc extension info.  :-)   */
-
-  case_Group:
-    trace("--Group\n");
-    arg = grab_gnu_arg();
-    if(!arg) return "List of real groups must follow --Group.";
-    err=parse_list(arg, parse_gid);
-    if(err) return err;
-    selection_list->typecode = SEL_RGID;
-    return NULL;
-  case_User:
-    trace("--User\n");
-    arg = grab_gnu_arg();
-    if(!arg) return "List of real users must follow --User.";
-    err=parse_list(arg, parse_uid);
-    if(err) return err;
-    selection_list->typecode = SEL_RUID;
-    return NULL;
-  case_cols:
-  case_width:
-  case_columns:
-    trace("--cols\n");
-    arg = grab_gnu_arg();
-    if(arg && *arg){
-      long t;
-      char *endptr;
-      t = strtol(arg, &endptr, 0);
-      if(!*endptr && (t>0) && (t<2000000000)){
-        screen_cols = (int)t;
-        return NULL;
-      }
-    }
-    return "Number of columns must follow --cols, --width, or --columns.";
-  case_cumulative:
-    trace("--cumulative\n");
-    if(s[sl]) return "Option --cumulative does not take an argument.";
-    include_dead_children = 1;
-    return NULL;
-  case_deselect:
-    trace("--deselect\n");
-    if(s[sl]) return "Option --deselect does not take an argument.";
-    negate_selection = 1;
-    return NULL;
-  case_no_header:
-  case_no_headers:
-  case_no_heading:
-  case_no_headings:
-  case_noheader:
-  case_noheaders:
-  case_noheading:
-  case_noheadings:
-    trace("--noheaders\n");
-    if(s[sl]) return "Option --no-heading does not take an argument.";
-    if(header_type) return "Only one heading option may be specified.";
-    header_type = HEAD_NONE;
-    return NULL;
-  case_header:
-  case_headers:
-  case_heading:
-  case_headings:
-    trace("--headers\n");
-    if(s[sl]) return "Option --heading does not take an argument.";
-    if(header_type) return "Only one heading option may be specified.";
-    header_type = HEAD_MULTI;
-    return NULL;
-  case_forest:
-    trace("--forest\n");
-    if(s[sl]) return "Option --forest does not take an argument.";
-    forest_type = 'g';
-    return NULL;
-  case_format:
-    trace("--format\n");
-    arg=grab_gnu_arg();
-    if(!arg) return "Format specification must follow --format.";
-    defer_sf_option(arg, SF_G_format);
-    return NULL;
-  case_group:
-    trace("--group\n");
-    arg = grab_gnu_arg();
-    if(!arg) return "List of effective groups must follow --group.";
-    err=parse_list(arg, parse_gid);
-    if(err) return err;
-    selection_list->typecode = SEL_EGID;
-    return NULL;
-  case_help:
-    trace("--help\n");
-    exclusive("--help");
-    fwrite(help_message,1,strlen(help_message),stdout);
-    exit(0);
-    return NULL;
-  case_info:
-    trace("--info\n");
-    exclusive("--info");
-    self_info();
-    exit(0);
-    return NULL;
-  case_pid:
-    trace("--pid\n");
-    arg = grab_gnu_arg();
-    if(!arg) return "List of process IDs must follow --pid.";
-    err=parse_list(arg, parse_pid);
-    if(err) return err;
-    selection_list->typecode = SEL_PID;
-    return NULL;
-  case_ppid:
-    trace("--ppid\n");
-    arg = grab_gnu_arg();
-    if(!arg) return "List of process IDs must follow --ppid.";
-    err=parse_list(arg, parse_pid);
-    if(err) return err;
-    selection_list->typecode = SEL_PPID;
-    return NULL;
-  case_rows:
-  case_lines:
-    trace("--rows\n");
-    arg = grab_gnu_arg();
-    if(arg && *arg){
-      long t;
-      char *endptr;
-      t = strtol(arg, &endptr, 0);
-      if(!*endptr && (t>0) && (t<2000000000)){
-        screen_rows = (int)t;
-        return NULL;
-      }
-    }
-    return "Number of rows must follow --rows or --lines.";
-  case_sid:
-    trace("--sid\n");
-    arg = grab_gnu_arg();
-    if(!arg) return "Some sid thing(s) must follow --sid.";
-    err=parse_list(arg, parse_pid);
-    if(err) return err;
-    selection_list->typecode = SEL_SESS;
-    return NULL;
-  case_sort:
-    trace("--sort\n");
-    arg=grab_gnu_arg();
-    if(!arg) return "Long sort specification must follow --sort.";
-    defer_sf_option(arg, SF_G_sort);
-    return NULL;
-  case_tty:
-    trace("--tty\n");
-    arg = grab_gnu_arg();
-    if(!arg) return "List of ttys must follow --tty.";
-    err=parse_list(arg, parse_tty);
-    if(err) return err;
-    selection_list->typecode = SEL_TTY;
-    return NULL;
-  case_user:
-    trace("--user\n");
-    arg = grab_gnu_arg();
-    if(!arg) return "List of effective users must follow --user.";
-    err=parse_list(arg, parse_uid);
-    if(err) return err;
-    selection_list->typecode = SEL_EUID;
-    return NULL;
-  case_version:
-    trace("--version\n");
-    exclusive("--version");
-    display_version();
-    exit(0);
-    return NULL;
-  case_context:
-    trace("--context\n");
-    format_flags |= FF_Fc;
-    return NULL;
-}
-
-/*************** process trailing PIDs  **********************/
-static const char *parse_trailing_pids(void){
-  selection_node *pidnode;  /* pid */
-  selection_node *grpnode;  /* process group */
-  selection_node *sidnode;  /* session */
-  char **argp;     /* pointer to pointer to text of PID */
-  const char *err;       /* error code that could or did happen */
-  int i;
-
-  i = ps_argc - thisarg;  /* how many trailing PIDs, SIDs, PGRPs?? */
-  argp = ps_argv + thisarg;
-  thisarg = ps_argc - 1;   /* we must be at the end now */
-
-  pidnode = malloc(sizeof(selection_node));
-  pidnode->u = malloc(i*sizeof(sel_union)); /* waste is insignificant */
-  pidnode->n = 0;
-
-  grpnode = malloc(sizeof(selection_node));
-  grpnode->u = malloc(i*sizeof(sel_union)); /* waste is insignificant */
-  grpnode->n = 0;
-
-  sidnode = malloc(sizeof(selection_node));
-  sidnode->u = malloc(i*sizeof(sel_union)); /* waste is insignificant */
-  sidnode->n = 0;
-
-  while(i--){
-    char *data;
-    data = *(argp++);
-    switch(*data){
-    default:   err = parse_pid(  data, pidnode->u + pidnode->n++); break;
-    case '-':  err = parse_pid(++data, grpnode->u + grpnode->n++); break;
-    case '+':  err = parse_pid(++data, sidnode->u + sidnode->n++); break;
-    }
-    if(err) return err;     /* the node gets freed with the list */
-  }
-
-  if(pidnode->n){
-    pidnode->next = selection_list;
-    selection_list = pidnode;
-    selection_list->typecode = SEL_PID;
-  }  /* else free both parts */
-
-  if(grpnode->n){
-    grpnode->next = selection_list;
-    selection_list = grpnode;
-    selection_list->typecode = SEL_PGRP;
-  }  /* else free both parts */
-
-  if(sidnode->n){
-    sidnode->next = selection_list;
-    selection_list = sidnode;
-    selection_list->typecode = SEL_SESS;
-  }  /* else free both parts */
-
-  return NULL;
-}
-
-/************** misc stuff ***********/
-
-static void reset_parser(void){
-  w_count = 0;
-}
-
-static int arg_type(const char *str){
-  int tmp = str[0];
-  if((tmp>='a') && (tmp<='z'))   return ARG_BSD;
-  if((tmp>='A') && (tmp<='Z'))   return ARG_BSD;
-  if((tmp>='0') && (tmp<='9'))   return ARG_PID;
-  if(tmp=='+')                   return ARG_SESS;
-  if(tmp!='-')                   return ARG_FAIL;
-  tmp = str[1];
-  if((tmp>='a') && (tmp<='z'))   return ARG_SYSV;
-  if((tmp>='A') && (tmp<='Z'))   return ARG_SYSV;
-  if((tmp>='0') && (tmp<='9'))   return ARG_PGRP;
-  if(tmp!='-')                   return ARG_FAIL;
-  tmp = str[2];
-  if((tmp>='a') && (tmp<='z'))   return ARG_GNU;
-  if((tmp>='A') && (tmp<='Z'))   return ARG_GNU;
-  if(tmp=='\0')                  return ARG_END;
-                                 return ARG_FAIL;
-}
-
-/* First assume sysv, because that is the POSIX and Unix98 standard. */
-static const char *parse_all_options(void){
-  const char *err = NULL;
-  int at;
-  while(++thisarg < ps_argc){
-  trace("parse_all_options calling arg_type for \"%s\"\n", ps_argv[thisarg]);
-    at = arg_type(ps_argv[thisarg]);
-    trace("ps_argv[thisarg] is %s\n", ps_argv[thisarg]);
-    if(at != ARG_SYSV) not_pure_unix = 1;
-    switch(at){
-    case ARG_GNU:
-      err = parse_gnu_option();
-      break;
-    case ARG_SYSV:
-      if(!force_bsd){   /* else go past case ARG_BSD */
-        err = parse_sysv_option();
-        break;
-    case ARG_BSD:
-        if(force_bsd && !(personality & PER_FORCE_BSD)) return "way bad";
-      }
-      prefer_bsd_defaults = 1;
-      err = parse_bsd_option();
-      break;
-    case ARG_PGRP:
-    case ARG_SESS:
-    case ARG_PID:
-      prefer_bsd_defaults = 1;
-      err = parse_trailing_pids();
-      break;
-    case ARG_END:
-    case ARG_FAIL:
-      trace("              FAIL/END on [%s]\n",ps_argv[thisarg]);
-      return "Garbage option.";
-      break;
-    default:
-      printf("                  ?    %s\n",ps_argv[thisarg]);
-      return "Something broke.";
-    } /* switch */
-    if(err) return err;
-  } /* while */
-  return NULL;
-}
-
-static void choose_dimensions(void){
-  if(w_count && (screen_cols<132)) screen_cols=132;
-  if(w_count>1) screen_cols=OUTBUF_SIZE;
-  /* perhaps --html and --null should set unlimited width */
-}
-
-static const char *thread_option_check(void){
-  if(!thread_flags){
-    thread_flags = TF_show_proc;
-    return NULL;
-  }
-
-  if(forest_type){
-    return "Thread display conflicts with forest display.";
-  }
-  //thread_flags |= TF_no_forest;
-
-  if((thread_flags&TF_B_H) && (thread_flags&(TF_B_m|TF_U_m)))
-    return "Thread flags conflict; can't use H with m or -m.";
-  if((thread_flags&TF_B_m) && (thread_flags&TF_U_m))
-    return "Thread flags conflict; can't use both m and -m.";
-  if((thread_flags&TF_U_L) && (thread_flags&TF_U_T))
-    return "Thread flags conflict; can't use both -L and -T.";
-
-  if(thread_flags&TF_B_H) thread_flags |= (TF_show_proc|TF_loose_tasks);
-  if(thread_flags&(TF_B_m|TF_U_m)) thread_flags |= (TF_show_proc|TF_show_task|TF_show_both);
-
-  if(thread_flags&(TF_U_T|TF_U_L)){
-    if(thread_flags&(TF_B_m|TF_U_m|TF_B_H)){
-      // Got a thread style, so format modification is a requirement?
-      // Maybe -T/-L has H thread style though. (sorting interaction?)
-      //return "Huh? Tell procps@freelists.org what you expected.";
-      thread_flags |= TF_must_use;
-    }else{
-      // using -L/-T thread style, so format from elsewhere is OK
-      thread_flags |= TF_show_task;  // or like the H option?
-      //thread_flags |= TF_no_sort;
-    }
-  }
-
-  return NULL;
-}
-
-int arg_parse(int argc, char *argv[]){
-  const char *err = NULL;
-  const char *err2 = NULL;
-  ps_argc = argc;
-  ps_argv = argv;
-  thisarg = 0;
-
-  if(personality & PER_FORCE_BSD) goto try_bsd;
-
-  err = parse_all_options();
-  if(err) goto try_bsd;
-  err = thread_option_check();
-  if(err) goto try_bsd;
-  err = process_sf_options(!not_pure_unix);
-  if(err) goto try_bsd;
-  err = select_bits_setup();
-  if(err) goto try_bsd;
-
-  choose_dimensions();
-  return 0;
-
-try_bsd:
-  trace("--------- now try BSD ------\n");
-
-  reset_global();
-  reset_parser();
-  reset_sortformat();
-  format_flags = 0;
-  ps_argc = argc;
-  ps_argv = argv;
-  thisarg = 0;
-  /* no need to reset flagptr */
-  not_pure_unix=1;
-  force_bsd=1;
-  prefer_bsd_defaults=1;
-  if(!( (PER_OLD_m|PER_BSD_m) & personality )) /* if default m setting... */
-    personality |= PER_OLD_m; /* Prefer old Linux over true BSD. */
-  /* Do not set PER_FORCE_BSD! It is tested below. */
-
-  err2 = parse_all_options();
-  if(err2) goto total_failure;
-  err2 = thread_option_check();
-  if(err2) goto total_failure;
-  err2 = process_sf_options(!not_pure_unix);
-  if(err2) goto total_failure;
-  err2 = select_bits_setup();
-  if(err2) goto total_failure;
-
-  // Feel a need to patch this out? First of all, read the FAQ.
-  // Second of all, talk to me. Without this warning, people can
-  // get seriously confused. Ask yourself if users would freak out
-  // about "ps -aux" suddenly changing behavior if a user "x" were
-  // added to the system.
-  //
-  // Also, a "-x" option is coming. It's already there in fact,
-  // for some non-default personalities. So "ps -ax" will parse
-  // as SysV options... and you're screwed if you've been patching
-  // out the friendly warning. Cut-over is likely to be in 2005.
-  if(!(personality & PER_FORCE_BSD))
-    fprintf(stderr, "Warning: bad ps syntax, perhaps a bogus '-'? See http://procps.sf.net/faq.html\n");
-  // Remember: contact procps@freelists.org
-  // if you should feel tempted. Be damn sure you understand all
-  // the issues. The same goes for other stuff too, BTW. Please ask.
-  // I'm happy to justify various implementation choices.
-
-  choose_dimensions();
-  return 0;
-
-total_failure:
-  reset_parser();
-  if(personality & PER_FORCE_BSD) fprintf(stderr, "ERROR: %s\n", err2);
-  else fprintf(stderr, "ERROR: %s\n", err);
-  fwrite(help_message,1,strlen(help_message),stderr);
-  exit(1);
-  /* return 1; */ /* useless */
-}
diff --git a/ps/ps.1 b/ps/ps.1
deleted file mode 100644
index 1fd6e094..00000000
--- a/ps/ps.1
+++ /dev/null
@@ -1,1569 +0,0 @@
-'\" t
-.\" (The preceding line is a note to broken versions of man to tell
-.\" Man page for ps.
-.\" Quick hack conversion by Albert Cahalan, 1998.
-.\" Licensed under version 2 of the Gnu General Public License.
-.\"
-.TH PS 1 "February 25, 2010" "Linux" "Linux User's Manual"
-.\"
-.\" To render this page:
-.\"    groff -t -b -man -X -P-resolution -P100 -Tps ps.1 &
-.\"    groff -t -b -man -X -TX100 ps.1 &
-.\"    tbl ps.1 | troff -Ww -man -z
-.\"    groff -t -man -Tps ps.1 | ps2pdf - - > ps.pdf
-.\"
-.\" The '70s called. They want their perfect justification,
-.\" hyphenation, and double-spaced sentences back.
-.na
-.nh
-.if n .ss 12 0
-.\"
-.\"
-.\" ColSize is used for the format spec table.
-.\" It's the left margin, minus the right, minus
-.\" the space needed for the 1st two columns.
-.\" Making it messy: inches, ens, points, scaled points...
-.\"
-.nr ColSize ((\n[.l] - \n[.i]) / 1n - 29)
-.\"
-.\" This is for command options
-.nr OptSize (16u)
-.\"
-.\" l=\n(.l
-.\" i=\n(.i
-.\" o=\n(.o
-.\" H=\n(.H
-.\" s=\n(.s
-.\" ColSize=\n[ColSize]
-.\" 
-.\" Macro for easy option formatting:   .opt \-x
-.de opt              
-.  TP \\n[OptSize]
-.  BI \\$*
-..
-.\"
-.SH NAME
-ps \- report a snapshot of the current processes.
-.SH SYNOPSIS
-\fBps\fR [\fIoptions\fR]
-.PP
-.PP
-.SH DESCRIPTION
-.B ps
-displays information about a selection of the active processes.
-If you want a repetitive update of the selection and the
-displayed information, use\ \fItop\fR(1) instead.
-.P
-This version of \fBps\fR accepts several kinds of options:
-.PD 0
-.IP 1 4
-UNIX options, which may be grouped and must be preceded by a dash.
-.IP 2 4
-BSD options, which may be grouped and must not be used with a dash.
-.IP 3 4
-GNU long options, which are preceded by two dashes.
-.PD
-.PP
-Options of different types may be freely mixed, but conflicts can appear.
-There are some synonymous options, which are functionally identical, due
-to the many standards and \fBps\fR implementations that this \fBps\fR is
-compatible with.
-.P
-Note that "\fBps\ \-aux\fR" is distinct from "\fBps\ aux\fR".
-The POSIX and UNIX standards require that "\fBps\ \-aux\fR" print all
-processes owned by a user named "x", as well as printing all processes
-that would be selected by the \fB\-a\fR option. If the user named "x" does
-not exist, this \fBps\fR may interpret the command as "\fBps\ aux\fR"
-instead and print a warning. This behavior is intended to aid in
-transitioning old scripts and habits. It is fragile, subject to change,
-and thus should not be relied upon.
-.P
-By default, \fBps\fR selects all processes
-with the same effective user ID (euid=EUID) as the current user
-and
-associated with the same terminal as the invoker.
-It displays the process ID (pid=PID),
-the terminal associated with the process (tname=TTY),
-the cumulated CPU time in [DD\-]hh:mm:ss format (time=TIME),
-and the executable name (ucmd=CMD).
-Output is unsorted by default.
-.P
-The use of BSD\-style options will add process state (stat=STAT) to the
-default display and show the command args (args=COMMAND) instead of the
-executable name. You can override this with the \fBPS_FORMAT\fR
-environment variable. The use of BSD\-style options will also change the
-process selection to include processes on other terminals (TTYs) that
-are owned by you; alternately, this may be described as setting the
-selection to be the set of all processes filtered to exclude
-processes owned by other users or not on a terminal. These effects
-are not considered when options are described as being "identical" below,
-so \fB\-M\fR will be considered identical to \fBZ\fR and so on.
-.P
-Except as described below, process selection options are additive.
-The default selection is discarded, and then the selected processes
-are added to the set of processes to be displayed.
-A\ process will thus be shown if it meets any of the given
-selection criteria.
-.PP
-.\" """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
-.SH "EXAMPLES"
-.TP 3
-To see every process on the system using standard syntax:
-.B ps\ \-e
-.br
-.B ps\ \-ef
-.br
-.B ps\ \-eF
-.br
-.B ps\ \-ely
-.TP
-To see every process on the system using BSD syntax:
-.B ps\ ax
-.br
-.B ps\ axu
-.TP
-To print a process tree:
-.B ps\ -ejH
-.br
-.B ps\ axjf
-.TP
-To get info about threads:
-.B ps\ -eLf
-.br
-.B ps\ axms
-.TP
-To get security info:
-.B ps\ -eo euser,ruser,suser,fuser,f,comm,label
-.br
-.B ps\ axZ
-.br
-.B ps\ -eM
-.TP
-To see every process running as root (real\ &\ effective\ ID) in user format:
-.B ps\ \-U\ root\ \-u\ root\ u
-.TP
-To see every process with a user\-defined format:
-.B ps\ \-eo\ pid,tid,class,rtprio,ni,pri,psr,pcpu,stat,wchan:14,comm
-.br
-.B ps\ axo\ stat,euid,ruid,tty,tpgid,sess,pgrp,ppid,pid,pcpu,comm
-.br
-.B ps\ \-Ao\ pid,tt,user,fname,tmout,f,wchan
-.TP
-Print only the process IDs of syslogd:
-.B ps\ \-C\ syslogd\ \-o\ pid=
-.TP
-Print only the name of PID 42:
-.B ps\ \-p\ 42\ \-o\ comm=
-.PP
-.PP
-.\" """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
-.SH "SIMPLE PROCESS SELECTION"
-
-.opt a
-Lift the BSD\-style "only yourself" restriction, which is imposed upon
-the set of all processes when some BSD\-style (without\ "\-") options
-are used or when the \fBps\fR personality setting is BSD\-like.
-The set of processes selected in this manner is
-in addition to the set of processes selected by other means.
-An alternate description is that this option causes \fBps\fR to
-list all processes with a terminal (tty),
-or to list all processes when used together with the \fBx\fR option.
-
-.opt \-A
-Select all processes.  Identical to \fB\-e\fR.
-
-.opt \-a
-Select all processes except both session leaders (see \fIgetsid\fR(2)) and
-processes not associated with a terminal.
-
-.opt \-d
-Select all processes except session leaders.
-
-.opt \-\-deselect
-Select all processes except those that fulfill the specified conditions
-(negates the selection). Identical to \fB\-N\fR.
-
-
-.opt \-e
-Select all processes.  Identical to \fB\-A\fR.
-
-.\" Current "g" behavior: add in the session leaders, which would
-.\" be excluded in the sunos4 personality. Supposed "g" behavior:
-.\" add in the group leaders -- at least according to the SunOS 4
-.\" man page on the FreeBSD site. Uh oh. I think I had tested SunOS
-.\" though, so maybe the code is correct.
-
-.opt g
-Really all, even session leaders.  This flag is obsolete and may be
-discontinued in a future release. It is normally implied by the \fBa\fR flag,
-and is only useful when operating in the sunos4 personality.
-
-.opt \-N
-Select all processes except those that fulfill the specified conditions
-(negates the selection). Identical to \fB\-\-deselect\fR.
-
-.opt T
-Select all processes associated with this terminal.  Identical to the
-\fBt\fR option without any argument.
-
-.opt r
-Restrict the selection to only running processes.
-
-.opt x
-Lift the BSD\-style "must have a tty" restriction, which is imposed upon
-the set of all processes when some BSD\-style (without\ "\-") options
-are used or when the \fBps\fR personality setting is BSD\-like.
-The set of processes selected in this manner is
-in addition to the set of processes selected by other means.
-An alternate description is that this option causes \fBps\fR to
-list all processes owned by you (same EUID as \fBps\fR),
-or to list all processes when used together with the \fBa\fR option.
-
-.\" """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
-.PD
-.PP
-.SH "PROCESS SELECTION BY LIST"
-These options accept a single argument in the form of a blank\-separated
-or comma\-separated list.  They can be used multiple times.
-For\ example:\ \fBps\ \-p\ "1\ 2"\ \-p\ 3,4\fR
-.P
-
-.opt \-\fI123\fR
-Identical to \fB\-\-sid\ \fI123\fR.
-
-.opt \fI123\fR
-Identical to \fB\-\-pid\ \fI123\fR.
-
-.opt \-C \ cmdlist
-Select by command name.
-.br
-This selects the processes whose executable name is given in
-\fIcmdlist\fR.
-
-.opt \-G \ grplist
-Select by real group ID (RGID) or name.
-.br
-This selects the processes whose real group name or ID is in the
-\fIgrplist\fR list.  The real group ID identifies the group of the user
-who created the process, see \fIgetgid\fR(2).
-
-.opt \-g \ grplist
-Select by session OR by effective group name.
-.br
-Selection by session is specified by many standards,
-but selection by effective group is the logical behavior that
-several other operating systems use.
-This \fBps\fR will select by session when the list
-is completely numeric (as\ sessions\ are).
-Group ID numbers will work only when some group names are also specified.
-See the \fB\-s\fR and \fB\-\-group\fR options.
-
-.opt \-\-Group \ grplist
-Select by real group ID (RGID) or name.  Identical to \fB\-G\fR.
-
-.opt \-\-group \ grplist
-Select by effective group ID (EGID) or name.
-.br
-This selects the processes whose effective group name or ID is in
-\fIgrouplist\fR.  The effective group ID describes the group whose file
-access permissions are used by the process (see\ \fIgetegid\fR(2)).
-The \fB\-g\fR option is often an alternative to\ \fB\-\-group\fR.
-
-.opt p \ pidlist
-Select by process ID.  Identical to \fB\-p\fR and\ \fB\-\-pid\fR.
-
-.opt \-p \ pidlist
-Select by PID.
-.br
-This selects the processes whose process ID numbers appear in
-\fIpidlist\fR.  Identical to \fBp\fR and\ \fB\-\-pid\fR.
-
-.opt \-\-pid \ pidlist
-Select by process\ ID.  Identical to \fB\-p\fR\ and\ \fBp\fR.
-
-.opt \-\-ppid \ pidlist
-Select by parent process\ ID.
-This selects the processes
-with a parent\ process\ ID in \fIpidlist\fR.
-That\ is, it selects processes that are children
-of those listed in \fIpidlist\fR.
-
-.opt \-s \ sesslist
-Select by session ID.
-.br
-This selects the processes
-with a session ID specified in\ \fIsesslist\fR.
-
-.opt \-\-sid \ sesslist
-Select by session\ ID.  Identical to\ \fB\-s\fR.
-
-.opt t \ ttylist
-Select by tty.  Nearly identical to \fB\-t\fR and \fB\-\-tty\fR,
-but can also be used with an empty \fIttylist\fR to indicate
-the terminal associated with \fBps\fR.
-Using the \fBT\fR option is considered cleaner than using \fBt\fR with
-an\ empty\ \fIttylist\fR.
-
-.opt \-t \ ttylist
-Select by tty.
-.br
-This selects the processes associated with the terminals
-given in \fIttylist\fR.
-Terminals (ttys, or screens for text output) can be specified in several
-forms: /dev/ttyS1, ttyS1, S1.
-A\ plain "\-" may be used to select processes not attached to any terminal.
-
-.opt \-\-tty \ ttylist
-Select by terminal.  Identical to \fB\-t\fR and\ \fBt\fR.
-
-.opt U \ userlist
-Select by effective user ID (EUID) or name.
-.br
-This selects the processes whose effective user name
-or ID is in \fIuserlist\fR.
-The effective user\ ID describes the user whose file
-access permissions are used by the process
-(see\ \fIgeteuid\fR(2)).
-Identical to \fB\-u\fR and\ \fB\-\-user\fR.
-
-.opt \-U \ userlist
-Select by real user ID (RUID) or name.
-.br
-It selects the processes whose real user name or ID is in the
-\fIuserlist\fR list.
-The real user ID identifies the user who created the process,
-see\ \fIgetuid\fR(2).
-
-.opt \-u \ userlist
-Select by effective user ID (EUID) or name.
-.br
-This selects the processes whose effective user name or ID is in
-\fIuserlist\fR.  The effective user ID describes the user whose file
-access permissions are used by the process (see\ \fIgeteuid\fR(2)).
-Identical to \fBU\fR and \fB\-\-user\fR.
-
-.opt \-\-User \ userlist
-Select by real user ID (RUID) or name.  Identical to \fB\-U\fR.
-
-.opt \-\-user \ userlist
-Select by effective user ID (EUID) or name.
-Identical to \fB\-u\fR and\ \fBU\fR.
-
-.\" """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
-.PD
-.PP
-.SH "OUTPUT FORMAT CONTROL"
-These options are used to choose the information displayed by \fBps\fR.
-The output may differ by personality.
-.PP
-
-.opt \-c
-Show different scheduler information for the \fB\-l\fR option.
-
-.opt \-\-context
-Display security context format (for\ SE\ Linux).
-
-.opt \-f
-Do full\-format listing. This option can be combined with many
-other UNIX\-style options to add additional columns. It also causes
-the command arguments to be printed. When used with \fB\-L\fR, the
-NLWP (number of threads) and LWP (thread ID) columns will be added.
-See the \fBc\fR option, the format keyword \fBargs\fR, and the
-format keyword \fBcomm\fR.
-
-.opt \-F
-Extra full format. See the \fB\-f\fR option, which \fB\-F\fR implies.
-
-.opt \-\-format \ format
-user\-defined format.  Identical to \fB\-o\fR and \fBo\fR.
-
-.opt j
-BSD job control format.
-
-.opt \-j
-Jobs format
-
-.opt l
-Display BSD long format.
-
-.opt \-l
-Long format. The \fB\-y\fR option is often useful with this.
-
-.opt \-M
-Add a column of security data. Identical to \fBZ\fR (for\ SE\ Linux).
-
-.opt O \ format
-is preloaded \fBo\fR (overloaded).
-.br
-The BSD \fBO\fR option can act like \fB\-O\fR (user\-defined output
-format with some common fields predefined) or can be used to specify
-sort order.  Heuristics are used to determine the behavior of this
-option. To ensure that the desired behavior is obtained (sorting or
-formatting), specify the option in some other way
-(e.g. with \fB\-O\fR or \fB\-\-sort\fR).
-When used as a formatting option, it is identical to \fB\-O\fR, with the
-BSD\ personality.
-
-.opt \-O \ format
-Like \fB\-o\fR, but preloaded with some default columns.
-Identical to \fB\-o\ pid,\fIformat\fB,state,tname,time,command\fR
-or \fB\-o\ pid,\fIformat\fB,tname,time,cmd\fR, see\ \fB\-o\fR\ below.
-
-.opt o \ format
-Specify user\-defined format.  Identical to \fB\-o\fR and
-\fB\-\-format\fR.
-
-.opt \-o \ format
-User\-defined format.
-.br
-\fIformat\fR is a single argument in the form of a
-blank\-separated or comma\-separated list, which offers
-a way to specify individual output columns.
-The recognized keywords are described in the \fBSTANDARD FORMAT
-SPECIFIERS\fR section below.
-Headers may be
-renamed (\fBps\ \-o\ pid,ruser=RealUser\ \-o\ comm=Command\fR) as desired.
-If all column headers are empty (\fBps\ \-o\ pid=\ \-o\ comm=\fR) then the
-header line will not be output. Column width will increase as
-needed for wide headers; this may be used to widen up columns
-such as WCHAN (\fBps\ \-o\ pid,wchan=WIDE\-WCHAN\-COLUMN\ \-o\ comm\fR).
-Explicit width control (\fBps\ opid,wchan:42,cmd\fR) is offered too.
-The behavior of \fBps\ \-o\ pid=X,comm=Y\fR varies with personality;
-output may be one column named "X,comm=Y" or two columns
-named "X" and "Y". Use multiple \fB\-o\fR options when in doubt.
-Use the \fBPS_FORMAT\fR environment variable to specify a default
-as desired; DefSysV and DefBSD are macros that may be used to
-choose the default UNIX or BSD columns.
-
-.opt s
-Display signal format
-
-.opt u
-Display user\-oriented format
-
-.opt v
-Display virtual memory format
-
-.opt X
-Register format.
-
-.opt \-y
-Do not show flags; show rss in place of addr.
-This option can only be used with \fB\-l\fR.
-
-.opt Z
-Add a column of security data. Identical to \fB\-M\fR (for\ SE\ Linux).
-
-.\" """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
-.PD
-.PP
-.SH "OUTPUT MODIFIERS"
-
-.\"  .TP
-.\"  .B C
-.\"  use raw CPU time for %CPU instead of decaying average
-
-.opt c
-Show the true command name. This is derived from the name of the
-executable file, rather than from the argv value. Command arguments
-and any modifications to them  are
-thus not shown. This option
-effectively turns the \fBargs\fR format keyword into the \fBcomm\fR
-format keyword; it is useful with the \fB\-f\fR format option and with
-the various BSD\-style format options, which all normally
-display the command arguments.
-See the \fB\-f\fR option, the format keyword \fBargs\fR, and the
-format keyword \fBcomm\fR.
-
-.opt \-\-cols \ n
-Set screen width
-
-.opt \-\-columns \ n
-Set screen width
-
-.opt \-\-cumulative
-Include some dead child process data (as a sum with the parent)
-
-.opt e
-Show the environment after the command.
-
-.opt f
-ASCII art process hierarchy (forest).
-
-.opt \-\-forest
-ASCII art process tree.
-
-.opt h
-No header. (or, one header per screen in the BSD personality)
-.br
-The \fBh\fR option is problematic.  Standard BSD \fBps\fR uses
-this option to print a header on each page of output, but older
-Linux \fBps\fR uses this option to totally disable the header.
-This version of \fBps\fR follows the Linux usage of not printing
-the header unless the BSD personality has been selected, in which
-case it prints a header on each page of output. Regardless of the
-current personality, you can use the long options \fB\-\-headers\fR
-and \fB\-\-no\-headers\fR to enable printing headers each page or
-disable headers entirely, respectively.
-
-.opt \-H
-Show process hierarchy (forest).
-
-.opt \-\-headers
-Repeat header lines, one per page of output.
-
-.opt k \ spec
-Specify sorting order. Sorting syntax is
-[\fB+\fR|\fB\-\fR]\fIkey\fR[,[\fB+\fR|\fB\-\fR]\fIkey\fR[,...]].
-Choose a multi\-letter key from the \fBSTANDARD FORMAT SPECIFIERS\fR section.
-The\ "+" is optional since default direction is increasing numerical or
-lexicographic order. Identical to \fB\-\-sort\fR. Examples:
-.br
-\fBps\ jaxkuid,\-ppid,+pid\fR
-.br
-\fBps\ axk\ comm\ o\ comm,args\fR
-.br
-\fBps\ kstart_time\ \-ef\fR
-
-.opt \-\-lines \ n
-Set screen height.
-
-.opt \-n \ namelist
-Set namelist file.  Identical to \fBN\fR.
-.br
-The namelist file is needed for a proper WCHAN display, and must match
-the current Linux kernel exactly for correct output.
-Without this option, the default search path for the namelist is:
-
-	$PS_SYSMAP
-.br
-	$PS_SYSTEM_MAP
-.br
-	/proc/*/wchan
-.br
-	/boot/System.map\-\`uname\ \-r\`
-.br
-	/boot/System.map
-.br
-	/lib/modules/\`uname\ \-r\`/System.map
-.br
-	/usr/src/linux/System.map
-.br
-	/System.map
-
-.opt n
-Numeric output for WCHAN and USER (including all types of UID and GID).
-
-.opt N \ namelist
-Specify namelist file.  Identical to \fB\-n\fR, see \fB\-n\fR above.
-
-.opt \-\-no\-headers
-Print no header line at all. \fB\-\-no\-heading\fR is an alias for this
-option.
-
-.opt O \ order
-Sorting order (overloaded).
-.br
-The BSD \fBO\fR option can act like \fB\-O\fR (user\-defined output
-format with some common fields predefined) or can be used to specify
-sort order.  Heuristics are used to determine the behavior of this
-option. To ensure that the desired behavior is obtained (sorting or
-formatting), specify the option in some other way (e.g. with \fB\-O\fR
-or \fB\-\-sort\fR).
-
-For sorting, obsolete BSD \fBO\fR option syntax is
-\fBO\fR[\fB+\fR|\fB\-\fR]\fIk1\fR[,[\fB+\fR|\fB\-\fR]\fIk2\fR[,...]].
-It orders the processes listing according to the multilevel sort specified by
-the sequence of one\-letter short keys \fIk1\fR, \fIk2\fR, ... described
-in the \fBOBSOLETE SORT KEYS\fR section below.
-The\ "+" is currently optional,
-merely re\-iterating the default direction on a key,
-but may help to distinguish an \fBO\fR sort from an \fBO\fR format.
-The\ "\-" reverses direction only on the key it precedes.
-
-.opt \-\-rows \ n
-Set screen height.
-
-.opt S
-Sum up some information, such as CPU usage, from dead child processes
-into their parent. This is useful for examining a system where a
-parent process repeatedly forks off short\-lived children to do work.
-
-.opt \-\-sort \ spec
-Specify sorting order. Sorting syntax is
-[\fB+\fR|\fB\-\fR]\fIkey\fR[,[\fB+\fR|\fB\-\fR]\fIkey\fR[,...]].
-Choose a multi\-letter key from the \fBSTANDARD FORMAT SPECIFIERS\fR section.
-The\ "+" is optional since default direction is increasing numerical or
-lexicographic order. Identical to\ \fBk\fR.
-For example: \fBps\ jax\ \-\-sort=uid,\-ppid,+pid\fR
-
-.opt w
-Wide output. Use this option twice for unlimited width.
-
-.opt \-w
-Wide output. Use this option twice for unlimited width.
-
-.opt \-\-width \ n
-set screen width
-
-.\" """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
-.PD
-.PP
-.SH "THREAD DISPLAY"
-.PD 0
-
-.opt H
-Show threads as if they were processes.
-
-.opt \-L
-Show threads, possibly with LWP and NLWP columns.
-
-.opt m
-Show threads after processes.
-
-.opt \-m
-Show threads after processes.
-
-.opt \-T
-Show threads, possibly with SPID column.
-
-.\" """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
-.PD
-.PP
-.SH "OTHER INFORMATION"
-.PD 0
-
-.opt \-\-help
-Print a help message.
-
-.opt \-\-info
-Print debugging info.
-
-.opt L
-List all format specifiers.
-
-.opt V
-Print the procps-ng version.
-
-.opt \-V
-Print the procps-ng version.
-
-.opt \-\-version
-Print the procps-ng version.
-
-.\" """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
-.PD
-.PP
-.SH NOTES
-This \fBps\fR works by reading the virtual files in\ /proc.
-This \fBps\fR does not need to be setuid kmem or have any privileges to run.
-Do not give this \fBps\fR any special permissions.
-
-This \fBps\fR needs access to namelist data for proper WCHAN display.
-For kernels prior to 2.6, the System.map file must be installed.
-
-CPU usage is currently expressed as the percentage of time spent
-running during the entire lifetime of a process.
-This is not ideal, and\ it does not conform to the
-standards that \fBps\fR otherwise conforms\ to.
-CPU\ usage is unlikely to add up to exactly\ 100%.
-
-The SIZE and RSS fields don't count some parts of a process including the
-page tables, kernel stack, struct thread_info, and struct task_struct.
-This is usually at least 20\ KiB of memory that is always resident.
-SIZE is the virtual size of the process (code+data+stack).
-
-Processes marked <defunct> are dead processes (so\-called\ "zombies") that
-remain because their parent has not destroyed them properly. These processes
-will be destroyed by \fIinit\fR(8) if the parent process exits.
-
-If the length of the username is greater than the length of
-the display column, the numeric user ID is displayed instead.
-
-.SH "PROCESS FLAGS"
-The sum of these values is displayed in the "F" column,
-which is provided by the \fBflags\fR output specifier:
-.PD 0
-.TP 5
-1
-forked but didn't exec
-.TP
-4
-used super\-user privileges
-.PD
-.PP
-.SH "PROCESS STATE CODES"
-Here are the different values that the \fBs\fR, \fBstat\fR and
-\fBstate\fR output specifiers (header\ "STAT"\ or\ "S") will display to
-describe the state of a process:
-.PD 0
-.TP 5
-D
-uninterruptible sleep (usually\ IO)
-.TP
-R
-running or runnable (on\ run\ queue)
-.TP
-S
-interruptible sleep (waiting for an event to complete)
-.TP
-T
-stopped, either by a job control signal or because it is being traced.
-.TP
-W
-paging (not valid since the 2.6.xx kernel)
-.TP
-X
-dead (should never be seen)
-.TP
-Z
-defunct ("zombie") process, terminated but not reaped by its parent.
-.PD
-.PP
-For BSD formats and when the \fBstat\fR keyword is used, additional
-characters may be displayed:
-.PD 0
-.TP 5
-<
-high\-priority (not nice to other users)
-.TP
-N
-low\-priority (nice to other users)
-.TP
-L
-has pages locked into memory (for real\-time and custom\ IO)
-.TP
-s
-is a session leader
-.TP
-l
-is multi-threaded (using CLONE_THREAD, like NPTL pthreads\ do)
-.TP
-+
-is in the foreground process group.
-.PD
-.PP
-.PP
-.SH "OBSOLETE SORT KEYS"
-These keys are used by the BSD \fBO\fR option (when it is used for
-sorting).  The GNU \fB\-\-sort\fR option doesn't use these keys, but the
-specifiers described below in the \fBSTANDARD FORMAT SPECIFIERS\fR
-section. Note that the values used in sorting are the internal
-values \fBps\fR uses and not the "cooked" values used in some of
-the output format fields (e.g. sorting on tty will sort into
-device number, not according to the terminal name displayed).
-Pipe \fBps\fR output into the \fIsort\fR(1) command if you want
-to sort the cooked values.
-
-.TS
-l l lw(3i).
-\fBKEY	LONG	DESCRIPTION\fR
-c	cmd	simple name of executable
-C	pcpu	cpu utilization
-f	flags	flags as in long format F field
-g	pgrp	process group ID
-G	tpgid	controlling tty process group ID
-j	cutime	cumulative user time
-J	cstime	cumulative system time
-k	utime	user time
-m	min_flt	number of minor page faults
-M	maj_flt	number of major page faults
-n	cmin_flt	cumulative minor page faults
-N	cmaj_flt	cumulative major page faults
-o	session	session ID
-p	pid	process ID
-P	ppid	parent process ID
-r	rss	resident set size
-R	resident	resident pages
-s	size	memory size in kilobytes
-S	share	amount of shared pages
-t	tty	the device number of the controlling tty
-T	start_time	time process was started
-U	uid	user ID number
-u	user	user name
-v	vsize	total VM size in kB
-y	priority	kernel scheduling priority
-.\"K	stime	system time (conflict, system vs. start time)
-.TE
-.PP
-.PP
-.SH "AIX FORMAT DESCRIPTORS"
-This \fBps\fR supports AIX format descriptors, which work somewhat like the
-formatting codes of \fIprintf\fR(1) and \fIprintf\fR(3). For example, the normal
-default output can be produced with this:  \fBps\ \-eo\ "%p\ %y\ %x\ %c"\fR.
-The\ \fBNORMAL\fR codes are described in the next section.
-.TS
-l l l.
-\fBCODE	NORMAL	HEADER\fR
-%C	pcpu	%CPU
-%G	group	GROUP
-%P	ppid	PPID
-%U	user	USER
-%a	args	COMMAND
-%c	comm	COMMAND
-%g	rgroup	RGROUP
-%n	nice	NI
-%p	pid	PID
-%r	pgid	PGID
-%t	etime	ELAPSED
-%u	ruser	RUSER
-%x	time	TIME
-%y	tty	TTY
-%z	vsz	VSZ
-.TE
-
-.SH "STANDARD FORMAT SPECIFIERS"
-Here are the different keywords that may be used to control the output
-format (e.g. with option \fB\-o\fR) or to sort the selected processes
-with the GNU\-style \fB\-\-sort\fR option.
-
-For example:  \fBps\ \-eo\ pid,user,args\ \-\-sort\ user\fR
-
-This version of \fBps\fR tries to recognize most of the keywords used in
-other implementations of \fBps\fR.
-
-The following user\-defined format specifiers may contain
-spaces: \fBargs\fR, \fBcmd\fR, \fBcomm\fR, \fBcommand\fR, \fBfname\fR,
-\fBucmd\fR, \fBucomm\fR,
-\fBlstart\fR, \fBbsdstart\fR, \fBstart\fR.
-
-Some keywords may not be available for sorting.
-
-.\" #######################################################################
-.\" lB1 lB1 lB1 lB1 s s s
-.\" lB1 l1  l1  l1  s s s.
-.\"
-.\" lB1 lB1 lBw(5.5i)
-.\" lB1 l1  l.
-.\"
-.TS
-expand;
-lB1 lB1 lBw(\n[ColSize]n)
-lB1 l1  l.
-CODE	HEADER	DESCRIPTION
-
-%cpu	%CPU	T{
-cpu utilization of the process in "##.#" format.  Currently, it is the CPU time
-used divided by the time the process has been running (cputime/realtime
-ratio), expressed as a percentage. It will not add up to 100% unless you
-are lucky.  (alias\ \fBpcpu\fR).
-T}
-
-%mem	%MEM	T{
-ratio of the process's resident set size  to the physical memory on
-the machine, expressed as a percentage.  (alias\ \fBpmem\fR).
-T}
-
-args	COMMAND	T{
-command with all its arguments as a string. Modifications to the arguments
-may be shown. The output in this column may contain spaces.
-A\ process marked <defunct> is partly dead, waiting
-to be fully destroyed by its parent. Sometimes the process args
-will be unavailable; when this happens, \fBps\fR will instead
-print the executable name in brackets.
-(alias\ \fBcmd\fR,\ \fBcommand\fR). See also the \fBcomm\fR format
-keyword, the \fB\-f\fR option, and the \fBc\fR option.
-.br
-When specified last, this column will extend to the edge of the display.
-If \fBps\fR can not determine display width, as when output is redirected
-(piped) into a file or another command, the output width is undefined
-(it may be 80, unlimited, determined by the \fBTERM\fR variable, and so on).
-The \fBCOLUMNS\fR environment variable or \fB\-\-cols\fR option may
-be used to exactly determine the width in this case.
-The \fBw\fR or \fB\-w\fR option may be also be used to adjust width.
-T}
-
-blocked	BLOCKED	T{
-mask of the blocked signals, see \fIsignal\fR(7).
-According to the width of the field,
-a\ 32 or 64\-bit mask in hexadecimal format is displayed.
-(alias\ \fBsig_block\fR,\ \fBsigmask\fR).
-T}
-
-bsdstart	START	T{
-time the command started.  If the process was started less
-than 24 hours ago, the output format is "\ HH:MM",
-else it is "Mmm\ dd"
-(where Mmm is the three letters of the month).
-See also \fBlstart\fR, \fBstart\fR, \fBstart_time\fR, and \fBstime\fR.
-T}
-
-bsdtime	TIME	T{
-accumulated cpu time, user\ +\ system.  The display format is usually
-"MMM:SS", but can be shifted to the right if the process used more than 999
-minutes of cpu time.
-T}
-
-c	C	T{
-processor utilization. Currently, this is the integer value of
-the percent usage over the lifetime of the process.  (see\ \fB%cpu\fR).
-T}
-
-caught	CAUGHT	T{
-mask of the caught signals, see \fIsignal\fR(7).  According to the
-width of the field, a 32 or 64 bits mask in hexadecimal format is
-displayed.  (alias\ \fBsig_catch\fR,\ \fBsigcatch\fR).
-T}
-
-cgroup	CGROUP	T{
-display control groups to which the process belongs.
-T}
-
-class	CLS	T{
-scheduling class of the process.  (alias\ \fBpolicy\fR,\ \fBcls\fR).
-Field's possible values are:
-.br
-\-	not reported
-.br
-TS	SCHED_OTHER
-.br
-FF	SCHED_FIFO
-.br
-RR	SCHED_RR
-.br
-B	SCHED_BATCH
-.br
-ISO	SCHED_ISO
-.br
-IDL	SCHED_IDLE
-.br
-?	unknown value
-T}
-
-cls	CLS	T{
-scheduling class of the process.  (alias\ \fBpolicy\fR,\ \fBclass\fR).
-Field's possible values are:
-.br
-\-	not reported
-.br
-TS	SCHED_OTHER
-.br
-FF	SCHED_FIFO
-.br
-RR	SCHED_RR
-.br
-B	SCHED_BATCH
-.br
-ISO	SCHED_ISO
-.br
-IDL	SCHED_IDLE
-.br
-?	unknown value
-T}
-
-cmd	CMD	T{
-see \fBargs\fR.  (alias\ \fBargs\fR,\ \fBcommand\fR).
-T}
-
-comm	COMMAND	T{
-command name (only\ the executable\ name).  Modifications to the command
-name will not be shown. A\ process marked <defunct> is partly dead, waiting
-to be fully destroyed by its parent. The output in this
-column may contain spaces.  (alias\ \fBucmd\fR,\ \fBucomm\fR).
-See also the \fBargs\fR format
-keyword, the \fB\-f\fR option, and the \fBc\fR option.
-.br
-When specified last, this column will extend to the edge of the display.
-If \fBps\fR can not determine display width, as when output is redirected
-(piped) into a file or another command, the output width is undefined
-(it may be 80, unlimited, determined by the \fBTERM\fR variable, and so on).
-The \fBCOLUMNS\fR environment variable or \fB\-\-cols\fR option may
-be used to exactly determine the width in this case.
-The \fBw\fR or \fB\-w\fR option may be also be used to adjust width.
-T}
-
-command	COMMAND	T{
-see \fBargs\fR.  (alias\ \fBargs\fR,\ \fBcmd\fR).
-T}
-
-cp	CP	T{
-per\-mill (tenths of a percent) CPU usage.  (see\ \fB%cpu\fR).
-T}
-
-cputime	TIME	T{
-cumulative CPU time, "[DD\-]hh:mm:ss" format.  (alias\ \fBtime\fR).
-T}
-
-egid	EGID	T{
-effective group ID number of the process as a decimal integer.
-(alias\ \fBgid\fR).
-T}
-
-egroup	EGROUP	T{
-effective group ID of the process.  This will be the textual group ID,
-if it can be obtained and the field width permits, or a decimal
-representation otherwise.  (alias\ \fBgroup\fR).
-T}
-
-eip	EIP	T{
-instruction pointer.
-T}
-
-esp	ESP	T{
-stack pointer.
-T}
-
-etime	ELAPSED	T{
-elapsed time since the process was started,
-in\ the form\ [[DD\-]hh:]mm:ss.
-T}
-
-etimes	ELAPSED	T{
-elapsed time since the process was started,
-in\ seconds.
-T}
-
-euid	EUID	T{
-effective user\ ID (alias\ \fBuid\fR).
-T}
-
-euser	EUSER	T{
-effective user\ name.  This will be the textual
-user\ ID, if\ it can be obtained and the field width permits,
-or\ a\ decimal representation otherwise.
-The\ \fBn\fR\ option can be used
-to force the decimal representation.
-(alias\ \fBuname\fR,\ \fBuser\fR).
-T}
-
-f	F	T{
-flags associated with the process, see the \fBPROCESS FLAGS\fR section.
-(alias\ \fBflag\fR,\ \fBflags\fR).
-T}
-
-fgid	FGID	T{
-filesystem access group\ ID.  (alias\ \fBfsgid\fR).
-T}
-
-fgroup	FGROUP	T{
-filesystem access group\ ID.
-This will be the textual group\ ID, if\ it can be obtained
-and the field width permits,
-or\ a\ decimal representation otherwise.
-(alias\ \fBfsgroup\fR).
-T}
-
-flag	F	T{
-see\ \fBf\fR.  (alias\ \fBf\fR,\ \fBflags\fR).
-T}
-
-flags	F	T{
-see\ \fBf\fR.  (alias\ \fBf\fR,\ \fBflag\fR).
-T}
-
-fname	COMMAND	T{
-first 8 bytes of the base name of the process's executable file.
-The output in this column may contain spaces.
-T}
-
-fuid	FUID	T{
-filesystem access user\ ID.  (alias\ \fBfsuid\fR).
-T}
-
-fuser	FUSER	T{
-filesystem access user\ ID.  This will be the textual user\ ID,
-if\ it can be obtained and the field width permits,
-or\ a\ decimal representation otherwise.
-T}
-
-gid	GID	T{
-see\ \fBegid\fR.  (alias\ \fBegid\fR).
-T}
-
-group	GROUP	T{
-see\ \fBegroup\fR.  (alias\ \fBegroup\fR).
-T}
-
-ignored	IGNORED	T{
-mask of the ignored signals, see \fIsignal\fR(7).  According to the
-width of the field, a\ 32 or 64\ bits mask in hexadecimal format
-is displayed.  (alias \fBsig_ignore\fR, \fBsigignore\fR).
-T}
-
-label	LABEL	T{
-security label, most commonly used for SE\ Linux context data.
-This is for the \fIMandatory Access Control\fR ("MAC") found on
-high\-security systems.
-T}
-
-lstart	STARTED	T{
-time the command started.
-See also \fBbsdstart\fR, \fBstart\fR, \fBstart_time\fR, and \fBstime\fR.
-T}
-
-lwp	LWP	T{
-light weight process (thread) ID of the dispatchable entity
-(alias\ \fBspid\fR,\ \fBtid\fR).
-See \fBtid\fR for additional information.
-T}
-
-maj_flt	MAJFLT	T{
-The number of major page faults that have occured with this process.
-T}
-
-min_flt	MINFLT	T{
-The number of minor page faults that have occured with this process.
-T}
-
-ni	NI	T{
-nice value. This ranges from 19 (nicest) to \-20 (not\ nice to\ others),
-see\ \fInice\fR(1).  (alias\ \fBnice\fR).
-T}
-
-nice	NI	T{
-see\ \fBni\fR.  (alias\ \fBni\fR).
-T}
-
-nlwp	NLWP	T{
-number of lwps (threads) in the process.  (alias\ \fBthcount\fR).
-T}
-
-nwchan	WCHAN	T{
-address of the kernel function where the process is sleeping
-(use \fBwchan\fR if you want the kernel function name).
-Running tasks will display a dash ('\-') in this column.
-T}
-
-pcpu	%CPU	T{
-see\ \fB%cpu\fR.  (alias\ \fB%cpu\fR).
-T}
-
-pending	PENDING	T{
-mask of the pending signals. See\ \fIsignal\fR(7).  Signals pending on
-the process are distinct from signals pending on individual threads.
-Use the \fBm\fR option or the \fB\-m\fR option to see both.
-According to the width of the field, a\ 32 or 64\ bits mask in
-hexadecimal format is displayed.  (alias\ \fBsig\fR).
-T}
-
-pgid	PGID	T{
-process group\ ID or, equivalently, the process\ ID of the
-process group leader.  (alias\ \fBpgrp\fR).
-T}
-
-pgrp	PGRP	T{
-see\ \fBpgid\fR.  (alias\ \fBpgid\fR).
-T}
-
-pid	PID	T{
-a number representing the process ID
-(alias\ \fBtgid\fR).
-T}
-
-pmem	%MEM	T{
-see\ \fB%mem\fR.  (alias\ \fB%mem\fR).
-T}
-
-policy	POL	T{
-scheduling class of the process.  (alias\ \fBclass\fR,\ \fBcls\fR).
-Possible values are:
-.br
-\-	not reported
-.br
-TS	SCHED_OTHER
-.br
-FF	SCHED_FIFO
-.br
-RR	SCHED_RR
-.br
-B	SCHED_BATCH
-.br
-ISO	SCHED_ISO
-.br
-IDL	SCHED_IDLE
-.br
-?	unknown value
-T}
-
-ppid	PPID	T{
-parent process ID.
-T}
-
-pri	PRI	T{
-priority of the process. Higher number means lower priority.
-T}
-
-psr	PSR	T{
-processor that process is currently assigned to.
-T}
-
-rgid	RGID	T{
-real group ID.
-T}
-
-rgroup	RGROUP	T{
-real group name.  This will be the textual group\ ID, if\ it can be
-obtained and the field width permits,
-or\ a\ decimal representation otherwise.
-T}
-
-rss	RSS	T{
-resident set size, the non\-swapped physical memory that
-a task has used (in\ kiloBytes).
-(alias\ \fBrssize\fR,\ \fBrsz\fR).
-T}
-
-rssize	RSS	T{
-see\ \fBrss\fR.  (alias\ \fBrss\fR,\ \fBrsz\fR).
-T}
-
-rsz	RSZ	T{
-see\ \fBrss\fR.  (alias\ \fBrss\fR,\ \fBrssize\fR).
-T}
-
-rtprio	RTPRIO	T{
-realtime priority.
-T}
-
-ruid	RUID	T{
-real user\ ID.
-T}
-
-ruser	RUSER	T{
-real user\ ID.  This will be the textual user\ ID,
-if\ it can be obtained and the field width permits,
-or\ a\ decimal representation otherwise.
-T}
-
-s	S	T{
-minimal state display (one\ character).
-See\ section \fBPROCESS STATE CODES\fR for the different values.
-See\ also \fBstat\fR if you want additional
-information displayed.  (alias\ \fBstate\fR).
-T}
-
-sched	SCH	T{
-scheduling policy of the process.  The policies SCHED_OTHER (SCHED_NORMAL),
-SCHED_FIFO, SCHED_RR, SCHED_BATCH, SCHED_ISO, and SCHED_IDLE are respectively
-displayed as 0,\ 1,\ 2,\ 3,\ 4,\ and\ 5.
-T}
-
-sess	SESS	T{
-session\ ID or, equivalently, the process\ ID of the session\ leader.
-(alias\ \fBsession\fR,\ \fBsid\fR).
-T}
-
-sgi_p	P	T{
-processor that the process is currently executing on.
-Displays "*" if the process is not currently running or runnable.
-T}
-
-sgid	SGID	T{
-saved group\ ID.
-(alias\ \fBsvgid\fR).
-T}
-
-sgroup	SGROUP	T{
-saved group\ name.  This will be the textual group\ ID,
-if\ it can be obtained and the field width permits,
-or\ a\ decimal representation otherwise.
-T}
-
-sid	SID	T{
-see\ \fBsess\fR.  (alias\ \fBsess\fR,\ \fBsession\fR).
-T}
-
-sig	PENDING	T{
-see\ \fBpending\fR.  (alias\ \fBpending\fR,\ \fBsig_pend\fR).
-T}
-
-sigcatch	CAUGHT	T{
-see\ \fBcaught\fR.  (alias\ \fBcaught\fR,\ \fBsig_catch\fR).
-T}
-
-sigignore	IGNORED	T{
-see\ \fBignored\fR.  (alias\ \fBignored\fR,\ \fBsig_ignore\fR).
-T}
-
-sigmask	BLOCKED	T{
-see\ \fBblocked\fR.  (alias\ \fBblocked\fR,\ \fBsig_block\fR).
-T}
-
-size	SZ	T{
-approximate amount of swap space that would be required
-if the process were to dirty all writable pages and then
-be swapped out.
-This number is very\ rough!
-T}
-
-spid	SPID	T{
-see \fBlwp\fR.  (alias\ \fBlwp\fR,\ \fBtid\fR).
-T}
-
-stackp	STACKP	T{
-address of the bottom (start) of stack for the process.
-T}
-
-start	STARTED	T{
-time the command started.
-If the process was started less than 24 hours ago,
-the output format is "HH:MM:SS",
-else it is "\ \ <mm\ dd"
-(where Mmm is a three\-letter month\ name).
-See also \fBlstart\fR, \fBbsdstart\fR, \fBstart_time\fR, and \fBstime\fR.
-T}
-
-start_time	START	T{
-starting time or date of the process.
-Only the year will be displayed if the process was not
-started the same year \fBps\fR was invoked,
-or\ "MmmDD" if\ it was not started the same day,
-or\ "HH:MM" otherwise.
-See also \fBbsdstart\fR, \fBstart\fR, \fBlstart\fR, and \fBstime\fR.
-T}
-
-stat	STAT	T{
-multi\-character process state.
-See\ section \fBPROCESS STATE CODES\fR
-for the different values meaning.
-See also \fBs\fR and \fBstate\fR if you just want
-the first character displayed.
-T}
-
-state	S	T{
-see\ \fBs\fR.  (alias\ \fBs\fR).
-T}
-
-suid	SUID	T{
-saved user\ ID.  (alias\ \fBsvuid\fR).
-T}
-
-supgid	SUPGID	T{
-group ids of supplementary groups, if any.
-See
-.BR getgroups (2).
-T}
-
-supgrp	SUPGRP	T{
-group names of supplementary groups, if any.
-See
-.BR getgroups (2).
-T}
-
-suser	SUSER	T{
-saved user name.  This will be the textual user\ ID,
-if\ it can be obtained and the field width permits,
-or\ a\ decimal representation otherwise.
-(alias\ \fBsvuser\fR).
-T}
-
-svgid	SVGID	T{
-see\ \fBsgid\fR.  (alias\ \fBsgid\fR).
-T}
-
-svuid	SVUID	T{
-see\ \fBsuid\fR.  (alias\ \fBsuid\fR).
-T}
-
-sz	SZ	T{
-size in physical pages of the core image of the process.
-This includes text, data, and stack space.
-Device mappings are currently excluded; this is subject to change.
-See \fBvsz\fR and \fBrss\fR.
-T}
-
-tgid	TGID	T{
-a number representing the thread group to which a task
-belongs (alias\ \fBpid\fR).
-It is the process ID of the thread group leader.
-T}
-
-thcount	THCNT	T{
-see \fBnlwp\fR.  (alias\ \fBnlwp\fR).
-number of kernel threads owned by the process.
-T}
-
-tid	TID	T{
-the unique number representing a dispatacable entity
-(alias\ \fBlwp\fR,\ \fBspid\fR).
-This value may also appear as: a process ID (pid);
-a process group ID (pgrp);
-a session ID for the session leader (sid);
-a thread group ID for the thread group leader (tgid);
-and a tty process group ID for the process group leader (tpgid).
-T}
-
-time	TIME	T{
-cumulative CPU\ time, "[DD\-]HH:MM:SS" format.  (alias\ \fBcputime\fR).
-T}
-
-tname	TTY	T{
-controlling tty (terminal).
-(alias\ \fBtt\fR,\ \fBtty\fR).
-T}
-
-tpgid	TPGID	T{
-ID of the foreground process group on the tty (terminal) that
-the process is connected to, or \-1 if the process is not connected
-to a tty.
-T}
-
-tt	TT	T{
-controlling tty (terminal).  (alias\ \fBtname\fR,\ \fBtty\fR).
-T}
-
-tty	TT	T{
-controlling tty (terminal).  (alias\ \fBtname\fR,\ \fBtt\fR).
-T}
-
-ucmd	CMD	T{
-see \fBcomm\fR.  (alias\ \fBcomm\fR,\ \fBucomm\fR).
-T}
-
-ucomm	COMMAND	T{
-see \fBcomm\fR.  (alias\ \fBcomm\fR,\ \fBucmd\fR).
-T}
-
-uid	UID	T{
-see \fBeuid\fR.  (alias\ \fBeuid\fR).
-T}
-
-uname	USER	T{
-see \fBeuser\fR.  (alias\ \fBeuser\fR,\ \fBuser\fR).
-T}
-
-user	USER	T{
-see \fBeuser\fR.  (alias\ \fBeuser\fR,\ \fBuname\fR).
-T}
-
-vsize	VSZ	T{
-see \fBvsz\fR.  (alias\ \fBvsz\fR).
-T}
-
-vsz	VSZ	T{
-virtual memory size of the process in KiB (1024\-byte\ units).
-Device mappings are currently excluded; this is subject to change.
-(alias\ \fBvsize\fR).
-T}
-
-wchan	WCHAN	T{
-name of the kernel function in which the process is sleeping,
-a\ "\-"\ if the process is running,
-or a "*"\ if the process is multi\-threaded and
-\fBps\fR is not displaying threads.
-T}
-.TE
-.\" #######################################################################
-.PP
-.PP
-.SH "ENVIRONMENT VARIABLES"
-The following environment variables could affect \fBps\fR:
-.TP 3
-.B COLUMNS
-Override default display width.
-.TP
-.B LINES
-Override default display height.
-.TP
-.B PS_PERSONALITY
-Set to one of posix, old, linux, bsd, sun, digital...
-(see\ section\ \fBPERSONALITY\fR\ below).
-.TP
-.B CMD_ENV
-Set to one of posix, old, linux, bsd, sun, digital...
-(see\ section\ \fBPERSONALITY\fR\ below).
-.TP
-.B I_WANT_A_BROKEN_PS
-Force obsolete command line interpretation.
-.TP
-.B LC_TIME
-Date format.
-.TP
-.B PS_COLORS
-Not currently supported.
-.TP
-.B PS_FORMAT
-Default output format override. You may set this to a format
-string of the type used for the \fB\-o\fR option.
-The \fBDefSysV\fR and \fBDefBSD\fR values are particularly useful.
-.TP
-.B PS_SYSMAP
-Default namelist (System.map) location.
-.TP
-.B PS_SYSTEM_MAP
-Default namelist (System.map) location.
-.TP
-.B POSIXLY_CORRECT
-Don't find excuses to ignore bad "features".
-.TP
-.B POSIX2
-When set to "on", acts as \fBPOSIXLY_CORRECT\fR.
-.TP
-.B UNIX95
-Don't find excuses to ignore bad "features".
-.TP
-.B _XPG
-Cancel \fBCMD_ENV\fI=irix\fR non\-standard behavior.
-.PP
-In general, it\ is a bad idea to set these variables.
-The one exception is \fBCMD_ENV\fR or \fBPS_PERSONALITY\fR,
-which could be set to Linux for normal systems.
-Without that setting,
-\fBps\fR follows the useless and bad parts of the Unix98 standard.
-.PP
-.PP
-.SH "PERSONALITY"
-.TS
-l	l.
-390	like the OS/390 OpenEdition \fBps\fR
-aix	like AIX \fBps\fR
-bsd	like FreeBSD \fBps\fR (totally\ non\-standard)
-compaq	like Digital Unix \fBps\fR
-debian	like the old Debian \fBps\fR
-digital	like Tru64 (was Digital\ Unix, was OSF/1) \fBps\fR
-gnu	like the old Debian \fBps\fR
-hp	like HP\-UX \fBps\fR
-hpux	like HP\-UX \fBps\fR
-irix	like Irix \fBps\fR
-linux	***** RECOMMENDED *****
-old	like the original Linux \fBps\fR (totally\ non\-standard)
-os390	like OS/390 Open Edition \fBps\fR
-posix	standard
-s390	like OS/390 Open Edition \fBps\fR
-sco	like SCO \fBps\fR
-sgi	like Irix \fBps\fR
-solaris2	like Solaris 2+ (SunOS 5) \fBps\fR
-sunos4	like SunOS 4 (Solaris 1) \fBps\fR (totally\ non\-standard)
-svr4	standard
-sysv	standard
-tru64	like Tru64 (was Digital\ Unix, was OSF/1) \fBps\fR
-unix	standard
-unix95	standard
-unix98	standard
-.TE
-.PP
-.PP
-.SH "SEE ALSO"
-\fBtop\fR(1), \fBpgrep\fR(1), \fBpstree\fR(1), \fBproc\fR(5).
-.PP
-.PP
-.SH STANDARDS
-This \fBps\fR conforms to:
-.PP
-.PD 0
-.IP 1 4
-Version 2 of the Single Unix Specification
-.IP 2 4
-The Open Group Technical Standard Base Specifications, Issue\ 6
-.IP 3 4
-IEEE Std 1003.1, 2004\ Edition
-.IP 4 4
-X/Open System Interfaces Extension [UP\ XSI]
-.IP 5 4
-ISO/IEC 9945:2003
-.PD
-.PP
-.SH AUTHOR
-\fBps\fR was originally written by Branko Lankester <lankeste@fwi.uva.nl>. Michael
-K. Johnson <johnsonm@redhat.com> re\-wrote it significantly to use the proc
-filesystem, changing a few things in the process. Michael Shields
-<mjshield@nyx.cs.du.edu> added the pid\-list feature. Charles Blake
-<cblake@bbn.com> added multi\-level sorting, the dirent\-style library, the
-device name\-to\-number mmaped database, the approximate binary search
-directly on System.map, and many code and documentation cleanups. David
-Mossberger\-Tang wrote the generic BFD support for psupdate. Albert Cahalan
-<albert@users.sf.net> rewrote ps for full Unix98 and BSD support, along with
-some ugly hacks for obsolete and foreign syntax.
-
-Please send bug reports to <procps@freelists.org>.
-No\ subscription is required or suggested.
diff --git a/ps/regression b/ps/regression
deleted file mode 100644
index c71c826a..00000000
--- a/ps/regression
+++ /dev/null
@@ -1,26 +0,0 @@
--u 500 -o pid,ppid,fname,comm,args           # right margin trouble
--u 500 -o pid,ppid,fname,comm,args,wchan,wchan,wchan,wchan,wchan,nice,wchan
--u 500 -o pid,pid,pid,pid,user,user,user,args   # had trouble
--u 500 -o user,user,user,pid,pid,pid,pid,args   # no trouble!
-
-Test with each type of field (RIGHT,LEFT,UNLIMITED...) hanging off the
-edge of the screen and each type of field to the left of the one that
-hangs off the edge.
-
-Test "ps ef" as _both_ normal user and root. Especially after su!
-
-On a 108-col screen, try "ps alx" and "ps alx | cat"
-
-These ought to be the same:
-CMD_ENV=old ps -m
-CMD_ENV=old ps m
-
-These ought to be the same:
-CMD_ENV=old ps -X
-CMD_ENV=old ps X
-ps X
-ps -X        # needs to be a non-SysV option
-
-This should fail:
-ps x -x
-
diff --git a/ps/select.c b/ps/select.c
deleted file mode 100644
index 2c52d02d..00000000
--- a/ps/select.c
+++ /dev/null
@@ -1,146 +0,0 @@
-/*
- * Copyright 1998-2002 by Albert Cahalan; all rights resered.         
- * This file may be used subject to the terms and conditions of the
- * GNU Library General Public License Version 2, or any later version  
- * at your option, as published by the Free Software Foundation.
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Library General Public License for more details.
- */                                 
-
-#include <string.h>
-#include <stdlib.h>
-#include <stdio.h>
-
-#include "common.h"
-#include "../proc/readproc.h"
-#include "../proc/procps.h"
-
-//#define process_group_leader(p) ((p)->pgid    == (p)->tgid)
-//#define some_other_user(p)      ((p)->euid    != cached_euid)
-#define has_our_euid(p)         ((unsigned)(p)->euid    == (unsigned)cached_euid)
-#define on_our_tty(p)           ((unsigned)(p)->tty == (unsigned)cached_tty)
-#define running(p)              (((p)->state=='R')||((p)->state=='D'))
-#define session_leader(p)       ((p)->session == (p)->tgid)
-#define without_a_tty(p)        (!(p)->tty)
-
-static unsigned long select_bits = 0;
-
-/***** prepare select_bits for use */
-const char *select_bits_setup(void){
-  int switch_val = 0;
-  /* don't want a 'g' screwing up simple_select */
-  if(!simple_select && !prefer_bsd_defaults){
-    select_bits = 0xaa00; /* the STANDARD selection */
-    return NULL;
-  }
-  /* For every BSD but SunOS, the 'g' option is a NOP. (enabled by default) */
-  if( !(personality & PER_NO_DEFAULT_g) && !(simple_select&(SS_U_a|SS_U_d)) )
-    switch_val = simple_select|SS_B_g;
-  else
-    switch_val = simple_select;
-  switch(switch_val){
-  /* UNIX options */
-  case SS_U_a | SS_U_d:           select_bits = 0x3f3f; break; /* 3333 or 3f3f */
-  case SS_U_a:                    select_bits = 0x0303; break; /* 0303 or 0f0f */
-  case SS_U_d:                    select_bits = 0x3333; break;
-  /* SunOS 4 only (others have 'g' enabled all the time) */
-  case 0:                         select_bits = 0x0202; break;
-  case                   SS_B_a:  select_bits = 0x0303; break;
-  case          SS_B_x         :  select_bits = 0x2222; break;
-  case          SS_B_x | SS_B_a:  select_bits = 0x3333; break;
-  /* General BSD options */
-  case SS_B_g                  :  select_bits = 0x0a0a; break;
-  case SS_B_g |          SS_B_a:  select_bits = 0x0f0f; break;
-  case SS_B_g | SS_B_x         :  select_bits = 0xaaaa; break;
-  case SS_B_g | SS_B_x | SS_B_a:  /* convert to -e instead of using 0xffff */
-    all_processes = 1;
-    simple_select = 0;
-    break;
-  default:
-    return "Process selection options conflict.";
-    break;
-  }
-  return NULL;
-}
-
-/***** selected by simple option? */
-static int table_accept(proc_t *buf){
-  unsigned proc_index;
-  proc_index = (has_our_euid(buf)    <<0)
-             | (session_leader(buf)  <<1)
-             | (without_a_tty(buf)   <<2)
-             | (on_our_tty(buf)      <<3);
-  return (select_bits & (1<<proc_index));
-}
-
-/***** selected by some kind of list? */
-static int proc_was_listed(proc_t *buf){
-  selection_node *sn = selection_list;
-  int i;
-  if(!sn) return 0;
-  while(sn){
-    switch(sn->typecode){
-    default:
-      printf("Internal error in ps! Please report this bug.\n");
-
-#define return_if_match(foo,bar) \
-        i=sn->n; while(i--) \
-        if((unsigned)(buf->foo) == (unsigned)(*(sn->u+i)).bar) \
-        return 1
-
-    break; case SEL_RUID: return_if_match(ruid,uid);
-    break; case SEL_EUID: return_if_match(euid,uid);
-    break; case SEL_SUID: return_if_match(suid,uid);
-    break; case SEL_FUID: return_if_match(fuid,uid);
-
-    break; case SEL_RGID: return_if_match(rgid,gid);
-    break; case SEL_EGID: return_if_match(egid,gid);
-    break; case SEL_SGID: return_if_match(sgid,gid);
-    break; case SEL_FGID: return_if_match(fgid,gid);
-
-    break; case SEL_PGRP: return_if_match(pgrp,pid);
-    break; case SEL_PID : return_if_match(tgid,pid);
-    break; case SEL_PPID: return_if_match(ppid,ppid);
-    break; case SEL_TTY : return_if_match(tty,tty);
-    break; case SEL_SESS: return_if_match(session,pid);
-
-    break; case SEL_COMM: i=sn->n; while(i--)
-    if(!strncmp( buf->cmd, (*(sn->u+i)).cmd, 15 )) return 1;
-
-
-
-#undef return_if_match
-
-    }
-    sn = sn->next;
-  }
-  return 0;
-}
-
-
-/***** This must satisfy Unix98 and as much BSD as possible */
-int want_this_proc(proc_t *buf){
-  int accepted_proc = 1; /* assume success */
-  /* elsewhere, convert T to list, U sets x implicitly */
-
-  /* handle -e -A */
-  if(all_processes) goto finish;
-
-  /* use table for -a a d g x */
-  if((simple_select || !selection_list))
-    if(table_accept(buf)) goto finish;
-
-  /* search lists */
-  if(proc_was_listed(buf)) goto finish;
-
-  /* fail, fall through to loose ends */
-  accepted_proc = 0;
-
-  /* do r N */
-finish:
-  if(running_only && !running(buf)) accepted_proc = 0;
-  if(negate_selection) return !accepted_proc;
-  return accepted_proc;
-}
diff --git a/ps/sortformat.c b/ps/sortformat.c
deleted file mode 100644
index dec351e8..00000000
--- a/ps/sortformat.c
+++ /dev/null
@@ -1,955 +0,0 @@
-/*
- * Copyright 1998-2004 by Albert Cahalan; all rights resered.         
- * This file may be used subject to the terms and conditions of the
- * GNU Library General Public License Version 2, or any later version  
- * at your option, as published by the Free Software Foundation.
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Library General Public License for more details.
- */                                 
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-
-/* username lookups */
-#include <sys/types.h>
-#include <pwd.h>
-#include <grp.h>
-
-#include "../proc/readproc.h"
-#include "../proc/sysinfo.h"
-#include "common.h"
-
-static sf_node *sf_list = NULL;         /* deferred sorting and formatting */
-static int broken;                      /* use gross Unix98 parsing? */
-static int have_gnu_sort = 0;           /* if true, "O" must be format */
-static int already_parsed_sort = 0;     /* redundantly set in & out of fn */
-static int already_parsed_format = 0;
-
-
-/****************  Parse single format specifier *******************/
-static format_node *do_one_spec(const char *spec, const char *override){
-  const format_struct *fs;
-  const macro_struct *ms;
-
-  fs = search_format_array(spec);
-  if(fs){
-    int w1, w2;
-    format_node *thisnode;
-    thisnode = malloc(sizeof(format_node));
-    if(fs->flags & CF_PIDMAX){
-      w1 = (int)get_pid_digits();
-      w2 = strlen(fs->head);
-      if(w2>w1) w1=w2; // FIXME w/ separate header/body column sizing
-    }else{
-      w1 = fs->width;
-    }
-    if(override){
-      w2 = strlen(override);
-      thisnode->width = (w1>w2)?w1:w2;
-      thisnode->name = malloc(strlen(override)+1);
-      strcpy(thisnode->name, override);
-    }else{
-      thisnode->width = w1;
-      thisnode->name = malloc(strlen(fs->head)+1);
-      strcpy(thisnode->name, fs->head);
-    }
-    thisnode->pr = fs->pr;
-    thisnode->need = fs->need;
-    thisnode->vendor = fs->vendor;
-    thisnode->flags = fs->flags;
-    thisnode->next = NULL;
-    return thisnode;
-  }
-
-  /* That failed, so try it as a macro. */
-  ms = search_macro_array(spec);
-  if(ms){
-    format_node *list = NULL;
-    format_node *newnode;
-    const char *walk;
-    int dist;
-    char buf[16]; /* trust strings will be short (from above, not user) */
-    walk = ms->head;
-    while(*walk){
-      dist = strcspn(walk, ", ");
-      strncpy(buf,walk,dist);
-      buf[dist] = '\0';
-      newnode = do_one_spec(buf,override); /* call self, assume success */
-      newnode->next = list;
-      list = newnode;
-      walk += dist;
-      if(*walk) walk++;
-    }
-    return list;
-  }
-  return NULL;   /* bad, spec not found */
-}
-
-
-/************ must wrap user format in default *************/
-static void O_wrap(sf_node *sfn, int otype){
-  format_node *fnode;
-  format_node *endp;
-  const char *trailer;
-
-  trailer = (otype=='b') ? "END_BSD" : "END_SYS5" ;
-
-  fnode =  do_one_spec("pid",NULL);
-  if(!fnode)fprintf(stderr,"Seriously crashing. Goodbye cruel world.\n");
-  endp = sfn->f_cooked; while(endp->next) endp = endp->next;  /* find end */
-  endp->next = fnode;
-  
-  fnode =  do_one_spec(trailer,NULL);
-  if(!fnode) { fprintf(stderr,"Seriously crashing. Goodbye cruel world.\n"); exit(1); }
-  endp = fnode; while(endp->next) endp = endp->next;  /* find end */
-  endp->next = sfn->f_cooked;
-  sfn->f_cooked = fnode;
-}
-
-/******************************************************************
- * Used to parse option AIX field descriptors.
- * Put each completed format_node onto the list starting at ->f_cooked
- */
-static const char *aix_format_parse(sf_node *sfn){
-  char *buf;                   /* temp copy of arg to hack on */
-  char *walk;
-  int items;
-
-  /*** sanity check and count items ***/
-  items = 0;
-  walk = sfn->sf;
-  /* state machine */ {
-  int c;
-  initial:
-    c = *walk++;
-    if(c=='%')    goto get_desc;
-    if(!c)        goto looks_ok;
-  /* get_text: */
-    items++;
-  get_more_text:
-    c = *walk++;
-    if(c=='%')    goto get_desc;
-    if(c)         goto get_more_text;
-    goto looks_ok;
-  get_desc:
-    items++;
-    c = *walk++;
-    if(c)         goto initial;
-    return "Improper AIX field descriptor.";
-  looks_ok:
-    ;
-  }
-
-  /*** sanity check passed ***/
-  buf = malloc(strlen(sfn->sf)+1);
-  strcpy(buf, sfn->sf);
-  walk = sfn->sf;
-  
-  while(items--){
-    format_node *fnode;  /* newly allocated */
-    format_node *endp;   /* for list manipulation */
-
-    if(*walk == '%'){
-      const aix_struct *aix;
-      walk++;
-      if(*walk == '%') goto double_percent;
-      aix = search_aix_array(*walk);
-      walk++;
-      if(!aix){
-        free(buf);
-        return "Unknown AIX field descriptor.";
-      }
-      fnode =  do_one_spec(aix->spec, aix->head);
-      if(!fnode){
-        free(buf);
-        return "AIX field descriptor processing bug.";
-      }
-    } else {
-      int len;
-      len = strcspn(walk, "%");
-      memcpy(buf,walk,len);
-      if(0){
-double_percent:
-        len = 1;
-        buf[0] = '%';
-      }
-      buf[len] = '\0';
-      walk += len;
-      fnode = malloc(sizeof(format_node));
-      fnode->width = len;
-      fnode->name = malloc(len+1);
-      strcpy(fnode->name, buf);
-      fnode->pr = NULL;     /* checked for */
-      fnode->need = 0;
-      fnode->vendor = AIX;
-      fnode->flags = CF_PRINT_EVERY_TIME;
-      fnode->next = NULL;
-    }
-    
-    endp = fnode; while(endp->next) endp = endp->next;  /* find end */
-    endp->next = sfn->f_cooked;
-    sfn->f_cooked = fnode;
-  }
-  free(buf);
-  already_parsed_format = 1;
-  return NULL;
-}
-
-/***************************************************************
- * Used to parse option O lists. Option O is shared between
- * sorting and formatting. Users may expect one or the other.
- * The "broken" flag enables a really bad Unix98 misfeature.
- * Put each completed format_node onto the list starting at ->f_cooked
- */
-static const char *format_parse(sf_node *sfn){
-  char *buf;                   /* temp copy of arg to hack on */
-  char *sep_loc;               /* separator location: " \t,\n" */
-  char *walk;
-  const char *err;       /* error code that could or did happen */
-  format_node *fnode;
-  int items;
-  int need_item;
-  static char errbuf[80]; /* for variable-text error message */
-
-  /*** prepare to operate ***/
-  buf = malloc(strlen(sfn->sf)+1);
-  strcpy(buf, sfn->sf);
-  
-  /*** sanity check and count items ***/
-  need_item = 1; /* true */
-  items = 0;
-  walk = buf;
-  do{
-    switch(*walk){
-    case ' ': case ',': case '\t': case '\n': case '\0':
-    /* Linux extension: allow \t and \n as delimiters */
-      if(need_item){
-        free(buf);
-        goto improper;
-      }
-      need_item=1;
-      break;
-    case '=':
-      if(broken) goto out;
-      /* fall through */
-    default:
-      if(need_item) items++;
-      need_item=0;
-    }
-  } while (*++walk);
-out:
-  if(!items){
-    free(buf);
-    goto empty;
-  }
-#ifdef STRICT_LIST
-  if(need_item){    /* can't have trailing deliminator */
-    free(buf);
-    goto improper;
-  }
-#else
-  if(need_item){    /* allow 1 trailing deliminator */
-    *--walk='\0';  /* remove the trailing deliminator */
-  }
-#endif
-  /*** actually parse the list ***/
-  walk = buf;
-  while(items--){
-    format_node *endp;
-    char *equal_loc;
-    char *colon_loc;
-    sep_loc = strpbrk(walk," ,\t\n");
-    /* if items left, then sep_loc is not in header override */
-    if(items && sep_loc) *sep_loc = '\0';
-    equal_loc = strpbrk(walk,"=");
-    if(equal_loc){   /* if header override */
-      *equal_loc = '\0';
-      equal_loc++;
-    }
-    colon_loc = strpbrk(walk,":");
-    if(colon_loc){   /* if width override */
-      *colon_loc = '\0';
-      colon_loc++;
-      if(strspn(colon_loc,"0123456789") != strlen(colon_loc) || *colon_loc=='0' || !*colon_loc){
-        free(buf);
-        goto badwidth;
-      }
-    }
-    fnode =  do_one_spec(walk,equal_loc);
-    if(!fnode){
-      if(!*errbuf){  /* if didn't already create an error string */
-        snprintf(
-          errbuf,
-          sizeof(errbuf),
-          "Unknown user-defined format specifier \"%s\".",
-          walk
-        );
-      }
-      free(buf);
-      goto unknown;
-    }
-    if(colon_loc){
-      if(fnode->next){
-        free(buf);
-        goto notmacro;
-      }
-      // FIXME: enforce signal width to 8, 9, or 16 (grep: SIGNAL wide_signals)
-      fnode->width = atoi(colon_loc); // already verified to be a number
-    }
-    endp = fnode; while(endp->next) endp = endp->next;  /* find end */
-    endp->next = sfn->f_cooked;
-    sfn->f_cooked = fnode;
-    walk = sep_loc + 1; /* point to next item, if any */
-  }
-  free(buf);
-  already_parsed_format = 1;
-  return NULL;
-
-  /* errors may cause a retry looking for AIX format codes */
-  if(0) unknown:  err=errbuf;
-  if(0) empty:    err="Empty format list.";
-  if(0) improper: err="Improper format list.";
-  if(0) badwidth: err="Column widths must be unsigned decimal numbers.";
-  if(0) notmacro: err="Can't set width for a macro (multi-column) format specifier.";
-  if(strchr(sfn->sf,'%')) err = aix_format_parse(sfn);
-  return err;
-}
-
-/****************  Parse single sort specifier *******************/
-static sort_node *do_one_sort_spec(const char *spec){
-  const format_struct *fs;
-  int reverse = 0;
-  if(*spec == '-'){
-    reverse = 1;
-    spec++;
-  } else if(*spec == '+'){
-    spec++;
-  }
-  fs = search_format_array(spec);
-  if(fs){
-    sort_node *thisnode;
-    thisnode = malloc(sizeof(sort_node));
-    thisnode->sr = fs->sr;
-    thisnode->need = fs->need;
-    thisnode->reverse = reverse;
-    thisnode->next = NULL;
-    return thisnode;
-  }
-  return NULL;   /* bad, spec not found */
-}
-
-
-/**************************************************************
- * Used to parse long sorting options.
- * Put each completed sort_node onto the list starting at ->s_cooked
- */
-static const char *long_sort_parse(sf_node *sfn){
-  char *buf;                   /* temp copy of arg to hack on */
-  char *sep_loc;               /* separator location: " \t,\n" */
-  char *walk;
-  sort_node *snode;
-  int items;
-  int need_item;
-
-  /*** prepare to operate ***/
-  buf = malloc(strlen(sfn->sf)+1);
-  strcpy(buf, sfn->sf);
-  
-  /*** sanity check and count items ***/
-  need_item = 1; /* true */
-  items = 0;
-  walk = buf;
-  do{
-    switch(*walk){
-    case ' ': case ',': case '\t': case '\n': case '\0':
-      if(need_item){
-        free(buf);
-        return "Improper sort list";
-      }
-      need_item=1;
-      break;
-    default:
-      if(need_item) items++;
-      need_item=0;
-    }
-  } while (*++walk);
-  if(!items){
-    free(buf);
-    return "Empty sort list.";
-  }
-#ifdef STRICT_LIST
-  if(need_item){    /* can't have trailing deliminator */
-    free(buf);
-    return "Improper sort list.";
-  }
-#else
-  if(need_item){    /* allow 1 trailing deliminator */
-    *--walk='\0';  /* remove the trailing deliminator */
-  }
-#endif
-  /*** actually parse the list ***/
-  walk = buf;
-  while(items--){
-    sort_node *endp;
-    sep_loc = strpbrk(walk," ,\t\n");
-    if(sep_loc) *sep_loc = '\0';
-    snode = do_one_sort_spec(walk);
-    if(!snode){
-      free(buf);
-      return "Unknown sort specifier.";
-    }
-    endp = snode; while(endp->next) endp = endp->next;  /* find end */
-    endp->next = sfn->s_cooked;
-    sfn->s_cooked = snode;
-    walk = sep_loc + 1; /* point to next item, if any */
-  }
-  free(buf);
-  already_parsed_sort = 1;
-  return NULL;
-}
-
-
-
-
-
-
-/************ pre-parse short sorting option *************/
-/* Errors _must_ be detected so that the "O" option can try to
- * reparse as formatting codes.
- */
-static const char *verify_short_sort(const char *arg){
-  const char all[] = "CGJKMNPRSTUcfgjkmnoprstuvy+-";
-  char checkoff[256];
-  int i;
-  const char *walk;
-  int tmp;
-  if(strspn(arg,all) != strlen(arg)) return "Bad sorting code.";
-  for(i=256; i--;) checkoff[i] = 0;
-  walk = arg;
-  for(;;){
-    tmp = *walk;
-    switch(tmp){
-    case '\0':
-      return NULL;   /* looks good */
-    case '+':
-    case '-':
-      tmp = *(walk+1);
-      if(!tmp || tmp=='+' || tmp=='-') return "Bad sorting code.";
-      break;
-    case 'P':
-      if(forest_type) return "PPID sort and forest output conflict.";
-      /* fall through */
-    default:
-      if(checkoff[tmp]) return "Bad sorting code.";   /* repeated */
-      /* ought to check against already accepted sort options */
-      checkoff[tmp] = 1;
-      break;
-    }
-    walk++;
-  }
-}
-
-
-
-/************ parse short sorting option *************/
-static const char *short_sort_parse(sf_node *sfn){
-  int direction = 0;
-  const char *walk;
-  int tmp;
-  sort_node *snode;
-  sort_node *endp;
-  const struct shortsort_struct *ss;
-  walk = sfn->sf;
-  for(;;){
-    tmp = *walk;
-    switch(tmp){
-    case '\0':
-      already_parsed_sort = 1;
-      return NULL;
-    case '+':
-      direction = 0;
-      break;
-    case '-':
-      direction = 1;
-      break;
-    default:
-      ss = search_shortsort_array(tmp);
-      if(!ss) return "Unknown sort specifier.";
-      snode = do_one_sort_spec(ss->spec);
-      if(!snode) return "Unknown sort specifier.";
-      snode->reverse = direction;
-      endp = snode; while(endp->next) endp = endp->next;  /* find end */
-      endp->next = sfn->s_cooked;
-      sfn->s_cooked = snode;
-      direction = 0;
-      break;
-    }
-    walk++;
-  }
-}
-
-/******************* high-level below here *********************/
-
-
-/*
- * Used to parse option O lists. Option O is shared between
- * sorting and formatting. Users may expect one or the other.
- * The "broken" flag enables a really bad Unix98 misfeature.
- * Recursion is to preserve original order.
- */
-static const char *parse_O_option(sf_node *sfn){
-  const char *err;     /* error code that could or did happen */
-
-  if(sfn->next){
-    err = parse_O_option(sfn->next);
-    if(err) return err;
-  }
-
-  switch(sfn->sf_code){
-    case SF_B_o: case SF_G_format: case SF_U_o: /*** format ***/
-      err = format_parse(sfn);
-      if(!err) already_parsed_format = 1;
-      break;
-    case SF_U_O:                                /*** format ***/
-      /* Can have -l -f f u... set already_parsed_format like DEC does */
-      if(already_parsed_format) return "option -O can not follow other format options.";
-      err = format_parse(sfn);
-      if(err) return err;
-      already_parsed_format = 1;
-      O_wrap(sfn,'u'); /* must wrap user format in default */
-      break;
-    case SF_B_O:                                /***  both  ***/
-      if(have_gnu_sort || already_parsed_sort) err = "Multiple sort options.";
-      else err = verify_short_sort(sfn->sf);
-      if(!err){ /* success as sorting code */
-        short_sort_parse(sfn);
-        already_parsed_sort = 1;
-        return NULL;
-      }
-      if(already_parsed_format){
-        err = "option O is neither first format nor sort order.";
-        break;
-      }
-      if(!format_parse(sfn)){ /* if success as format code */
-        already_parsed_format = 1;
-        O_wrap(sfn,'b'); /* must wrap user format in default */
-        return NULL;
-      }
-      break;
-    case SF_G_sort: case SF_B_m:                 /***  sort  ***/
-      if(already_parsed_sort) err = "Multiple sort options.";
-      else err = long_sort_parse(sfn);
-      already_parsed_sort = 1;
-      break;
-    default:                                    /***  junk  ***/
-      return "Bug: parse_O_option got weirdness!";
-  }
-  return err; /* could be NULL */
-}
-
-
-/************ Main parser calls this to save lists for later **********/
-/* store data for later and return 1 if arg looks non-standard */
-int defer_sf_option(const char *arg, int source){
-  sf_node *sfn;
-  char buf[16];
-  int dist;
-  const format_struct *fs;
-  int need_item = 1;
-
-  sfn = malloc(sizeof(sf_node));
-  sfn->sf = malloc(strlen(arg)+1);
-  strcpy(sfn->sf, arg);
-  sfn->sf_code = source;
-  sfn->s_cooked = NULL;
-  sfn->f_cooked = NULL;
-  sfn->next = sf_list;
-  sf_list = sfn;
-
-  if(source == SF_G_sort) have_gnu_sort = 1;
-
-  /* Now try to find an excuse to ignore broken Unix98 parsing. */
-  if(source != SF_U_o) return 1;    /* Wonderful! Already non-Unix98. */
-  do{
-    switch(*arg){
-    case ' ': case ',': case '\0':  /* no \t\n\r support in Unix98 */
-      if(need_item) return 1;       /* something wrong */
-      need_item=1;
-      break;
-    case '=':
-      if(need_item) return 1;       /* something wrong */
-      return 0;                     /* broken Unix98 parsing is required */
-    default:
-      if(!need_item) break;
-      need_item=0;
-      dist = strcspn(arg,", =");
-      if(dist>15) return 1;         /* something wrong, sort maybe? */
-      strncpy(buf,arg,dist);   /* no '\0' on end */
-      buf[dist] = '\0';        /* fix that problem */
-      fs = search_format_array(buf);
-      if(!fs) return 1;             /* invalid spec, macro or sort maybe? */
-      if(fs->vendor) return 1;      /* Wonderful! Legal non-Unix98 spec. */
-    }
-  } while (*++arg);
-
-  return 0;                         /* boring, Unix98 is no change */
-}
-
-/***** Since ps is not long-lived, the memory leak can be ignored. ******/
-void reset_sortformat(void){
-  sf_list = NULL;          /* deferred sorting and formatting */
-  format_list = NULL;      /* digested formatting options */
-  sort_list = NULL;        /* digested sorting options (redundant?) */
-  have_gnu_sort = 0;
-  already_parsed_sort = 0;
-  already_parsed_format = 0;
-}
-
-
-/***** Search format_list for findme, then insert putme after findme. ****/
-static int fmt_add_after(const char *findme, format_node *putme){
-  format_node *walk;
-  if(!strcmp(format_list->name, findme)){
-    putme->next = format_list->next;
-    format_list->next = putme;
-    return 1; /* success */
-  }
-  walk = format_list;
-  while(walk->next){
-    if(!strcmp(walk->next->name, findme)){
-      putme->next = walk->next->next;
-      walk->next->next = putme;
-      return 1; /* success */
-    }
-    walk = walk->next;
-  }
-  return 0; /* fail */
-}
-
-/******* Search format_list for findme, then delete it. ********/
-static int fmt_delete(const char *findme){
-  format_node *walk;
-  format_node *old;
-  if(!strcmp(format_list->name, findme)){
-    old = format_list;
-    format_list = format_list->next;
-    free(old);
-    return 1; /* success */
-  }
-  walk = format_list;
-  while(walk->next){
-    if(!strcmp(walk->next->name, findme)){
-      old = walk->next;
-      walk->next = walk->next->next;
-      free(old);
-      return 1; /* success */
-    }
-    walk = walk->next;
-  }
-  return 0; /* fail */
-}
-
-
-/************ Build a SysV format backwards. ***********/
-#define PUSH(foo) (fn=do_one_spec(foo, NULL), fn->next=format_list, format_list=fn)
-static const char *generate_sysv_list(void){
-  format_node *fn;
-  if((format_modifiers & FM_y) && !(format_flags & FF_Ul))
-    return "Modifier -y without format -l makes no sense.";
-  if(prefer_bsd_defaults){
-    if(format_flags) PUSH("cmd");
-    else PUSH("args");
-    PUSH("bsdtime");
-    if(!(format_flags & FF_Ul)) PUSH("stat");
-  }else{
-    if(format_flags & FF_Uf) PUSH("cmd");
-    else PUSH("ucmd");
-    PUSH("time");
-  }
-  PUSH("tname");  /* Unix98 says "TTY" here, yet "tty" produces "TT". */
-  if(format_flags & FF_Uf) PUSH("stime");
-  /* avoid duplicate columns from -FP and -Fly */
-  if(format_modifiers & FM_F){
-    /* if -FP take the Sun-style column instead (sorry about "sgi_p") */
-    if(!(format_modifiers & FM_P)) PUSH("psr");  /* should be ENG */
-    /* if -Fly take the ADDR-replacement RSS instead */
-    if(!( (format_flags & FF_Ul) && (format_modifiers & FM_y) )) PUSH("rss");
-  }
-  if(format_flags & FF_Ul){
-    PUSH("wchan");
-  }
-  /* since FM_y adds RSS anyway, don't do this hack when that is true */
-  if( (format_flags & FF_Ul) && !(format_modifiers & FM_y) ){
-    if(personality & PER_IRIX_l){ /* add "rss" then ':' here */
-      PUSH("sgi_rss");
-      fn = malloc(sizeof(format_node));
-      fn->width = 1;
-      fn->name = malloc(2);
-      strcpy(fn->name, ":");
-      fn->pr = NULL;     /* checked for */
-      fn->need = 0;
-      fn->vendor = AIX;   /* yes, for SGI weirdness */
-      fn->flags = CF_PRINT_EVERY_TIME;
-      fn->next = format_list;
-      format_list=fn;
-    }
-  }
-  if((format_modifiers & FM_F) || (format_flags & FF_Ul)){
-    PUSH("sz");
-  }
-  if(format_flags & FF_Ul){
-    if(format_modifiers & FM_y) PUSH("rss");
-    else if(personality & (PER_ZAP_ADDR|PER_IRIX_l)) PUSH("sgi_p");
-    else PUSH("addr_1");
-  }
-  if(format_modifiers & FM_c){
-    PUSH("pri"); PUSH("class");
-  }else if(format_flags & FF_Ul){
-    PUSH("ni");
-    if(personality & PER_IRIX_l) PUSH("priority");
-    else /* is this good? */ PUSH("opri");
-  }
-
-  // FIXME TODO XXX -- this is a serious problem
-  // These somehow got flipped around.
-  // The bug is in procps-3.1.1, procps-990211, prior too?
-  if((thread_flags & TF_U_L) && (format_flags & FF_Uf)) PUSH("nlwp");
-  if( (format_flags & (FF_Uf|FF_Ul)) && !(format_modifiers & FM_c) ) PUSH("c");
-
-  if(format_modifiers & FM_P) PUSH("psr");
-  if(thread_flags & TF_U_L) PUSH("lwp");
-  if(format_modifiers & FM_j){
-    PUSH("sid");
-    PUSH("pgid");
-  }
-  if(format_flags & (FF_Uf|FF_Ul)) PUSH("ppid");
-  if(thread_flags & TF_U_T) PUSH("spid");
-  PUSH("pid");
-  if(format_flags & FF_Uf){
-    if(personality & PER_SANE_USER) PUSH("user");
-    else PUSH("uid_hack");
-  }else if(format_flags & FF_Ul){
-    PUSH("uid");
-  }
-  if(format_flags & FF_Ul){
-    PUSH("s");
-    if(!(format_modifiers & FM_y)) PUSH("f");
-  }
-  if(format_modifiers & FM_M){
-    PUSH("label");  /* Mandatory Access Control */
-  }
-  return NULL;
-}
-
-
-/**************************************************************************
- * Used to parse option O lists. Option O is shared between
- * sorting and formatting. Users may expect one or the other.
- * The "broken" flag enables a really bad Unix98 misfeature.
- */
-const char *process_sf_options(int localbroken){
-  sf_node *sf_walk;
-
-  if(personality & PER_BROKEN_o) localbroken = 1;
-  if(personality & PER_GOOD_o)   localbroken = 0;
-  broken = localbroken;
-  if(sf_list){
-    const char *err;
-    err = parse_O_option(sf_list);
-    if(err) return err;
-  }
-
-  if(format_list) printf("Bug: must reset the list first!\n");
-
-  /* merge formatting info of sf_list into format_list here */
-  sf_walk = sf_list;
-  while(sf_walk){
-    format_node *fmt_walk;
-    fmt_walk = sf_walk->f_cooked;
-    sf_walk->f_cooked = NULL;
-    while(fmt_walk){   /* put any nodes onto format_list in opposite way */
-      format_node *travler;
-      travler = fmt_walk;
-      fmt_walk = fmt_walk->next;
-      travler->next = format_list;
-      format_list = travler;
-    }
-    sf_walk = sf_walk->next;
-  }
-
-  /* merge sorting info of sf_list into sort_list here */
-  sf_walk = sf_list;
-  while(sf_walk){
-    sort_node *srt_walk;
-    srt_walk = sf_walk->s_cooked;
-    sf_walk->s_cooked = NULL;
-    while(srt_walk){   /* put any nodes onto sort_list in opposite way */
-      sort_node *travler;
-      travler = srt_walk;
-      srt_walk = srt_walk->next;
-      travler->next = sort_list;
-      sort_list = travler;
-    }
-    sf_walk = sf_walk->next;
-  }
-
-  // Get somebody to explain how -L/-T is supposed to interact
-  // with sorting. Do the threads remain grouped, with sorting
-  // by process, or do the threads get sorted by themselves?
-  if(sort_list && (thread_flags&TF_no_sort)){
-    return "Tell procps@freelists.org what you expected.";
-  }
-
-  // If nothing else, try to use $PS_FORMAT before the default.
-  if(!format_flags && !format_modifiers && !format_list){
-    char *tmp;
-    tmp = getenv("PS_FORMAT");  /* user override kills default */
-    if(tmp && *tmp){
-      const char *err;
-      sf_node sfn;
-      if(thread_flags&TF_must_use) return "Tell procps@freelists.org what you want. (-L/-T, -m/m/H, and $PS_FORMAT)";
-      sfn.sf = tmp;
-      sfn.f_cooked = NULL;
-      err = format_parse(&sfn);
-      if(!err){
-        format_node *fmt_walk;
-        fmt_walk = sfn.f_cooked;
-        while(fmt_walk){   /* put any nodes onto format_list in opposite way */
-          format_node *travler;
-          travler = fmt_walk;
-          fmt_walk = fmt_walk->next;
-          travler->next = format_list;
-          format_list = travler;
-        }
-        return NULL;
-      }
-      // FIXME: prove that this won't be hit on valid bogus-BSD options
-      fprintf(stderr, "Warning: $PS_FORMAT ignored. (%s)\n", err);
-    }
-  }
-
-  if(format_list){
-    if(format_flags) return "Conflicting format options.";
-    if(format_modifiers) return "Can't use output modifiers with user-defined output";
-    if(thread_flags&TF_must_use) return "-L/-T with H/m/-m and -o/-O/o/O is nonsense";
-    return NULL;
-  }
-
-  do{
-    const char *spec;
-    switch(format_flags){
-
-    default:             return "Conflicting format options.";
-
-    /* These can be NULL, which enables SysV list generation code. */
-    case 0:              spec=NULL;           break;
-    case FF_Uf | FF_Ul:  spec=sysv_fl_format; break;
-    case FF_Uf:          spec=sysv_f_format;  break;
-    case FF_Ul:          spec=sysv_l_format;  break;
-
-    /* These are NOT REACHED for normal -j processing. */
-    case FF_Uj:          spec=sysv_j_format;  break; /* Debian & Digital */
-    case FF_Uj | FF_Ul:  spec="RD_lj";        break; /* Debian */
-    case FF_Uj | FF_Uf:  spec="RD_fj";        break; /* Debian */
-
-    /* These are true BSD options. */
-    case FF_Bj:          spec=bsd_j_format;   break;
-    case FF_Bl:          spec=bsd_l_format;   break;
-    case FF_Bs:          spec=bsd_s_format;   break;
-    case FF_Bu:          spec=bsd_u_format;   break;
-    case FF_Bv:          spec=bsd_v_format;   break;
-
-    /* These are old Linux options. Option m is overloaded. */
-    case FF_LX:          spec="OL_X";         break;
-    case FF_Lm:          spec="OL_m";         break;
-
-    /* This is the sole FLASK security option. */
-    case FF_Fc:          spec="FLASK_context"; break;
-
-    }  /* end switch(format_flags) */
-
-    // not just for case 0, since sysv_l_format and such may be NULL
-    if(!spec) return generate_sysv_list();
-
-    do{
-      format_node *fmt_walk;
-      fmt_walk = do_one_spec(spec, NULL); /* use override "" for no headers */
-      while(fmt_walk){   /* put any nodes onto format_list in opposite way */
-        format_node *travler;
-        travler = fmt_walk;
-        fmt_walk = fmt_walk->next;
-        travler->next = format_list;
-        format_list = travler;
-      }
-    }while(0);
-  }while(0);
-
-  do{
-    format_node *fn;
-    if(format_modifiers & FM_j){
-      fn = do_one_spec("pgid", NULL);
-      if(!fmt_add_after("PPID", fn)) if(!fmt_add_after("PID", fn))
-        return "Internal error, no PID or PPID for -j option.";
-      fn = do_one_spec("sid", NULL);
-      if(!fmt_add_after("PGID", fn)) return "Lost my PGID!";
-    }
-    if(format_modifiers & FM_y){
-      /* TODO: check for failure to do something, and complain if so */
-      fmt_delete("F");
-      fn = do_one_spec("rss", NULL);
-      if(fmt_add_after("ADDR", fn)) fmt_delete("ADDR");
-    }
-    if(format_modifiers & FM_c){
-      fmt_delete("%CPU"); fmt_delete("CPU"); fmt_delete("CP"); fmt_delete("C");
-      fmt_delete("NI");
-      fn = do_one_spec("class", NULL);
-      if(!fmt_add_after("PRI", fn))
-        return "Internal error, no PRI for -c option.";
-      fmt_delete("PRI"); /* we want a different one */
-      fn = do_one_spec("pri", NULL);
-      if(!fmt_add_after("CLS", fn)) return "Lost my CLS!";
-    }
-    if(thread_flags & TF_U_T){
-      fn = do_one_spec("spid", NULL);
-      if(!fmt_add_after("PID", fn) && (thread_flags&TF_must_use))
-        return "-T with H/-m/m but no PID for SPID to follow";
-    }
-    if(thread_flags & TF_U_L){
-      fn = do_one_spec("lwp", NULL);
-      if(fmt_add_after("SID",  fn)) goto did_lwp;
-      if(fmt_add_after("SESS", fn)) goto did_lwp;
-      if(fmt_add_after("PGID", fn)) goto did_lwp;
-      if(fmt_add_after("PGRP", fn)) goto did_lwp;
-      if(fmt_add_after("PPID", fn)) goto did_lwp;
-      if(fmt_add_after("PID",  fn)) goto did_lwp;
-      if(thread_flags&TF_must_use)
-        return "-L with H/-m/m but no PID/PGID/SID/SESS for NLWP to follow";
-did_lwp:
-      fn = do_one_spec("nlwp", NULL);
-      fmt_add_after("%CPU",  fn);
-    }
-    if(format_modifiers & FM_M){    // Mandatory Access Control, IRIX style
-      fn = do_one_spec("label", NULL);
-      fn->next=format_list;
-      format_list=fn;
-    }
-    /* Do personality-specific translations not covered by format_flags.
-     * Generally, these only get hit when personality overrides unix output.
-     * That (mostly?) means the Digital and Debian personalities.
-     */
-    if((personality & PER_ZAP_ADDR) && (format_flags & FF_Ul)){
-      fn = do_one_spec("sgi_p", NULL);
-      if(fmt_add_after("ADDR", fn)) fmt_delete("ADDR");
-    }
-    if((personality & PER_SANE_USER) && (format_flags & FF_Uf)){
-      fn = do_one_spec("user", NULL);
-      if(fmt_add_after("UID", fn)) fmt_delete("UID");
-    }
-  }while(0);
-
-  return NULL;
-}
-
diff --git a/ps/stacktrace.c b/ps/stacktrace.c
deleted file mode 100644
index 79814bb3..00000000
--- a/ps/stacktrace.c
+++ /dev/null
@@ -1,165 +0,0 @@
-/*
- * Gnu debugger stack trace code provided by Peter Mattis
- * <petm@CSUA.Berkeley.EDU> on Thu, 2 Nov 1995
- *
- * Modified for easy use by Albert Cahalan.
- */
-
-#include <unistd.h>
-#include <errno.h>
-#include <signal.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <sys/types.h>
-#include <sys/wait.h>
-#include <sys/time.h>
-
-#define INTERACTIVE 0
-#define STACK_TRACE 1
-
-char *stored_prog_name = "You forgot to set \"program\"";
-static int stack_trace_done;
-
-/***********/
-static void debug_stop(char **args){
-  execvp (args[0], args);
-  perror ("exec failed");
-  _exit (0);
-}
-
-/***********/
-static void stack_trace_sigchld(int signum){
-  stack_trace_done = 1;
-}
-
-/************/
-static void stack_trace(char **args){
-  pid_t pid;
-  int in_fd[2];
-  int out_fd[2];
-  fd_set fdset;
-  fd_set readset;
-  struct timeval tv;
-  int sel, index, state;
-  char buffer[256];
-  char c;
-
-  stack_trace_done = 0;
-  signal(SIGCHLD, stack_trace_sigchld);
-  
-  if((pipe (in_fd) == -1) || (pipe (out_fd) == -1)){
-    perror ("could open pipe");
-    _exit (0);
-  }
-
-  pid = fork ();
-  if (pid == 0){
-    close (0); dup (in_fd[0]);   /* set the stdin to the in pipe */
-    close (1); dup (out_fd[1]);  /* set the stdout to the out pipe */
-    close (2); dup (out_fd[1]);  /* set the stderr to the out pipe */
-    execvp (args[0], args);      /* exec gdb */
-    perror ("exec failed");
-    _exit (0);
-  } else {
-    if(pid == (pid_t) -1){
-      perror ("could not fork");
-      _exit (0);
-    }
-  }
-
-  FD_ZERO (&fdset);
-  FD_SET (out_fd[0], &fdset);
-
-  write (in_fd[1], "backtrace\n", 10);
-  write (in_fd[1], "p x = 0\n", 8);
-  write (in_fd[1], "quit\n", 5);
-  
-  index = 0;
-  state = 0;
-  
-  for(;;){
-    readset = fdset;
-    tv.tv_sec = 1;
-    tv.tv_usec = 0;
-
-    sel = select (FD_SETSIZE, &readset, NULL, NULL, &tv);
-    if (sel == -1) break;
-    
-    if((sel > 0) && (FD_ISSET (out_fd[0], &readset))){
-      if(read (out_fd[0], &c, 1)){
-        switch(state){
-        case 0:
-          if(c == '#'){
-            state = 1;
-            index = 0;
-            buffer[index++] = c;
-          }
-          break;
-        case 1:
-          buffer[index++] = c;
-          if((c == '\n') || (c == '\r')){
-            buffer[index] = 0;
-            fprintf (stderr, "%s", buffer);
-            state = 0;
-            index = 0;
-          }
-          break;
-        default:
-          break;
-        }
-      }
-    }
-    else if(stack_trace_done) break;
-  }
-  
-  close (in_fd[0]);
-  close (in_fd[1]);
-  close (out_fd[0]);
-  close (out_fd[1]);
-  _exit (0);
-}
-
-/************/
-void debug(int method, char *prog_name){
-  pid_t pid;
-  char buf[16];
-  char *args[4] = { "gdb", NULL, NULL, NULL };
-  int x;
-  
-  snprintf (buf, 99, "%d", getpid ());
-
-  args[1] = prog_name;
-  args[2] = buf;
-
-  pid = fork ();
-  if(pid == 0){
-    switch (method){
-    case INTERACTIVE:
-      fprintf (stderr, "debug_stop\n");
-      debug_stop(args);
-      break;
-    case STACK_TRACE:
-      fprintf (stderr, "stack_trace\n");
-      stack_trace(args);
-      break;
-    }
-    _exit(0);
-  } else if(pid == (pid_t) -1){
-    perror ("could not fork");
-    return;
-  }
-
-  x = 1;
-  while(x);  /* wait for debugger? */
-}
-
-/************/
-static void stack_trace_sigsegv(int signum){
-  debug(STACK_TRACE, stored_prog_name);
-}
-
-/************/
-void init_stack_trace(char *prog_name){
-  stored_prog_name = prog_name;
-  signal(SIGSEGV, stack_trace_sigsegv);
-}
diff --git a/proc/pwcache.c b/pwcache.c
similarity index 100%
rename from proc/pwcache.c
rename to pwcache.c
diff --git a/proc/pwcache.h b/pwcache.h
similarity index 100%
rename from proc/pwcache.h
rename to pwcache.h
diff --git a/pwdx.1 b/pwdx.1
deleted file mode 100644
index 8491fefa..00000000
--- a/pwdx.1
+++ /dev/null
@@ -1,37 +0,0 @@
-'\" t
-.\" (The preceding line is a note to broken versions of man to tell
-.\" them to pre-process this man page with tbl)
-.\" Man page for pwdx
-.\" Licensed under version 2 of the GNU General Public License.
-.\" Copyright 2004 Nicholas Miell.
-.\" Based on the pmap(1) man page by Albert Cahalan.
-.\"
-.TH PWDX 1 "September 8, 2004" "Linux" "Linux User's Manual"
-.SH NAME
-pwdx \- report current working directory of a process
-
-.SH SYNOPSIS
-.nf
-pwdx pids...
-pwdx -V
-.fi
-
-.SH DESCRIPTION
-The pwdx command reports the current working directory of a process or
-processes.
-
-.SH "GENERAL OPTIONS"
-.TS
-l l l.
--V	show version	Displays version of program.
-.TE
-
-.SH "SEE ALSO"
-ps(1) pgrep(1)
-
-.SH STANDARDS
-No standards apply, but pwdx looks an awful lot like a SunOS command.
-
-.SH AUTHOR
-Nicholas Miell <nmiell@gmail.com> wrote pwdx in 2004. Please send bug
-reports to <procps@freelists.org>
diff --git a/pwdx.c b/pwdx.c
deleted file mode 100644
index ac42736b..00000000
--- a/pwdx.c
+++ /dev/null
@@ -1,96 +0,0 @@
-// Copyright 2004 Nicholas Miell
-//
-// This file may be used subject to the terms and conditions of the
-// GNU Library General Public License Version 2 as published by the
-// Free Software Foundation.This program is distributed in the hope
-// that it will be useful, but WITHOUT ANY WARRANTY; without even the
-// implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
-// PURPOSE. See the GNU Library General Public License for more
-// details.
-
-#include <stdio.h>
-#include <string.h>
-#include <stdlib.h>
-#include <sys/types.h>
-#include <regex.h>
-#include <limits.h>
-#include <unistd.h>
-#include <errno.h>
-
-#include "proc/version.h"
-
-static void die(const char *msg) NORETURN;
-static void die(const char *msg)
-{
-     fputs(msg, stderr);
-     exit(1);
-}
-
-static void version(void) NORETURN;
-static void version(void)
-{
-     printf("pwdx (%s)\n", procps_version);
-     exit(0);
-}
-
-int main(int argc, char* argv[])
-{
-     static char buf[PATH_MAX+1];      // null terminate string via static
-     regex_t re;
-     int i;
-
-     if (argc < 2)
-          die("Usage: pwdx pid...\n");
-
-     // Allowed on the command line:
-     //
-     // --version
-     // -V
-     // /proc/nnnn
-     // nnnn
-     //
-     // where nnnn is any number that doesn't begin with 0.
-     //
-     // If --version or -V are present, further arguments are ignored
-     // completely.
-        
-     regcomp(&re, "^((/proc/+)?[1-9][0-9]*|-V|--version)$",
-             REG_EXTENDED|REG_NOSUB);
-
-     for (i = 1; i < argc; i++) {
-          if (regexec(&re, argv[i], 0, NULL, 0) != 0) {
-               snprintf(buf, sizeof buf, "pwdx: invalid process id: %s\n", argv[i]);
-               buf[sizeof(buf)-1] = '\0';
-               die(buf);
-          }
-          if (!strcmp("-V", argv[i]) || !strcmp("--version", argv[i]))
-               version();
-     }
-
-     regfree(&re);
-
-     for (i = 1; i < argc; i++) {
-          char * s = buf;
-          int len;
-          
-          // At this point, all arguments are in the form /proc/nnnn
-          // or nnnn, so a simple check based on the first char is
-          // possible
-          if (argv[i][0] != '/')
-               snprintf(buf, sizeof buf, "/proc/%s/cwd", argv[i]);
-          else
-               snprintf(buf, sizeof buf, "%s/cwd", argv[i]);
-
-          // buf contains /proc/nnnn/cwd symlink name on entry, the
-          // target of that symlink on return
-          if ((len = readlink(buf, buf, PATH_MAX)) < 0) {
-               s = strerror(errno == ENOENT ? ESRCH : errno);
-          } else {
-               buf[len] = 0;
-          }
-
-          printf("%s: %s\n", argv[i], s);
-     }
-
-     return 0;
-}
diff --git a/proc/readproc.c b/readproc.c
similarity index 57%
rename from proc/readproc.c
rename to readproc.c
index 45ec4150..dfa070dc 100644
--- a/proc/readproc.c
+++ b/readproc.c
@@ -6,11 +6,12 @@
  * May be distributed under the conditions of the
  * GNU Library General Public License; a copy is in COPYING
  */
-
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
 #include "version.h"
 #include "readproc.h"
 #include "alloc.h"
-#include "escape.h"
 #include "pwcache.h"
 #include "devname.h"
 #include "procps.h"
@@ -36,12 +37,6 @@ extern void __cyg_profile_func_enter(void*,void*);
 #define LEAVE(x)
 #endif
 
-#ifdef QUICK_THREADS
-// used when multi-threaded and some memory must not be freed
-#define MK_THREAD(q)   q->pad_1 =  '\xee'
-#define IS_THREAD(q) ( q->pad_1 == '\xee' )
-#endif
-
 #ifndef SIGNAL_STRING
 // convert hex string to unsigned long long
 static unsigned long long unhex(const char *restrict cp){
@@ -57,23 +52,6 @@ static unsigned long long unhex(const char *restrict cp){
 
 static int task_dir_missing;
 
-// free any additional dynamically acquired storage associated with a proc_t
-// ( and if it's to be reused, refresh it otherwise destroy it )
-static inline void free_acquired (proc_t *p, int reuse) {
-#ifdef QUICK_THREADS
-    if (!IS_THREAD(p)) {
-#endif
-        if (p->environ) free((void*)*p->environ);
-        if (p->cmdline) free((void*)*p->cmdline);
-        if (p->cgroup)  free((void*)*p->cgroup);
-        if (p->supgid)  free(p->supgid);
-        if (p->supgrp)  free(p->supgrp);
-#ifdef QUICK_THREADS
-    }
-#endif
-    memset(p, reuse ? '\0' : '\xff', sizeof(*p));
-}
-
 ///////////////////////////////////////////////////////////////////////////
 
 typedef struct status_table_struct {
@@ -94,20 +72,14 @@ typedef struct status_table_struct {
 #define NUL  {"", 0, 0},
 
 // Derived from:
-// gperf -7 --language=ANSI-C --key-positions=1,3,4 -C -n -c <if-not-piped>
+// gperf -7 --language=ANSI-C --key-positions=1,3,4 -C -n -c sml.gperf
 //
 // Suggested method:
 // Grep this file for "case_", then strip those down to the name.
-// Eliminate duplicates (due to #ifs), the '    case_' prefix and
-// any c comments.  Leave the colon and newline so that "Pid:\n",
-// "Threads:\n", etc. would be lines, but no quote, no escape, etc.
-//
-// After a pipe through gperf, insert the resulting 'asso_values'
-// into our 'asso' array.  Then convert the gperf 'wordlist' array
-// into our 'table' array by wrapping the string literals within
-// the F macro and replacing empty strings with the NUL define.
+// (leave the colon and newline) So "Pid:\n" and "Threads:\n"
+// would be lines in the file. (no quote, no escape, etc.)
 //
-// In the status_table_struct watch out for name size (grrr, expanding)
+// Watch out for name size in the status_table_struct (grrr, expanding)
 // and the number of entries (we mask with 63 for now). The table
 // must be padded out to 64 entries, maybe 128 in the future.
 
@@ -116,81 +88,62 @@ static void status2proc(char *S, proc_t *restrict P, int is_proc){
     long Tgid = 0;
     long Pid = 0;
 
-  // 128 entries because we trust the kernel to use ASCII names
   static const unsigned char asso[] =
     {
-      64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
-      64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
-      64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
-      64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
-      64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
-      64, 64, 64, 64, 64, 64, 64, 64, 28, 64,
-      64, 64, 64, 64, 64, 64,  8, 25, 23, 25,
-       6, 25,  0,  3, 64, 64,  3, 64, 25, 64,
-      20,  1,  1,  5,  0, 30,  0,  0, 64, 64,
-      64, 64, 64, 64, 64, 64, 64,  3, 64,  0,
-       0, 18, 64, 10, 64, 10, 64, 64, 64, 20,
-      64, 20,  0, 64, 25, 64,  3, 15, 64,  0,
-      30, 64, 64, 64, 64, 64, 64, 64
+      61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
+      61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
+      61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
+      61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
+      61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
+      61, 61, 61, 61, 61, 61, 61, 61, 15, 61,
+      61, 61, 61, 61, 61, 61, 30,  3,  5,  5,
+      61,  5, 61,  8, 61, 61,  3, 61, 10, 61,
+       6, 61, 13,  0, 30, 25,  0, 61, 61, 61,
+      61, 61, 61, 61, 61, 61, 61,  3, 61, 13,
+       0,  0, 61, 30, 61, 25, 61, 61, 61,  0,
+      61, 61, 61, 61,  5, 61,  0, 61, 61, 61,
+       0, 61, 61, 61, 61, 61, 61, 61
     };
 
     static const status_table_struct table[] = {
-      F(VmHWM)
-      NUL NUL
-      F(VmLck)
-      NUL
-      F(VmSwap)
-      F(VmRSS)
-      NUL
       F(VmStk)
-      NUL
-      F(Tgid)
+      NUL NUL
       F(State)
       NUL
-      F(VmLib)
-      NUL
-      F(VmSize)
-      F(SigQ)
-      NUL
-      F(SigIgn)
-      NUL
-      F(VmPTE)
-      F(FDSize)
-      NUL
-      F(SigBlk)
-      NUL
+      F(VmExe)
       F(ShdPnd)
-      F(VmData)
       NUL
-      F(CapInh)
+      F(VmData)
       NUL
-      F(PPid)
+      F(Name)
       NUL NUL
-      F(CapBnd)
-      NUL
-      F(SigPnd)
+      F(VmRSS)
       NUL NUL
-      F(VmPeak)
+      F(VmLck)
+      NUL NUL NUL
+      F(Gid)
+      F(Pid)
+      NUL NUL NUL
+      F(VmSize)
+      NUL NUL
+      F(VmLib)
+      NUL NUL
+      F(PPid)
       NUL
       F(SigCgt)
-      NUL NUL
-      F(Threads)
       NUL
-      F(CapPrm)
-      NUL NUL
-      F(Pid)
+      F(Threads)
+      F(SigPnd)
       NUL
-      F(CapEff)
-      NUL NUL
-      F(Gid)
+      F(SigIgn)
       NUL
-      F(VmExe)
-      NUL NUL
       F(Uid)
-      NUL
-      F(Groups)
-      NUL NUL
-      F(Name)
+      NUL NUL NUL NUL NUL NUL NUL NUL NUL
+      NUL NUL NUL NUL NUL
+      F(Tgid)
+      NUL NUL NUL NUL
+      F(SigBlk)
+      NUL NUL NUL
     };
 
 #undef F
@@ -198,6 +151,16 @@ static void status2proc(char *S, proc_t *restrict P, int is_proc){
 
 ENTER(0x220);
 
+    P->vm_size = 0;
+    P->vm_lock = 0;
+    P->vm_rss  = 0;
+    P->vm_data = 0;
+    P->vm_stack= 0;
+    P->vm_exe  = 0;
+    P->vm_lib  = 0;
+    P->nlwp    = 0;
+    P->signal[0] = '\0';  // so we can detect it as missing for very old kernels
+
     goto base;
 
     for(;;){
@@ -227,8 +190,8 @@ ENTER(0x220);
         goto *entry.addr;
 #endif
 
-    case_Name:
-    {   unsigned u = 0;
+    case_Name:{
+        unsigned u = 0;
         while(u < sizeof P->cmd - 1u){
             int c = *S++;
             if(unlikely(c=='\n')) break;
@@ -331,52 +294,25 @@ ENTER(0x220);
     case_VmStk:
         P->vm_stack = strtol(S,&S,10);
         continue;
-    case_VmSwap: // Linux 2.6.34
-        P->vm_swap = strtol(S,&S,10);
-        continue;
-    case_Groups:
-    {   int j = strchr(S, '\n') - S;        // currently lines end space + \n
-        if (j) {
-            P->supgid = xmalloc(j+1);       // +1 in case space disappears
-            memcpy(P->supgid, S, j);
-            if (unlikely(' ' != P->supgid[--j])) ++j;
-            P->supgid[j] = '\0';            // whack the space or the newline
-            for ( ; j; j--)
-                if (' '  == P->supgid[j])
-                    P->supgid[j] = ',';
-        } else
-            P->supgid = strdup("-");
-        continue;
-    }
-    case_CapBnd:
-    case_CapEff:
-    case_CapInh:
-    case_CapPrm:
-    case_FDSize:
-    case_SigQ:
-    case_VmHWM: // 2005, peak VmRSS unless VmRSS is bigger
-    case_VmPTE:
-    case_VmPeak: // 2005, peak VmSize unless VmSize is bigger
-        continue;
     }
 
 #if 0
     // recent kernels supply per-tgid pending signals
     if(is_proc && *ShdPnd){
-        memcpy(P->signal, ShdPnd, 16);
-        P->signal[16] = '\0';
+	memcpy(P->signal, ShdPnd, 16);
+	P->signal[16] = '\0';
     }
 #endif
 
     // recent kernels supply per-tgid pending signals
 #ifdef SIGNAL_STRING
     if(!is_proc || !P->signal[0]){
-        memcpy(P->signal, P->_sigpnd, 16);
-        P->signal[16] = '\0';
+	memcpy(P->signal, P->_sigpnd, 16);
+	P->signal[16] = '\0';
     }
 #else
-    if(!is_proc){
-        P->signal = P->_sigpnd;
+    if(!is_proc || !have_process_pending){
+	P->signal = P->_sigpnd;
     }
 #endif
 
@@ -385,50 +321,19 @@ ENTER(0x220);
     // Only 2.6.0 and above have "Threads" (nlwp) info.
 
     if(Threads){
-        P->nlwp = Threads;
-        P->tgid = Tgid;     // the POSIX PID value
-        P->tid  = Pid;      // the thread ID
+       P->nlwp = Threads;
+       P->tgid = Tgid;     // the POSIX PID value
+       P->tid  = Pid;      // the thread ID
     }else{
-        P->nlwp = 1;
-        P->tgid = Pid;
-        P->tid  = Pid;
+       P->nlwp = 1;
+       P->tgid = Pid;
+       P->tid  = Pid;
     }
 
 LEAVE(0x220);
 }
 
-static void supgrps_from_supgids (proc_t *p) {
-    char *g, *s;
-    int t;
-
-    if (!p->supgid || '-' == *p->supgid) {
-        p->supgrp = strdup("-");
-        return;
-    }
-    s = p->supgid;
-    t = 0;
-    do {
-        if (',' == *s) ++s;
-        g = group_from_gid((uid_t)strtol(s, &s, 10));
-        p->supgrp = realloc(p->supgrp, P_G_SZ+t+2);
-        t += snprintf(p->supgrp+t, P_G_SZ+2, "%s%s", t ? "," : "", g);
-    } while (*s);
-}
-
 ///////////////////////////////////////////////////////////////////////
-#ifdef OOMEM_ENABLE
-static void oomscore2proc(const char* S, proc_t *restrict P)
-{
-    sscanf(S, "%d", &P->oom_score);
-}
-
-static void oomadj2proc(const char* S, proc_t *restrict P)
-{
-    sscanf(S, "%d", &P->oom_adj);
-}
-#endif
-///////////////////////////////////////////////////////////////////////
-
 
 // Reads /proc/*/stat files, being careful not to trip over processes with
 // names like ":-) 1 2 3 4 5 6".
@@ -497,8 +402,7 @@ LEAVE(0x160);
 /////////////////////////////////////////////////////////////////////////
 
 static void statm2proc(const char* s, proc_t *restrict P) {
-    int num;
-    num = sscanf(s, "%ld %ld %ld %ld %ld %ld %ld",
+    sscanf(s, "%ld %ld %ld %ld %ld %ld %ld",
 	   &P->size, &P->resident, &P->share,
 	   &P->trs, &P->lrs, &P->drs, &P->dt);
 /*    fprintf(stderr, "statm2proc converted %d fields.\n",num); */
@@ -529,20 +433,17 @@ static char** file2strvec(const char* directory, const char* what) {
     if(fd==-1) return NULL;
 
     /* read whole file into a memory buffer, allocating as we go */
-    while ((n = read(fd, buf, sizeof buf - 1)) >= 0) {
+    while ((n = read(fd, buf, sizeof buf - 1)) > 0) {
 	if (n < (int)(sizeof buf - 1))
 	    end_of_file = 1;
-	if (n == 0 && rbuf == 0) {
-	    close(fd);
+	if (n == 0 && rbuf == 0)
 	    return NULL;	/* process died between our open and read */
-	}
 	if (n < 0) {
 	    if (rbuf)
 		free(rbuf);
-	    close(fd);
 	    return NULL;	/* read error */
 	}
-	if (end_of_file && (n == 0 || buf[n-1]))/* last read char not null */
+	if (end_of_file && buf[n-1])		/* last read char not null */
 	    buf[n++] = '\0';			/* so append null-terminator */
 	rbuf = xrealloc(rbuf, tot + n);		/* allocate more memory */
 	memcpy(rbuf + tot, buf, n);		/* copy buffer into it */
@@ -557,12 +458,9 @@ static char** file2strvec(const char* directory, const char* what) {
     }
     endbuf = rbuf + tot;			/* count space for pointers */
     align = (sizeof(char*)-1) - ((tot + sizeof(char*)-1) & (sizeof(char*)-1));
-    for (c = 0, p = rbuf; p < endbuf; p++) {
-	if (!*p || *p == '\n')
+    for (c = 0, p = rbuf; p < endbuf; p++)
+    	if (!*p)
 	    c += sizeof(char*);
-	if (*p == '\n')
-	    *p = 0;
-    }
     c += sizeof(char*);				/* one extra for NULL term */
 
     rbuf = xrealloc(rbuf, tot + c + align);	/* make room for ptrs AT END */
@@ -578,18 +476,15 @@ static char** file2strvec(const char* directory, const char* what) {
     return ret;
 }
 
-    // this is the former under utilized 'read_cmdline', which has been
-    // generalized in support of these new libproc flags:
-    //     PROC_EDITCGRPCVT, PROC_EDITCMDLCVT
-static int read_unvectored(char *restrict const dst, unsigned sz, const char* whom, const char *what, char sep) {
-    char path[PROCPATHLEN];
+// warning: interface may change
+int read_cmdline(char *restrict const dst, unsigned sz, unsigned pid){
+    char name[32];
     int fd;
     unsigned n = 0;
-
-    snprintf(path, sizeof(path), "%s/%s", whom, what);
-    fd = open(path, O_RDONLY);
+    dst[0] = '\0';
+    snprintf(name, sizeof name, "/proc/%u/cmdline", pid);
+    fd = open(name, O_RDONLY);
     if(fd==-1) return 0;
-
     for(;;){
         ssize_t r = read(fd,dst+n,sz-n);
         if(r==-1){
@@ -597,88 +492,23 @@ static int read_unvectored(char *restrict const dst, unsigned sz, const char* wh
             break;
         }
         n += r;
-        if(n==sz) {      // filled the buffer
-            --n;         // make room for '\0'
-            break;
-        }
+        if(n==sz) break; // filled the buffer
         if(r==0) break;  // EOF
     }
     close(fd);
     if(n){
-        int i=n;
-        while(i--)
-            if(dst[i]=='\n' || dst[i]=='\0') dst[i]=sep;
+        int i;
+        if(n==sz) n--;
+        dst[n] = '\0';
+        i=n;
+        while(i--){
+            int c = dst[i];
+            if(c<' ' || c>'~') dst[i]=' ';
+        }
     }
-    dst[n] = '\0';
     return n;
 }
 
-static char** vectorize_this_str (const char* src) {
- #define pSZ  (sizeof(char*))
-    char *cpy, **vec;
-    int adj, tot;
-
-    tot = strlen(src) + 1;                       // prep for our vectors
-    adj = (pSZ-1) - ((tot + pSZ-1) & (pSZ-1));   // calc alignment bytes
-    cpy = xcalloc(NULL, tot + adj + (2 * pSZ));  // get new larger buffer
-    snprintf(cpy, tot, "%s", src);               // duplicate their string
-    vec = (char**)(cpy + tot + adj);             // prep pointer to pointers
-    *vec = cpy;                                  // point 1st vector to string
-    *(vec+1) = NULL;                             // null ptr 'list' delimit
-    return vec;                                  // ==> free(*vec) to dealloc
- #undef pSZ
-}
-
-    // This routine reads a 'cgroup' for the designated proc_t.
-    // It is similar to file2strvec except we filter and concatenate
-    // the data into a single string represented as a single vector.
-static void fill_cgroup_cvt (const char* directory, proc_t *restrict p) {
- #define vMAX ( sizeof(dbuf) - (int)(dst - dbuf) )
-    char sbuf[1024], dbuf[1024];
-    char *src, *dst, *grp, *eob;
-    int tot, x, whackable_int = sizeof(dbuf);
-
-    *(dst = dbuf) = '\0';                        // empty destination
-    tot = read_unvectored(sbuf, sizeof(sbuf), directory, "cgroup", '\0');
-    for (src = sbuf, eob = sbuf + tot; src < eob; src += x) {
-        x = 1;                                   // loop assist
-        if (!*src) continue;
-        x = strlen((grp = src));
-        if ('/' == grp[x - 1]) continue;         // skip empty root cgroups
-#if 0
-        grp += strspn(grp, "0123456789:");       // jump past group number
-#endif
-        dst += snprintf(dst, vMAX, "%s", (dst > dbuf) ? "," : "");
-        dst += escape_str(dst, grp, vMAX, &whackable_int);
-    }
-    p->cgroup = vectorize_this_str(dbuf[0] ? dbuf : "-");
- #undef vMAX
-}
-
-    // This routine reads a 'cmdline' for the designated proc_t, "escapes"
-    // the result into a single string represented as a single vector
-    // and guarantees the caller a valid proc_t.cmdline pointer.
-static void fill_cmdline_cvt (const char* directory, proc_t *restrict p) {
- #define uFLG ( ESC_BRACKETS | ESC_DEFUNCT )
-    char sbuf[2048], dbuf[2048];
-    int whackable_int = sizeof(dbuf);
-
-    if (read_unvectored(sbuf, sizeof(sbuf), directory, "cmdline", ' '))
-        escape_str(dbuf, sbuf, sizeof(dbuf), &whackable_int);
-    else
-        escape_command(dbuf, p, sizeof(dbuf), &whackable_int, uFLG);
-    p->cmdline = vectorize_this_str(dbuf);
- #undef uFLG
-}
-
-// warning: interface may change
-int read_cmdline(char *restrict const dst, unsigned sz, unsigned pid) {
-    char path[PROCPATHLEN];
-    snprintf(path, sizeof(path), "/proc/%u", pid);
-    return read_unvectored(dst, sz, path, "cmdline", ' ');
-}
-
-
 /* These are some nice GNU C expression subscope "inline" functions.
  * The can be used with arbitrary types and evaluate their arguments
  * exactly once.
@@ -704,37 +534,35 @@ int read_cmdline(char *restrict const dst, unsigned sz, unsigned pid) {
 // The pid (tgid? tid?) is already in p, and a path to it in path, with some
 // room to spare.
 static proc_t* simple_readproc(PROCTAB *restrict const PT, proc_t *restrict const p) {
-    static struct stat sb;     // stat() buffer
-    static char sbuf[1024];    // buffer for stat,statm,status
+    static struct stat sb;		// stat() buffer
+    static char sbuf[1024];	// buffer for stat,statm
     char *restrict const path = PT->path;
     unsigned flags = PT->flags;
 
-    if (unlikely(stat(path, &sb) == -1))        /* no such dirent (anymore) */
-        goto next_proc;
+    if (unlikely(stat(path, &sb) == -1))	/* no such dirent (anymore) */
+	goto next_proc;
 
     if ((flags & PROC_UID) && !XinLN(uid_t, sb.st_uid, PT->uids, PT->nuid))
-        goto next_proc;                 /* not one of the requested uids */
+	goto next_proc;			/* not one of the requested uids */
 
-    p->euid = sb.st_uid;                        /* need a way to get real uid */
-    p->egid = sb.st_gid;                        /* need a way to get real gid */
+    p->euid = sb.st_uid;			/* need a way to get real uid */
+    p->egid = sb.st_gid;			/* need a way to get real gid */
 
-    if (flags & PROC_FILLSTAT) {                // read /proc/#/stat
-        if (unlikely(file2str(path, "stat", sbuf, sizeof sbuf) == -1))
-            goto next_proc;
-        stat2proc(sbuf, p);
+    if (flags & PROC_FILLSTAT) {         /* read, parse /proc/#/stat */
+	if (unlikely( file2str(path, "stat", sbuf, sizeof sbuf) == -1 ))
+	    goto next_proc;			/* error reading /proc/#/stat */
+	stat2proc(sbuf, p);				/* parse /proc/#/stat */
     }
 
-    if (flags & PROC_FILLMEM) {                 // read /proc/#/statm
-        if (likely(file2str(path, "statm", sbuf, sizeof sbuf) != -1))
-            statm2proc(sbuf, p);
-    }
+    if (unlikely(flags & PROC_FILLMEM)) {	/* read, parse /proc/#/statm */
+	if (likely( file2str(path, "statm", sbuf, sizeof sbuf) != -1 ))
+	    statm2proc(sbuf, p);		/* ignore statm errors here */
+    }						/* statm fields just zero */
 
-    if (flags & PROC_FILLSTATUS) {              // read /proc/#/status
-        if (likely(file2str(path, "status", sbuf, sizeof sbuf) != -1)){
-            status2proc(sbuf, p, 1);
-            if (flags & PROC_FILLSUPGRP)
-                supgrps_from_supgids(p);
-        }
+    if (flags & PROC_FILLSTATUS) {         /* read, parse /proc/#/status */
+       if (likely( file2str(path, "status", sbuf, sizeof sbuf) != -1 )){
+           status2proc(sbuf, p, 1);
+       }
     }
 
     // if multithreaded, some values are crap
@@ -742,17 +570,17 @@ static proc_t* simple_readproc(PROCTAB *restrict const PT, proc_t *restrict cons
       p->wchan = (KLONG)~0ull;
     }
 
-    /* some number->text resolving which is time consuming */
+    /* some number->text resolving which is time consuming and kind of insane */
     if (flags & PROC_FILLUSR){
-        memcpy(p->euser, user_from_uid(p->euid), sizeof p->euser);
+	memcpy(p->euser,   user_from_uid(p->euid), sizeof p->euser);
         if(flags & PROC_FILLSTATUS) {
-            memcpy(p->ruser, user_from_uid(p->ruid), sizeof p->ruser);
-            memcpy(p->suser, user_from_uid(p->suid), sizeof p->suser);
-            memcpy(p->fuser, user_from_uid(p->fuid), sizeof p->fuser);
+            memcpy(p->ruser,   user_from_uid(p->ruid), sizeof p->ruser);
+            memcpy(p->suser,   user_from_uid(p->suid), sizeof p->suser);
+            memcpy(p->fuser,   user_from_uid(p->fuid), sizeof p->fuser);
         }
     }
 
-    /* some number->text resolving which is time consuming */
+    /* some number->text resolving which is time consuming and kind of insane */
     if (flags & PROC_FILLGRP){
         memcpy(p->egroup, group_from_gid(p->egid), sizeof p->egroup);
         if(flags & PROC_FILLSTATUS) {
@@ -762,36 +590,15 @@ static proc_t* simple_readproc(PROCTAB *restrict const PT, proc_t *restrict cons
         }
     }
 
-    if (unlikely(flags & PROC_FILLENV))         // read /proc/#/environ
-        p->environ = file2strvec(path, "environ");
+    if ((flags & PROC_FILLCOM) || (flags & PROC_FILLARG))	/* read+parse /proc/#/cmdline */
+	p->cmdline = file2strvec(path, "cmdline");
     else
-        p->environ = NULL;
-
-    if (flags & (PROC_FILLCOM|PROC_FILLARG)) {  // read /proc/#/cmdline
-        if (flags & PROC_EDITCMDLCVT)
-            fill_cmdline_cvt(path, p);
-        else
-            p->cmdline = file2strvec(path, "cmdline");
-    } else
         p->cmdline = NULL;
 
-    if ((flags & PROC_FILLCGROUP)               // read /proc/#/cgroup
-    && linux_version_code >= LINUX_VERSION(2,6,24)) {
-        if (flags & PROC_EDITCGRPCVT)
-            fill_cgroup_cvt(path, p);
-        else
-            p->cgroup = file2strvec(path, "cgroup");
-    } else
-        p->cgroup = NULL;
-
-#ifdef OOMEM_ENABLE
-    if (unlikely(flags & PROC_FILLOOM)) {
-        if (likely(file2str(path, "oom_score", sbuf, sizeof sbuf) != -1))
-            oomscore2proc(sbuf, p);
-        if (likely(file2str(path, "oom_adj", sbuf, sizeof sbuf) != -1))
-            oomadj2proc(sbuf, p);
-    }
-#endif
+    if (unlikely(flags & PROC_FILLENV))			/* read+parse /proc/#/environ */
+	p->environ = file2strvec(path, "environ");
+    else
+        p->environ = NULL;
 
     return p;
 next_proc:
@@ -800,56 +607,59 @@ next_proc:
 
 //////////////////////////////////////////////////////////////////////////////////
 // This reads /proc/*/task/* data, for one task.
-#ifdef QUICK_THREADS
-// p is the POSIX process (task group summary) & source for some copies if !NULL
-#else
 // p is the POSIX process (task group summary) (not needed by THIS implementation)
-#endif
 // t is the POSIX thread (task group member, generally not the leader)
 // path is a path to the task, with some room to spare.
 static proc_t* simple_readtask(PROCTAB *restrict const PT, const proc_t *restrict const p, proc_t *restrict const t, char *restrict const path) {
-    static struct stat sb;     // stat() buffer
-    static char sbuf[1024];    // buffer for stat,statm,status
+    static struct stat sb;		// stat() buffer
+    static char sbuf[1024];	// buffer for stat,statm
     unsigned flags = PT->flags;
 
-    if (unlikely(stat(path, &sb) == -1))        /* no such dirent (anymore) */
-        goto next_task;
+//printf("hhh\n");
+    if (unlikely(stat(path, &sb) == -1))	/* no such dirent (anymore) */
+	goto next_task;
 
-//  if ((flags & PROC_UID) && !XinLN(uid_t, sb.st_uid, PT->uids, PT->nuid))
-//      goto next_task;                         /* not one of the requested uids */
+//    if ((flags & PROC_UID) && !XinLN(uid_t, sb.st_uid, PT->uids, PT->nuid))
+//	goto next_task;			/* not one of the requested uids */
 
-    t->euid = sb.st_uid;                        /* need a way to get real uid */
-    t->egid = sb.st_gid;                        /* need a way to get real gid */
+    t->euid = sb.st_uid;			/* need a way to get real uid */
+    t->egid = sb.st_gid;			/* need a way to get real gid */
 
-    if (flags & PROC_FILLSTAT) {                        // read /proc/#/task/#/stat
-        if (unlikely(file2str(path, "stat", sbuf, sizeof sbuf) == -1))
-            goto next_task;
-        stat2proc(sbuf, t);
+//printf("iii\n");
+    if (flags & PROC_FILLSTAT) {         /* read, parse /proc/#/stat */
+	if (unlikely( file2str(path, "stat", sbuf, sizeof sbuf) == -1 ))
+	    goto next_task;			/* error reading /proc/#/stat */
+	stat2proc(sbuf, t);				/* parse /proc/#/stat */
     }
 
-#ifndef QUICK_THREADS
-    if (flags & PROC_FILLMEM)                           // read /proc/#/task/#statm
-        if (likely(file2str(path, "statm", sbuf, sizeof sbuf) != -1))
-            statm2proc(sbuf, t);
+    if (unlikely(flags & PROC_FILLMEM)) {	/* read, parse /proc/#/statm */
+#if 0
+	if (likely( file2str(path, "statm", sbuf, sizeof sbuf) != -1 ))
+	    statm2proc(sbuf, t);		/* ignore statm errors here */
+#else
+	t->size     = p->size;
+	t->resident = p->resident;
+	t->share    = p->share;
+	t->trs      = p->trs;
+	t->lrs      = p->lrs;
+	t->drs      = p->drs;
+	t->dt       = p->dt;
 #endif
+    }						/* statm fields just zero */
 
-    if (flags & PROC_FILLSTATUS) {                      // read /proc/#/task/#/status
-        if (likely(file2str(path, "status", sbuf, sizeof sbuf) != -1)) {
-            status2proc(sbuf, t, 0);
-#ifndef QUICK_THREADS
-            if (flags & PROC_FILLSUPGRP)
-                supgrps_from_supgids(t);
-#endif
-        }
+    if (flags & PROC_FILLSTATUS) {         /* read, parse /proc/#/status */
+       if (likely( file2str(path, "status", sbuf, sizeof sbuf) != -1 )){
+           status2proc(sbuf, t, 0);
+       }
     }
 
     /* some number->text resolving which is time consuming */
     if (flags & PROC_FILLUSR){
-        memcpy(t->euser, user_from_uid(t->euid), sizeof t->euser);
+	memcpy(t->euser,   user_from_uid(t->euid), sizeof t->euser);
         if(flags & PROC_FILLSTATUS) {
-            memcpy(t->ruser, user_from_uid(t->ruid), sizeof t->ruser);
-            memcpy(t->suser, user_from_uid(t->suid), sizeof t->suser);
-            memcpy(t->fuser, user_from_uid(t->fuid), sizeof t->fuser);
+            memcpy(t->ruser,   user_from_uid(t->ruid), sizeof t->ruser);
+            memcpy(t->suser,   user_from_uid(t->suid), sizeof t->suser);
+            memcpy(t->fuser,   user_from_uid(t->fuid), sizeof t->fuser);
         }
     }
 
@@ -863,71 +673,26 @@ static proc_t* simple_readtask(PROCTAB *restrict const PT, const proc_t *restric
         }
     }
 
-#ifdef QUICK_THREADS
-    if (!p) {
-        if (flags & PROC_FILLMEM)
-            if (likely(file2str(path, "statm", sbuf, sizeof sbuf) != -1))
-                statm2proc(sbuf, t);
+#if 0
+    if ((flags & PROC_FILLCOM) || (flags & PROC_FILLARG))	/* read+parse /proc/#/cmdline */
+	t->cmdline = file2strvec(path, "cmdline");
+    else
+        t->cmdline = NULL;
 
-        if (flags & PROC_FILLSUPGRP)
-            supgrps_from_supgids(t);
-#endif
-        if (unlikely(flags & PROC_FILLENV))             // read /proc/#/task/#/environ
-            t->environ = file2strvec(path, "environ");
-        else
-            t->environ = NULL;
-
-        if (flags & (PROC_FILLCOM|PROC_FILLARG)) {      // read /proc/#/task/#/cmdline
-            if (flags & PROC_EDITCMDLCVT)
-                fill_cmdline_cvt(path, t);
-            else
-                t->cmdline = file2strvec(path, "cmdline");
-        } else
-            t->cmdline = NULL;
-
-        if ((flags & PROC_FILLCGROUP)                   // read /proc/#/task/#/cgroup
-        && linux_version_code >= LINUX_VERSION(2,6,24)) {
-            if (flags & PROC_EDITCGRPCVT)
-                fill_cgroup_cvt(path, t);
-            else
-                t->cgroup = file2strvec(path, "cgroup");
-        } else
-            t->cgroup = NULL;
-
-#ifdef QUICK_THREADS
-    } else {
-        t->size     = p->size;
-        t->resident = p->resident;
-        t->share    = p->share;
-        t->trs      = p->trs;
-        t->lrs      = p->lrs;
-        t->drs      = p->drs;
-        t->dt       = p->dt;
-        t->cmdline  = p->cmdline;  // better not free these until done with all threads!
-        t->environ  = p->environ;
-        t->cgroup   = p->cgroup;
-        if (t->supgid) free(t->supgid);
-        t->supgid   = p->supgid;
-        t->supgrp   = p->supgrp;
-        MK_THREAD(t);
-    }
+    if (unlikely(flags & PROC_FILLENV))			/* read+parse /proc/#/environ */
+	t->environ = file2strvec(path, "environ");
+    else
+        t->environ = NULL;
+#else
+    t->cmdline = p->cmdline;  // better not free these until done with all threads!
+    t->environ = p->environ;
 #endif
 
-#ifdef OOMEM_ENABLE
-    if (unlikely(flags & PROC_FILLOOM)) {
-        if (likely(file2str(path, "oom_score", sbuf, sizeof sbuf) != -1))
-            oomscore2proc(sbuf, t);
-        if (likely(file2str(path, "oom_adj", sbuf, sizeof sbuf) != -1))
-            oomadj2proc(sbuf, t);
-    }
-#endif
+    t->ppid = p->ppid;  // ought to put the per-task ppid somewhere
 
     return t;
 next_task:
     return NULL;
-#ifndef QUICK_THREADS
-    (void)p;
-#endif
 }
 
 //////////////////////////////////////////////////////////////////////////////////
@@ -939,7 +704,7 @@ static int simple_nextpid(PROCTAB *restrict const PT, proc_t *restrict const p)
   for (;;) {
     ent = readdir(PT->procfs);
     if(unlikely(unlikely(!ent) || unlikely(!ent->d_name))) return 0;
-    if(likely(likely(*ent->d_name > '0') && likely(*ent->d_name <= '9'))) break;
+    if(likely( likely(*ent->d_name > '0') && likely(*ent->d_name <= '9') )) break;
   }
   p->tgid = strtoul(ent->d_name, NULL, 10);
   p->tid = p->tgid;
@@ -966,11 +731,11 @@ static int simple_nexttid(PROCTAB *restrict const PT, const proc_t *restrict con
   for (;;) {
     ent = readdir(PT->taskdir);
     if(unlikely(unlikely(!ent) || unlikely(!ent->d_name))) return 0;
-    if(likely(likely(*ent->d_name > '0') && likely(*ent->d_name <= '9'))) break;
+    if(likely( likely(*ent->d_name > '0') && likely(*ent->d_name <= '9') )) break;
   }
   t->tid = strtoul(ent->d_name, NULL, 10);
   t->tgid = p->tgid;
-//t->ppid = p->ppid;  // cover for kernel behavior? we want both actually...?
+  t->ppid = p->ppid;  // cover for kernel behavior? we want both actually...?
   snprintf(path, PROCPATHLEN, "/proc/%d/task/%s", p->tgid, ent->d_name);
   return 1;
 }
@@ -981,7 +746,7 @@ static int simple_nexttid(PROCTAB *restrict const PT, const proc_t *restrict con
 static int listed_nextpid(PROCTAB *restrict const PT, proc_t *restrict const p) {
   char *restrict const path = PT->path;
   pid_t tgid = *(PT->pids)++;
-  if(likely(tgid)){
+  if(likely( tgid )){
     snprintf(path, PROCPATHLEN, "/proc/%d", tgid);
     p->tgid = tgid;
     p->tid = tgid;  // they match for leaders
@@ -1012,12 +777,11 @@ proc_t* readproc(PROCTAB *restrict const PT, proc_t *restrict p) {
 //  }
 
   saved_p = p;
-  if(!p) p = xcalloc(NULL, sizeof *p);
-  else free_acquired(p, 1);
+  if(!p) p = xcalloc(p, sizeof *p); /* passed buf or alloced mem */
 
   for(;;){
     // fills in the path, plus p->tid and p->tgid
-    if (unlikely(!PT->finder(PT,p))) goto out;
+    if (unlikely(! PT->finder(PT,p) )) goto out;
 
     // go read the process data
     ret = PT->reader(PT,p);
@@ -1036,45 +800,31 @@ out:
 // pointer (boolean false).  Use the passed buffer instead of allocating
 // space if it is non-NULL.
 proc_t* readtask(PROCTAB *restrict const PT, const proc_t *restrict const p, proc_t *restrict t) {
-  char path[PROCPATHLEN];    // must hold /proc/2000222000/task/2000222000/cmdline
+  static char path[PROCPATHLEN];       // must hold /proc/2000222000/task/2000222000/cmdline
   proc_t *ret;
   proc_t *saved_t;
 
   saved_t = t;
-  if(!t) t = xcalloc(NULL, sizeof *t);
-  else free_acquired(t, 1);
+  if(!t) t = xcalloc(t, sizeof *t); /* passed buf or alloced mem */
 
   // 1. got to fake a thread for old kernels
-#ifdef QUICK_THREADS
   // 2. for single-threaded processes, this is faster (but must patch up stuff that differs!)
   if(task_dir_missing || p->nlwp < 2){
-#else
-  if(task_dir_missing){
-#endif
     if(PT->did_fake) goto out;
     PT->did_fake=1;
     memcpy(t,p,sizeof(proc_t));
     // use the per-task pending, not per-tgid pending
 #ifdef SIGNAL_STRING
-    memcpy(&t->signal, &t->_sigpnd, sizeof t->signal);
-#else
-    t->signal = t->_sigpnd;
-#endif
-#ifdef QUICK_THREADS
-    MK_THREAD(t);
+	memcpy(&t->signal, &t->_sigpnd, sizeof t->signal);
 #else
-    t->environ = NULL;
-    t->cmdline = vectorize_this_str("n/a");
-    t->cgroup  = NULL;
-    t->supgid  = NULL;
-    t->supgrp  = NULL;
+	t->signal = t->_sigpnd;
 #endif
     return t;
   }
 
   for(;;){
     // fills in the path, plus t->tid and t->tgid
-    if (unlikely(!PT->taskfinder(PT,p,t,path))) goto out;  // simple_nexttid
+    if (unlikely(! PT->taskfinder(PT,p,t,path) )) goto out;  // simple_nexttid
 
     // go read the task data
     ret = PT->taskreader(PT,p,t,path);          // simple_readtask
@@ -1086,46 +836,6 @@ out:
   return NULL;
 }
 
-//////////////////////////////////////////////////////////////////////////////////
-// readeither: return a pointer to a proc_t filled with requested info about
-// the next unique process or task available.  If no more are available,
-// return a null pointer (boolean false).  Use the passed buffer instead
-// of allocating space if it is non-NULL.
-extern proc_t* readeither (PROCTAB *restrict const PT, proc_t *restrict x) {
-    static proc_t skel_p;    // skeleton proc_t, only uses tid + tgid
-    static proc_t *new_p;    // for process/task transitions
-    char path[PROCPATHLEN];
-    proc_t *saved_x, *ret;
-
-    saved_x = x;
-    if (!x) x = xcalloc(NULL, sizeof(*x));
-    else free_acquired(x,1);
-    if (new_p) goto next_task;
-
-next_proc:
-    new_p = NULL;
-    for (;;) {
-        // fills in the PT->path, plus skel_p.tid and skel_p.tgid
-        if (!PT->finder(PT,&skel_p)) goto end_procs;       // simple_nextpid
-        if (!task_dir_missing) break;
-        if ((ret = PT->reader(PT,x))) return ret;          // simple_readproc
-    }
-
-next_task:
-    // fills in our path, plus x->tid and x->tgid
-    if ((!(PT->taskfinder(PT,&skel_p,x,path)))             // simple_nexttid
-    || (!(ret = PT->taskreader(PT,new_p,x,path)))) {       // simple_readtask
-        goto next_proc;
-    }
-    if (!new_p) new_p = ret;
-    return ret;
-
-end_procs:
-    if (!saved_x) free(x);
-    return NULL;
-}
-
-
 //////////////////////////////////////////////////////////////////////////////////
 
 // initiate a process table scan
@@ -1150,7 +860,7 @@ PROCTAB* openproc(int flags, ...) {
       PT->finder = listed_nextpid;
     }else{
       PT->procfs = opendir("/proc");
-      if(!PT->procfs) { free(PT); return NULL; }
+      if(!PT->procfs) return NULL;
       PT->finder = simple_nextpid;
     }
     PT->flags = flags;
@@ -1177,12 +887,17 @@ void closeproc(PROCTAB* PT) {
     }
 }
 
-// deallocate space allocated by readproc
+// deallocate the space allocated by readproc if the passed rbuf was NULL
 void freeproc(proc_t* p) {
-    if (p) {
-        free_acquired(p, 0);
-        free(p);
-    }
+    if (!p)	/* in case p is NULL */
+	return;
+    /* ptrs are after strings to avoid copying memory when building them. */
+    /* so free is called on the address of the address of strvec[0]. */
+    if (p->cmdline)
+	free((void*)*p->cmdline);
+    if (p->environ)
+	free((void*)*p->environ);
+    free(p);
 }
 
 
@@ -1199,7 +914,6 @@ void look_up_our_self(proc_t *p) {
 
 HIDDEN_ALIAS(readproc);
 HIDDEN_ALIAS(readtask);
-HIDDEN_ALIAS(readeither);
 
 /* Convenient wrapper around openproc and readproc to slurp in the whole process
  * table subset satisfying the constraints of flags and the optional PID list.
@@ -1239,7 +953,6 @@ proc_t** readproctab(int flags, ...) {
 
 // Try again, this time with threads and selection.
 proc_data_t *readproctab2(int(*want_proc)(proc_t *buf), int(*want_task)(proc_t *buf), PROCTAB *restrict const PT) {
-    static proc_data_t pd;
     proc_t** ptab = NULL;
     unsigned n_proc_alloc = 0;
     unsigned n_proc = 0;
@@ -1252,6 +965,8 @@ proc_data_t *readproctab2(int(*want_proc)(proc_t *buf), int(*want_task)(proc_t *
     unsigned n_alloc = 0;
     unsigned long n_used = 0;
 
+    proc_data_t *pd;
+
     for(;;){
         proc_t *tmp;
         if(n_alloc == n_used){
@@ -1259,7 +974,6 @@ proc_data_t *readproctab2(int(*want_proc)(proc_t *buf), int(*want_task)(proc_t *
           n_alloc = n_alloc*5/4+30;  // grow by over 25%
           data = realloc(data,sizeof(proc_t)*n_alloc);
           //if(!data) return NULL;
-          memset(data+n_used, 0, sizeof(proc_t)*(n_alloc-n_used));
         }
         if(n_proc_alloc == n_proc){
           //proc_t **old = ptab;
@@ -1278,10 +992,9 @@ proc_data_t *readproctab2(int(*want_proc)(proc_t *buf), int(*want_task)(proc_t *
             proc_t *old = data;
             n_alloc = n_alloc*5/4+30;  // grow by over 25%
             data = realloc(data,sizeof(proc_t)*n_alloc);
-            // have to move tmp too
-            tmp = data+(tmp-old);
+	    // have to move tmp too
+	    tmp = data+(tmp-old);
             //if(!data) return NULL;
-            memset(data+n_used+1, 0, sizeof(proc_t)*(n_alloc-(n_used+1)));
           }
           if(n_task_alloc == n_task){
             //proc_t **old = ttab;
@@ -1296,49 +1009,23 @@ proc_data_t *readproctab2(int(*want_proc)(proc_t *buf), int(*want_task)(proc_t *
         }
     }
 
-    pd.proc  = ptab;
-    pd.task  = ttab;
-    pd.nproc = n_proc;
-    pd.ntask = n_task;
+    pd = malloc(sizeof(proc_data_t));
+    pd->proc = ptab;
+    pd->task = ttab;
+    pd->nproc = n_proc;
+    pd->ntask = n_task;
     if(PT->flags & PROC_LOOSE_TASKS){
-      pd.tab = ttab;
-      pd.n   = n_task;
+      pd->tab = ttab;
+      pd->n   = n_task;
     }else{
-      pd.tab = ptab;
-      pd.n   = n_proc;
+      pd->tab = ptab;
+      pd->n   = n_proc;
     }
     // change array indexes to pointers
     while(n_proc--) ptab[n_proc] = data+(long)(ptab[n_proc]);
     while(n_task--) ttab[n_task] = data+(long)(ttab[n_task]);
 
-    return &pd;
-}
-
-// Try try yet again, this time treating processes and threads the same...
-proc_data_t *readproctab3 (int(*want_task)(proc_t *buf), PROCTAB *restrict const PT) {
-    static proc_data_t pd;
-    proc_t **tab = NULL;
-    unsigned n_alloc = 0;
-    unsigned n_used = 0;
-    proc_t *p = NULL;
-
-    for (;;) {
-        if (n_alloc == n_used) {
-            n_alloc = n_alloc*5/4+30;  // grow by over 25%
-            tab = realloc(tab,sizeof(proc_t*)*n_alloc);
-        }
-        // let this next guy allocate the necessary proc_t storage
-        // (or recycle it) since he can't tolerate realloc relocations
-        if (!(p = readeither_direct(PT,p))) break;
-        if (want_task(p)) {
-            tab[n_used++] = p;
-            p = NULL;
-        }
-    }
-
-    pd.tab = tab;
-    pd.n = n_used;
-    return &pd;
+    return pd;
 }
 
 /*
@@ -1366,6 +1053,3 @@ proc_t * get_proc_stats(pid_t pid, proc_t *p) {
 
 	return p;
 }
-
-#undef MK_THREAD
-#undef IS_THREAD
diff --git a/proc/readproc.h b/readproc.h
similarity index 71%
rename from proc/readproc.h
rename to readproc.h
index b9d93d9c..a953b291 100644
--- a/proc/readproc.h
+++ b/readproc.h
@@ -14,7 +14,6 @@
 #include "pwcache.h"
 
 #define SIGNAL_STRING
-#define QUICK_THREADS        /* copy (vs. read) some thread info from parent proc_t */
 
 EXTERN_C_BEGIN
 
@@ -45,11 +44,7 @@ typedef struct proc_t {
         pcpu;           // stat (special)  %CPU usage (is not filled in by readproc!!!)
     char
     	state,		// stat,status     single-char code for process state (S=sleeping)
-#ifdef QUICK_THREADS
-        pad_1,          // n/a             padding (psst, also used if multi-threaded)
-#else
-        pad_1,          // n/a             padding
-#endif
+    	pad_1,		// n/a             padding
     	pad_2,		// n/a             padding
     	pad_3;		// n/a             padding
 // 2nd 16 bytes
@@ -87,25 +82,24 @@ typedef struct proc_t {
     long
 	priority,	// stat            kernel scheduling priority
 	nice,		// stat            standard unix nice level of process
-	rss,		// stat            identical to 'resident'
+	rss,		// stat            resident set size from /proc/#/stat (pages)
 	alarm,		// stat            ?
     // the next 7 members come from /proc/#/statm
-	size,		// statm           total virtual memory (as # pages)
-	resident,	// statm           resident non-swapped memory (as # pages)
-	share,		// statm           shared (mmap'd) memory (as # pages)
-	trs,		// statm           text (exe) resident set (as # pages)
-	lrs,		// statm           library resident set (always 0 w/ 2.6)
-	drs,		// statm           data+stack resident set (as # pages)
-	dt;		// statm           dirty pages (always 0 w/ 2.6)
+	size,		// statm           total # of pages of memory
+	resident,	// statm           number of resident set (non-swapped) pages (4k)
+	share,		// statm           number of pages of shared (mmap'd) memory
+	trs,		// statm           text resident set size
+	lrs,		// statm           shared-lib resident set size
+	drs,		// statm           data resident set size
+	dt;		// statm           dirty pages
     unsigned long
-	vm_size,        // status          equals 'size' (as kb)
-	vm_lock,        // status          locked pages (as kb)
-	vm_rss,         // status          equals 'rss' and/or 'resident' (as kb)
-	vm_data,        // status          data only size (as kb)
-	vm_stack,       // status          stack only size (as kb)
-	vm_swap,        // status          based on linux-2.6.34 "swap ents" (as kb)
-	vm_exe,         // status          equals 'trs' (as kb)
-	vm_lib,         // status          total, not just used, library pages (as kb)
+	vm_size,        // status          same as vsize in kb
+	vm_lock,        // status          locked pages in kb
+	vm_rss,         // status          same as rss in kb
+	vm_data,        // status          data size
+	vm_stack,       // status          stack size
+	vm_exe,         // status          executable size
+	vm_lib,         // status          library size (all pages, not just used ones)
 	rtprio,		// stat            real-time priority
 	sched,		// stat            scheduling class
 	vsize,		// stat            number of pages of virtual memory ...
@@ -116,11 +110,8 @@ typedef struct proc_t {
 	cmin_flt,	// stat            cumulative min_flt of process and child processes
 	cmaj_flt;	// stat            cumulative maj_flt of process and child processes
     char
-        **environ,      // (special)       environment string vector (/proc/#/environ)
-        **cmdline,      // (special)       command line string vector (/proc/#/cmdline)
-        **cgroup,       // (special)       cgroup string vector (/proc/#/cgroup)
-         *supgid,       // status          supplementary gids as comma delimited str
-         *supgrp;       // supp grp names as comma delimited str, derived from supgid
+	**environ,	// (special)       environment string vector (/proc/#/environ)
+	**cmdline;	// (special)       command line string vector (/proc/#/cmdline)
     char
 	// Be compatible: Digital allows 16 and NT allows 14 ???
     	euser[P_G_SZ],	// stat(),status   effective user name
@@ -139,7 +130,7 @@ typedef struct proc_t {
 	pgrp,		// stat            process group id
 	session,	// stat            session id
 	nlwp,		// stat,status     number of threads, or 0 if no clue
-	tgid,		// (special)       thread group ID, the POSIX PID (see also: tid)
+	tgid,		// (special)       task group ID, the POSIX PID (see also: tid)
 	tty,		// stat            full device number of controlling terminal
         euid, egid,     // stat(),status   effective
         ruid, rgid,     // status          real
@@ -148,11 +139,6 @@ typedef struct proc_t {
 	tpgid,		// stat            terminal process group id
 	exit_signal,	// stat            might not be SIGCHLD
 	processor;      // stat            current (or most recent?) CPU
-#ifdef OOMEM_ENABLE
-    int
-        oom_score,      // oom_score       (badness for OOM killer)
-        oom_adj;        // oom_adj         (adjustment to OOM score)
-#endif
 } proc_t;
 
 // PROCTAB: data structure holding the persistent information readproc needs
@@ -187,53 +173,44 @@ typedef struct PROCTAB {
     unsigned pathlen;        // length of string in the above (w/o '\0')
 } PROCTAB;
 
-// Initialize a PROCTAB structure holding needed call-to-call persistent data
+// initialize a PROCTAB structure holding needed call-to-call persistent data
 extern PROCTAB* openproc(int flags, ... /* pid_t*|uid_t*|dev_t*|char* [, int n] */ );
 
-typedef struct proc_data_t {  // valued by: (else zero)
-    proc_t **tab;             //     readproctab2, readproctab3
-    proc_t **proc;            //     readproctab2
-    proc_t **task;            //  *  readproctab2
-    int n;                    //     readproctab2, readproctab3
-    int nproc;                //     readproctab2
-    int ntask;                //  *  readproctab2
-} proc_data_t;                //  *  when PROC_LOOSE_TASKS set
+typedef struct proc_data_t {
+    proc_t **tab;
+    proc_t **proc;
+    proc_t **task;
+    int n;
+    int nproc;
+    int ntask;
+} proc_data_t;
 
 extern proc_data_t *readproctab2(int(*want_proc)(proc_t *buf), int(*want_task)(proc_t *buf), PROCTAB *restrict const PT);
-extern proc_data_t *readproctab3(int(*want_task)(proc_t *buf), PROCTAB *restrict const PT);
 
 // Convenient wrapper around openproc and readproc to slurp in the whole process
 // table subset satisfying the constraints of flags and the optional PID list.
 // Free allocated memory with exit().  Access via tab[N]->member.  The pointer
 // list is NULL terminated.
+
 extern proc_t** readproctab(int flags, ... /* same as openproc */ );
 
-// Clean-up open files, etc from the openproc()
+// clean-up open files, etc from the openproc()
 extern void closeproc(PROCTAB* PT);
 
-// Retrieve the next process or task matching the criteria set by the openproc().
-//
-// Note: When NULL is used as the readproc 'p', readtask 't' or readeither 'x'
-//       parameter, the library will allocate the necessary proc_t storage.
-//
-//       Alternatively, you may provide your own reuseable buffer address
-//       in which case that buffer *MUST* be initialized to zero one time
-//       only before first use.  Thereafter, the library will manage such
-//       a passed proc_t, freeing any additional acquired memory associated
-//       with the previous process or thread.
+// retrieve the next process matching the criteria set by the openproc()
 extern proc_t* readproc(PROCTAB *restrict const PT, proc_t *restrict p);
 extern proc_t* readtask(PROCTAB *restrict const PT, const proc_t *restrict const p, proc_t *restrict t);
-extern proc_t* readeither(PROCTAB *restrict const PT, proc_t *restrict x);
 
 // warning: interface may change
 extern int read_cmdline(char *restrict const dst, unsigned sz, unsigned pid);
 
 extern void look_up_our_self(proc_t *p);
 
-// Deallocate space allocated by readproc
+// deallocate space allocated by readproc
+
 extern void freeproc(proc_t* p);
 
-// Fill out a proc_t for a single task
+//fill out a proc_t for a single task
 extern proc_t * get_proc_stats(pid_t pid, proc_t *p);
 
 // openproc/readproctab:
@@ -255,23 +232,17 @@ extern proc_t * get_proc_stats(pid_t pid, proc_t *p);
 #define PROC_FILLENV         0x0004 // alloc and fill in `environ'
 #define PROC_FILLUSR         0x0008 // resolve user id number -> user name
 #define PROC_FILLGRP         0x0010 // resolve group id number -> group name
-#define PROC_FILLSTATUS      0x0020 // read status
-#define PROC_FILLSTAT        0x0040 // read stat
+#define PROC_FILLSTATUS      0x0020 // read status -- currently unconditional
+#define PROC_FILLSTAT        0x0040 // read stat -- currently unconditional
 #define PROC_FILLWCHAN       0x0080 // look up WCHAN name
 #define PROC_FILLARG         0x0100 // alloc and fill in `cmdline'
-#define PROC_FILLCGROUP      0x0200 // alloc and fill in `cgroup`
-#define PROC_FILLSUPGRP      0x0400 // resolve supplementary group id -> group name
-#define PROC_FILLOOM         0x0800 // fill in proc_t oom_score and oom_adj
 
-#define PROC_LOOSE_TASKS     0x2000 // treat threads as if they were processes
+#define PROC_LOOSE_TASKS     0x0200 // threat threads as if they were processes
 
 // Obsolete, consider only processes with one of the passed:
 #define PROC_PID             0x1000  // process id numbers ( 0   terminated)
 #define PROC_UID             0x4000  // user id numbers    ( length needed )
 
-#define PROC_EDITCGRPCVT    0x10000 // edit `cgroup' as single vector
-#define PROC_EDITCMDLCVT    0x20000 // edit `cmdline' as single vector
-
 // it helps to give app code a few spare bits
 #define PROC_SPARE_1     0x01000000
 #define PROC_SPARE_2     0x02000000
diff --git a/proc/sig.c b/sig.c
similarity index 97%
rename from proc/sig.c
rename to sig.c
index 3d6e0584..53ed8d8b 100644
--- a/proc/sig.c
+++ b/sig.c
@@ -214,7 +214,7 @@ void pretty_print_signals(void){
   while(++i <= number_of_signals){
     int n;
     n = printf("%2d %s", i, signal_number_to_name(i));
-    if(n>0 && i%7) printf("           \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0" + n);
+    if(i%7) printf("%*c",n,' ');
     else printf("\n");
   }
   if((i-1)%7) printf("\n");
@@ -231,7 +231,7 @@ void unix_print_signals(void){
 }
 
 /* sanity check */
-static int init_signal_list(void) __attribute__((constructor));
+static int init_signal_list(void) __attribute__((constructor(101)));
 static int init_signal_list(void){
   if(number_of_signals != 31){
     fprintf(stderr, "WARNING: %d signals -- adjust and recompile.\n", number_of_signals);
diff --git a/proc/sig.h b/sig.h
similarity index 100%
rename from proc/sig.h
rename to sig.h
diff --git a/skill.1 b/skill.1
deleted file mode 100644
index 9289cc19..00000000
--- a/skill.1
+++ /dev/null
@@ -1,129 +0,0 @@
-'\" t
-.\" (The preceding line is a note to broken versions of man to tell
-.\" them to pre-process this man page with tbl)
-.\" Man page for skill and snice.
-.\" Licensed under version 2 of the GNU General Public License.
-.\" Written by Albert Cahalan, converted to a man page by
-.\" Michael K. Johnson
-.\"
-.TH SKILL 1 "March 12, 1999" "Linux" "Linux User's Manual"
-.SH NAME
-skill, snice \- send a signal or report process status
-
-.SH SYNOPSIS
-.B skill
-.RI [ "signal to send" ]
-.RI [ options ]
-.I process selection criteria
-.br
-.B snice
-.RI [ "new priority" ]
-.RI [ options ]
-.I process selection criteria
-
-.SH DESCRIPTION
-These tools are probably obsolete and unportable. The command
-syntax is poorly defined. Consider using the killall, pkill,
-and pgrep commands instead.
-
-The default signal for skill is TERM. Use \-l or \-L to list available signals.
-Particularly useful signals include HUP, INT, KILL, STOP, CONT, and 0.
-Alternate signals may be specified in three ways: \-9 \-SIGKILL \-KILL.
-
-The default priority for snice is +4. (snice +4 ...)
-Priority numbers range from +20 (slowest) to \-20 (fastest).
-Negative priority numbers are restricted to administrative users.
-
-.SH "GENERAL OPTIONS"
-.TS
-lB l l.
-\-f	fast mode	This is not currently useful.
-\-i	interactive use	You will be asked to approve each action.
-\-v	verbose output	Display information about selected processes.
-\-w	warnings enabled	This is not currently useful.
-\-n	no action	This only displays the process ID.
-\-V	show version	Displays version of program.
-.TE
-
-.SH "PROCESS SELECTION OPTIONS"
-Selection criteria can be: terminal, user, pid, command.
-The options below may be used to ensure correct interpretation.
-Do not blame Albert for this interesting interface.
-.TS
-lB l.
-\-t	The next argument is a terminal (tty or pty).
-\-u	The next argument is a username.
-\-p	The next argument is a process ID number.
-\-c	The next argument is a command name.
-.TE
-
-.SH SIGNALS
-The signals listed below may be available for use with skill.
-When known, numbers and default behavior are shown.
-.TS
-lB rB lB lB
-lfCW r l l.
-Name	Num	Action	Description
-0	0	n/a	exit code indicates if a signal may be sent
-ALRM	14	exit
-HUP	1	exit
-INT	2	exit
-KILL	9	exit	this signal may not be blocked
-PIPE	13	exit
-POLL		exit
-PROF		exit
-TERM	15	exit
-USR1		exit
-USR2		exit
-VTALRM		exit
-STKFLT		exit	may not be implemented
-PWR		ignore	may exit on some systems
-WINCH		ignore
-CHLD		ignore
-URG		ignore
-TSTP		stop	may interact with the shell
-TTIN		stop	may interact with the shell
-TTOU		stop	may interact with the shell
-STOP		stop	this signal may not be blocked
-CONT		restart	continue if stopped, otherwise ignore
-ABRT	6	core
-FPE	8	core
-ILL	4	core
-QUIT	3	core
-SEGV	11	core
-TRAP	5	core
-SYS		core	may not be implemented
-EMT		core	may not be implemented
-BUS		core	core dump may fail
-XCPU		core	core dump may fail
-XFSZ		core	core dump may fail
-.TE
-
-.SH EXAMPLES
-.TS
-lB lB
-lfCW l.
-Command	Description
-snice seti crack +7	Slow down seti and crack
-skill \-KILL \-v /dev/pts/*	Kill users on new-style PTY devices
-skill \-STOP viro lm davem	Stop 3 users
-snice \-17 root bash	Give priority to root's shell
-.TE
-
-.SH "SEE ALSO"
-.BR killall (1),
-.BR pkill (1),
-.BR kill (1),
-.BR renice (1),
-.BR nice (1),
-.BR kill (2),
-.BR signal (7)
-
-.SH STANDARDS
-No standards apply.
-
-.SH AUTHOR
-Albert Cahalan <albert@users.sf.net> wrote skill and snice in 1999 as a
-replacement for a non-free version.
-
-Please send bug reports to <procps@freelists.org>.
diff --git a/skill.c b/skill.c
deleted file mode 100644
index 1aa1a54d..00000000
--- a/skill.c
+++ /dev/null
@@ -1,580 +0,0 @@
-/*
- * Copyright 1998-2002 by Albert Cahalan; all rights resered.
- * This file may be used subject to the terms and conditions of the
- * GNU Library General Public License Version 2, or any later version
- * at your option, as published by the Free Software Foundation.
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Library General Public License for more details.
- */
-#include <fcntl.h>
-#include <pwd.h>
-#include <dirent.h>
-#include <errno.h>
-#include <signal.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sys/resource.h>
-#include <sys/stat.h>
-#include <sys/time.h>
-#include <sys/types.h>
-#include <unistd.h>
-#include "proc/pwcache.h"
-#include "proc/sig.h"
-#include "proc/devname.h"
-#include "proc/procps.h"  /* char *user_from_uid(uid_t uid) */
-#include "proc/version.h" /* procps_version */
-
-static int f_flag, i_flag, v_flag, w_flag, n_flag;
-
-static int tty_count, uid_count, cmd_count, pid_count;
-static int *ttys;
-static uid_t *uids;
-static const char **cmds;
-static int *pids;
-
-#define ENLIST(thing,addme) do{ \
-if(!thing##s) thing##s = malloc(sizeof(*thing##s)*saved_argc); \
-if(!thing##s) fprintf(stderr,"No memory.\n"),exit(2); \
-thing##s[thing##_count++] = addme; \
-}while(0)
-
-static int my_pid;
-static int saved_argc;
-
-static int sig_or_pri;
-
-static int program = -1;
-#define PROG_KILL  1
-#define PROG_SKILL 2
-/* #define PROG_NICE  3 */ /* easy, but the old one isn't broken */
-#define PROG_SNICE 4
-
-
-/********************************************************************/
-
-static void display_kill_version(void){
-  switch(program) {
-    case PROG_KILL:
-      fprintf(stdout, "kill (%s)\n",procps_version);
-      return;
-    case PROG_SKILL:
-      fprintf(stdout, "skill (%s)\n",procps_version);
-      return;
-    case PROG_SNICE:
-      fprintf(stdout, "snice (%s)\n",procps_version);
-      return;
-    default:
-      fprintf(stdout, "unknown (%s)\n",procps_version);
-      return;
-  }
-}
-
-/***** kill or nice a process */
-static void hurt_proc(int tty, int uid, int pid, const char *restrict const cmd){
-  int failed;
-  int saved_errno;
-  char dn_buf[1000];
-  dev_to_tty(dn_buf, 999, tty, pid, ABBREV_DEV);
-  if(i_flag){
-    char buf[8];
-    fprintf(stderr, "%-8s %-8s %5d %-16.16s   ? ",
-      (char*)dn_buf,user_from_uid(uid),pid,cmd
-    );
-    if(!fgets(buf,7,stdin)){
-      printf("\n");
-      exit(0);
-    }
-    if(*buf!='y' && *buf!='Y') return;
-  }
-  /* do the actual work */
-  if(program==PROG_SKILL) failed=kill(pid,sig_or_pri);
-  else                    failed=setpriority(PRIO_PROCESS,pid,sig_or_pri);
-  saved_errno = errno;
-  if(w_flag && failed){
-    fprintf(stderr, "%-8s %-8s %5d %-16.16s   ",
-      (char*)dn_buf,user_from_uid(uid),pid,cmd
-    );
-    errno = saved_errno;
-    perror("");
-    return;
-  }
-  if(i_flag) return;
-  if(v_flag){
-    printf("%-8s %-8s %5d %-16.16s\n",
-      (char*)dn_buf,user_from_uid(uid),pid,cmd
-    );
-    return;
-  }
-  if(n_flag){
-   printf("%d\n",pid);
-   return;
-  }
-}
-
-
-/***** check one process */
-static void check_proc(int pid){
-  char buf[128];
-  struct stat statbuf;
-  char *tmp;
-  int tty;
-  int fd;
-  int i;
-  if(pid==my_pid) return;
-  sprintf(buf, "/proc/%d/stat", pid); /* pid (cmd) state ppid pgrp session tty */
-  fd = open(buf,O_RDONLY);
-  if(fd==-1){  /* process exited maybe */
-    if(pids && w_flag) printf("WARNING: process %d could not be found.",pid);
-    return;
-  }
-  fstat(fd, &statbuf);
-  if(uids){  /* check the EUID */
-    i=uid_count;
-    while(i--) if(uids[i]==statbuf.st_uid) break;
-    if(i==-1) goto closure;
-  }
-  read(fd,buf,128);
-  buf[127] = '\0';
-  tmp = strrchr(buf, ')');
-  *tmp++ = '\0';
-  i = 5; while(i--) while(*tmp++!=' '); /* scan to find tty */
-  tty = atoi(tmp);
-  if(ttys){
-    i=tty_count;
-    while(i--) if(ttys[i]==tty) break;
-    if(i==-1) goto closure;
-  }
-  tmp = strchr(buf, '(') + 1;
-  if(cmds){
-    i=cmd_count;
-    /* fast comparison trick -- useful? */
-    while(i--) if(cmds[i][0]==*tmp && !strcmp(cmds[i],tmp)) break;
-    if(i==-1) goto closure;
-  }
-  /* This is where we kill/nice something. */
-/*  fprintf(stderr, "PID %d, UID %d, TTY %d,%d, COMM %s\n",
-    pid, statbuf.st_uid, tty>>8, tty&0xf, tmp
-  );
-*/
-  hurt_proc(tty, statbuf.st_uid, pid, tmp);
-closure:
-  close(fd); /* kill/nice _first_ to avoid PID reuse */
-}
-
-
-/***** debug function */
-#if 0
-static void show_lists(void){
-  int i;
-
-  fprintf(stderr, "%d TTY: ", tty_count);
-  if(ttys){
-    i=tty_count;
-    while(i--){
-      fprintf(stderr, "%d,%d%c", (ttys[i]>>8)&0xff, ttys[i]&0xff, i?' ':'\n');
-    }
-  }else fprintf(stderr, "\n");
-  
-  fprintf(stderr, "%d UID: ", uid_count);
-  if(uids){
-    i=uid_count;
-    while(i--) fprintf(stderr, "%d%c", uids[i], i?' ':'\n');
-  }else fprintf(stderr, "\n");
-  
-  fprintf(stderr, "%d PID: ", pid_count);
-  if(pids){
-    i=pid_count;
-    while(i--) fprintf(stderr, "%d%c", pids[i], i?' ':'\n');
-  }else fprintf(stderr, "\n");
-  
-  fprintf(stderr, "%d CMD: ", cmd_count);
-  if(cmds){
-    i=cmd_count;
-    while(i--) fprintf(stderr, "%s%c", cmds[i], i?' ':'\n');
-  }else fprintf(stderr, "\n");
-}
-#endif
-
-
-/***** iterate over all PIDs */
-static void iterate(void){
-  int pid;
-  DIR *d;
-  struct dirent *de;
-  if(pids){
-    pid = pid_count;
-    while(pid--) check_proc(pids[pid]);
-    return;
-  }
-#if 0
-  /* could setuid() and kill -1 to have the kernel wipe out a user */
-  if(!ttys && !cmds && !pids && !i_flag){
-  }
-#endif
-  d = opendir("/proc");
-  if(!d){
-    perror("/proc");
-    exit(1);
-  }
-  while(( de = readdir(d) )){
-    if(de->d_name[0] > '9') continue;
-    if(de->d_name[0] < '1') continue;
-    pid = atoi(de->d_name);
-    if(pid) check_proc(pid);
-  }
-  closedir (d);
-}
-
-/***** kill help */
-static void kill_usage(void) NORETURN;
-static void kill_usage(void){
-  fprintf(stderr,
-    "Usage:\n"
-    "  kill pid ...              Send SIGTERM to every process listed.\n"
-    "  kill signal pid ...       Send a signal to every process listed.\n"
-    "  kill -s signal pid ...    Send a signal to every process listed.\n"
-    "  kill -l                   List all signal names.\n"
-    "  kill -L                   List all signal names in a nice table.\n"
-    "  kill -l signal            Convert between signal numbers and names.\n"
-  );
-  exit(1);
-}
-
-/***** kill */
-static void kill_main(int argc, const char *restrict const *restrict argv) NORETURN;
-static void kill_main(int argc, const char *restrict const *restrict argv){
-  const char *sigptr;
-  int signo = SIGTERM;
-  int exitvalue = 0;
-  if(argc<2) kill_usage();
-  if(!strcmp(argv[1],"-V")|| !strcmp(argv[1],"--version")){
-    display_kill_version();
-    exit(0);
-  }
-  if(argv[1][0]!='-'){
-    argv++;
-    argc--;
-    goto no_more_args;
-  }
-
-  /* The -l option prints out signal names. */
-  if(argv[1][1]=='l' && argv[1][2]=='\0'){
-    if(argc==2){
-      unix_print_signals();
-      exit(0);
-    }
-    /* at this point, argc must be 3 or more */
-    if(argc>128 || argv[2][0] == '-') kill_usage();
-    exit(print_given_signals(argc-2, argv+2, 80));
-  }
-
-  /* The -L option prints out signal names in a nice table. */
-  if(argv[1][1]=='L' && argv[1][2]=='\0'){
-    if(argc==2){
-      pretty_print_signals();
-      exit(0);
-    }
-    kill_usage();
-  }
-  if(argv[1][1]=='-' && argv[1][2]=='\0'){
-    argv+=2;
-    argc-=2;
-    goto no_more_args;
-  }
-  if(argv[1][1]=='-') kill_usage(); /* likely --help */
-  // FIXME: "kill -sWINCH $$" not handled
-  if(argv[1][2]=='\0' && (argv[1][1]=='s' || argv[1][1]=='n')){
-    sigptr = argv[2];
-    argv+=3;
-    argc-=3;
-  }else{
-    sigptr = argv[1]+1;
-    argv+=2;
-    argc-=2;
-  }
-  signo = signal_name_to_number(sigptr);
-  if(signo<0){
-    fprintf(stderr, "ERROR: unknown signal name \"%s\".\n", sigptr);
-    kill_usage();
-  }
-no_more_args:
-  if(!argc) kill_usage();  /* nothing to kill? */
-  while(argc--){
-    long pid;
-    char *endp;
-    pid = strtol(argv[argc],&endp,10);
-    if(!*endp){
-      if(!kill((pid_t)pid,signo)) continue;
-      // The UNIX standard contradicts itself. If at least one process
-      // is matched for each PID (as if processes could share PID!) and
-      // "the specified signal was successfully processed" (the systcall
-      // returned zero?) for at least one of those processes, then we must
-      // exit with zero. Note that an error might have also occured.
-      // The standard says we return non-zero if an error occurs. Thus if
-      // killing two processes gives 0 for one and EPERM for the other,
-      // we are required to return both zero and non-zero. Quantum kill???
-      exitvalue = 1;
-      continue;
-    }
-    fprintf(stderr, "ERROR: garbage process ID \"%s\".\n", argv[argc]);
-    kill_usage();
-  }
-  exit(exitvalue);
-}
-
-/***** skill/snice help */
-static void skillsnice_usage(void) NORETURN;
-static void skillsnice_usage(void){
-  if(program==PROG_SKILL){
-    fprintf(stderr,
-      "Usage:   skill [signal to send] [options] process selection criteria\n"
-      "Example: skill -KILL -v pts/*\n"
-      "\n"
-      "The default signal is TERM. Use -l or -L to list available signals.\n"
-      "Particularly useful signals include HUP, INT, KILL, STOP, CONT, and 0.\n"
-      "Alternate signals may be specified in three ways: -SIGKILL -KILL -9\n"
-    );
-  }else{
-    fprintf(stderr,
-      "Usage:   snice [new priority] [options] process selection criteria\n"
-      "Example: snice netscape crack +7\n"
-      "\n"
-      "The default priority is +4. (snice +4 ...)\n"
-      "Priority numbers range from +20 (slowest) to -20 (fastest).\n"
-      "Negative priority numbers are restricted to administrative users.\n"
-    );
-  }
-  fprintf(stderr,
-    "\n"
-    "General options:\n"
-    "-f  fast mode            This is not currently useful.\n"
-    "-i  interactive use      You will be asked to approve each action.\n"
-    "-v  verbose output       Display information about selected processes.\n"
-    "-w  warnings enabled     This is not currently useful.\n"
-    "-n  no action            This only displays the process ID.\n"
-    "\n"
-    "Selection criteria can be: terminal, user, pid, command.\n"
-    "The options below may be used to ensure correct interpretation.\n"
-    "-t  The next argument is a terminal (tty or pty).\n"
-    "-u  The next argument is a username.\n"
-    "-p  The next argument is a process ID number.\n"
-    "-c  The next argument is a command name.\n"
-  );
-  exit(1);
-}
-
-#if 0
-static void _skillsnice_usage(int line){
-  fprintf(stderr,"Something at line %d.\n", line);
-  skillsnice_usage();
-}
-#define skillsnice_usage() _skillsnice_usage(__LINE__)
-#endif
-
-#define NEXTARG (argc?( argc--, ((argptr=*++argv)) ):NULL)
-
-/***** common skill/snice argument parsing code */
-#define NO_PRI_VAL ((int)0xdeafbeef)
-static void skillsnice_parse(int argc, const char *restrict const *restrict argv){
-  int signo = -1;
-  int prino = NO_PRI_VAL;
-  int force = 0;
-  int num_found = 0;
-  const char *restrict argptr;
-  if(argc<2) skillsnice_usage();
-  if(argc==2 && argv[1][0]=='-'){
-    if(!strcmp(argv[1],"-L")){
-      pretty_print_signals();
-      exit(0);
-    }
-    if(!strcmp(argv[1],"-l")){
-      unix_print_signals();
-      exit(0);
-    }
-    if(!strcmp(argv[1],"-V")|| !strcmp(argv[1],"--version")){
-      display_kill_version();
-      exit(0);
-    }
-    skillsnice_usage();
-  }
-  NEXTARG;
-  /* Time for serious parsing. What does "skill -int 123 456" mean? */
-  while(argc){
-    if(force && !num_found){  /* if forced, _must_ find something */
-      fprintf(stderr,"ERROR: -%c used with bad data.\n", force);
-      skillsnice_usage();
-    }
-    force = 0;
-    if(program==PROG_SKILL && signo<0 && *argptr=='-'){
-      signo = signal_name_to_number(argptr+1);
-      if(signo>=0){      /* found a signal */
-        if(!NEXTARG) break;
-        continue;
-      }
-    }
-    if(program==PROG_SNICE && prino==NO_PRI_VAL
-    && (*argptr=='+' || *argptr=='-') && argptr[1]){
-      long val;
-      char *endp;
-      val = strtol(argptr,&endp,10);
-      if(!*endp && val<=999 && val>=-999){
-        prino=val;
-        if(!NEXTARG) break;
-        continue;
-      }
-    }
-    /* If '-' found, collect any flags. (but lone "-" is a tty) */
-    if(*argptr=='-' && argptr[1]){
-      argptr++;
-      do{
-        switch(( force = *argptr++ )){
-        default:  skillsnice_usage();
-        case 't':
-        case 'u':
-        case 'p':
-        case 'c':
-          if(!*argptr){ /* nothing left here, *argptr is '\0' */
-            if(!NEXTARG){
-              fprintf(stderr,"ERROR: -%c with nothing after it.\n", force);
-              skillsnice_usage();
-            }
-          }
-          goto selection_collection;
-        case 'f': f_flag++; break;
-        case 'i': i_flag++; break;
-        case 'v': v_flag++; break;
-        case 'w': w_flag++; break;
-        case 'n': n_flag++; break;
-        case 0:
-          NEXTARG;
-          /*
-           * If no more arguments, all the "if(argc)..." tests will fail
-           * and the big loop will exit.
-           */
-        } /* END OF SWITCH */
-      }while(force);
-    } /* END OF IF */
-selection_collection:
-    num_found = 0; /* we should find at least one thing */
-    switch(force){ /* fall through each data type */
-    default: skillsnice_usage();
-    case 0: /* not forced */
-    case 't':
-      if(argc){
-        struct stat sbuf;
-        char path[32];
-        if(!argptr) skillsnice_usage(); /* Huh? Maybe "skill -t ''". */
-        snprintf(path,32,"/dev/%s",argptr);
-        if(stat(path, &sbuf)>=0 && S_ISCHR(sbuf.st_mode)){
-          num_found++;
-          ENLIST(tty,sbuf.st_rdev);
-          if(!NEXTARG) break;
-        }else if(!(argptr[1])){  /* if only 1 character */
-          switch(*argptr){
-          default:
-            if(stat(argptr,&sbuf)<0) break; /* the shell eats '?' */
-          case '-':
-          case '?':
-            num_found++;
-            ENLIST(tty,0);
-            if(!NEXTARG) break;
-          }
-        }
-      }
-      if(force) continue;
-    case 'u':
-      if(argc){
-        struct passwd *passwd_data;
-        passwd_data = getpwnam(argptr);
-        if(passwd_data){
-          num_found++;
-          ENLIST(uid,passwd_data->pw_uid);
-          if(!NEXTARG) break;
-        }
-      }
-      if(force) continue;
-    case 'p':
-      if(argc && *argptr>='0' && *argptr<='9'){
-        char *endp;
-        int num;
-        num = strtol(argptr, &endp, 0);
-        if(*endp == '\0'){
-          num_found++;
-          ENLIST(pid,num);
-          if(!NEXTARG) break;
-        }
-      }
-      if(force) continue;
-      if(num_found) continue; /* could still be an option */
-    case 'c':
-      if(argc){
-        num_found++;
-        ENLIST(cmd,argptr);
-        if(!NEXTARG) break;
-      }
-    } /* END OF SWITCH */
-  } /* END OF WHILE */
-  /* No more arguments to process. Must sanity check. */
-  if(!tty_count && !uid_count && !cmd_count && !pid_count){
-    fprintf(stderr,"ERROR: no process selection criteria.\n");
-    skillsnice_usage();
-  }
-  if((f_flag|i_flag|v_flag|w_flag|n_flag) & ~1){
-    fprintf(stderr,"ERROR: general flags may not be repeated.\n");
-    skillsnice_usage();
-  }
-  if(i_flag && (v_flag|f_flag|n_flag)){
-    fprintf(stderr,"ERROR: -i makes no sense with -v, -f, and -n.\n");
-    skillsnice_usage();
-  }
-  if(v_flag && (i_flag|f_flag)){
-    fprintf(stderr,"ERROR: -v makes no sense with -i and -f.\n");
-    skillsnice_usage();
-  }
-  /* OK, set up defaults */
-  if(prino==NO_PRI_VAL) prino=4;
-  if(signo<0) signo=SIGTERM;
-  if(n_flag){
-    program=PROG_SKILL;
-    signo=0; /* harmless */
-  }
-  if(program==PROG_SKILL) sig_or_pri = signo;
-  else sig_or_pri = prino;
-}
-
-/***** main body */
-int main(int argc, const char *argv[]){
-  const char *tmpstr;
-  my_pid = getpid();
-  saved_argc = argc;
-  if(!argc){
-    fprintf(stderr,"ERROR: could not determine own name.\n");
-    exit(1);
-  }
-  tmpstr=strrchr(*argv,'/');
-  if(tmpstr) tmpstr++;
-  if(!tmpstr) tmpstr=*argv;
-  if(strstr(tmpstr,"kill"))  program = PROG_KILL;
-  if(strstr(tmpstr,"skill")) program = PROG_SKILL;
-  if(strstr(tmpstr,"snice")) program = PROG_SNICE;
-  switch(program){
-  case PROG_SNICE:
-  case PROG_SKILL:
-    setpriority(PRIO_PROCESS,my_pid,-20);
-    skillsnice_parse(argc, argv);
-/*    show_lists(); */
-    iterate(); /* this is it, go get them */
-    break;
-  case PROG_KILL:
-    kill_main(argc, argv);
-    break;
-  default:
-    fprintf(stderr,"ERROR: no \"%s\" support.\n",tmpstr);
-  }
-  return 0;
-}
-
-
diff --git a/proc/slab.c b/slab.c
similarity index 81%
rename from proc/slab.c
rename to slab.c
index d53b327d..5f3901ff 100644
--- a/proc/slab.c
+++ b/slab.c
@@ -1,4 +1,4 @@
-/* 
+/*
  * slab.c - slab related functions for libproc
  *
  * Chris Rivera <cmrivera@ufl.edu>
@@ -51,7 +51,7 @@ static struct slab_info *get_slabnode(void)
 
 /*
  * slab_badname_detect - return true if current slab was declared with
- *                       whitespaces for instance 
+ *                       whitespaces for instance
  *			 FIXME :Other cases ?
  */
 
@@ -61,9 +61,9 @@ static int slab_badname_detect(const char *restrict buffer)
 	while (*buffer){
 		if((*buffer)==' ')
 			numberarea=1;
-		if(isalpha(*buffer)&&numberarea)	
+		if(isalpha(*buffer)&&numberarea)
 			return 1;
-		buffer++;	
+		buffer++;
 	}
 	return 0;
 }
@@ -89,35 +89,36 @@ void free_slabinfo(struct slab_info *list)
 	}
 }
 
-// parse_slabinfo20 - actual parse routine for slabinfo 2.x (2.6 kernels)
-// Note: difference between 2.0 and 2.1 is in the ": globalstat" part where version 2.1 
-// has extra column <nodeallocs>. We don't use ": globalstat" part in both versions.
-//
-// Formats (we don't use "statistics" extensions)
-//
-//  slabinfo - version: 2.1
-//  # name            <active_objs> <num_objs> <objsize> <objperslab> <pagesperslab> \
-//  : tunables <batchcount> <limit> <sharedfactor> \
-//  : slabdata <active_slabs> <num_slabs> <sharedavail>
-//
-//  slabinfo - version: 2.1 (statistics)
-//  # name            <active_objs> <num_objs> <objsize> <objperslab> <pagesperslab> \
-//  : tunables <batchcount> <limit> <sharedfactor> \
-//  : slabdata <active_slabs> <num_slabs> <sharedavail> \
-//  : globalstat <listallocs> <maxobjs> <grown> <reaped> <error> <maxfreeable> <freelimit> <nodeallocs> \
-//  : cpustat <allochit> <allocmiss> <freehit> <freemiss>
-//             
-//  slabinfo - version: 2.0
-//  # name            <active_objs> <num_objs> <objsize> <objperslab> <pagesperslab> \
-//  : tunables <batchcount> <limit> <sharedfactor> \
-//  : slabdata <active_slabs> <num_slabs> <sharedavail>
-//
-//  slabinfo - version: 2.0 (statistics)
-//  # name            <active_objs> <num_objs> <objsize> <objperslab> <pagesperslab> \
-//  : tunables <batchcount> <limit> <sharedfactor> \
-//  : slabdata <active_slabs> <num_slabs> <sharedavail> \
-//  : globalstat <listallocs> <maxobjs> <grown> <reaped> <error> <maxfreeable> <freelimit> \
-//  : cpustat <allochit> <allocmiss> <freehit> <freemiss>
+/* parse_slabinfo20 - actual parse routine for slabinfo 2.x (2.6 kernels)
+   Note: difference between 2.0 and 2.1 is in the ": globalstat" part where version 2.1
+   has extra column <nodeallocs>. We don't use ": globalstat" part in both versions.
+
+   Formats (we don't use "statistics" extensions)
+
+    slabinfo - version: 2.1
+    # name            <active_objs> <num_objs> <objsize> <objperslab> <pagesperslab> \
+    : tunables <batchcount> <limit> <sharedfactor> \
+    : slabdata <active_slabs> <num_slabs> <sharedavail>
+
+    slabinfo - version: 2.1 (statistics)
+    # name            <active_objs> <num_objs> <objsize> <objperslab> <pagesperslab> \
+    : tunables <batchcount> <limit> <sharedfactor> \
+    : slabdata <active_slabs> <num_slabs> <sharedavail> \
+    : globalstat <listallocs> <maxobjs> <grown> <reaped> <error> <maxfreeable> <freelimit> <nodeallocs> \
+    : cpustat <allochit> <allocmiss> <freehit> <freemiss>
+
+    slabinfo - version: 2.0
+    # name            <active_objs> <num_objs> <objsize> <objperslab> <pagesperslab> \
+    : tunables <batchcount> <limit> <sharedfactor> \
+    : slabdata <active_slabs> <num_slabs> <sharedavail>
+
+    slabinfo - version: 2.0 (statistics)
+    # name            <active_objs> <num_objs> <objsize> <objperslab> <pagesperslab> \
+    : tunables <batchcount> <limit> <sharedfactor> \
+    : slabdata <active_slabs> <num_slabs> <sharedavail> \
+    : globalstat <listallocs> <maxobjs> <grown> <reaped> <error> <maxfreeable> <freelimit> \
+    : cpustat <allochit> <allocmiss> <freehit> <freemiss>
+*/
 static int parse_slabinfo20(struct slab_info **list, struct slab_stat *stats,
 				FILE *f)
 {
@@ -134,7 +135,7 @@ static int parse_slabinfo20(struct slab_info **list, struct slab_stat *stats,
 
 		if (buffer[0] == '#')
 			continue;
-	
+
 		curr = get_slabnode();
 		if (!curr)
 			break;
@@ -146,8 +147,8 @@ static int parse_slabinfo20(struct slab_info **list, struct slab_stat *stats,
 
 		assigned = sscanf(buffer, "%" STRINGIFY(SLAB_INFO_NAME_LEN)
 				"s %d %d %d %d %d : tunables %*d %*d %*d : \
-				slabdata %d %d %*d", curr->name, 
-				&curr->nr_active_objs, &curr->nr_objs, 
+				slabdata %d %d %*d", curr->name,
+				&curr->nr_active_objs, &curr->nr_objs,
 				&curr->obj_size, &curr->objs_per_slab,
 				&curr->pages_per_slab, &curr->nr_active_slabs,
 				&curr->nr_slabs);
@@ -231,7 +232,7 @@ static int parse_slabinfo11(struct slab_info **list, struct slab_stat *stats,
 		if (assigned < 6) {
 			fprintf(stderr, "unrecognizable data in  your slabinfo version 1.1\n\r");
 			if(slab_badname_detect(buffer))
-				fprintf(stderr, "Found an error in cache name at line %s\n", buffer); 
+				fprintf(stderr, "Found an error in cache name at line %s\n", buffer);
 			curr = NULL;
 			break;
 		}
@@ -251,7 +252,7 @@ static int parse_slabinfo11(struct slab_info **list, struct slab_stat *stats,
 
 		if (curr->obj_size)
 			curr->objs_per_slab = curr->pages_per_slab *
-					page_size / curr->obj_size;		
+					page_size / curr->obj_size;
 
 		stats->nr_objs += curr->nr_objs;
 		stats->nr_active_objs += curr->nr_active_objs;
@@ -312,13 +313,11 @@ int get_slabinfo(struct slab_info **list, struct slab_stat *stats)
 
 	if (!fgets(buffer, SLABINFO_VER_LEN, slabfile)) {
 		fprintf(stderr, "cannot read from slabinfo\n");
-		free(slabfile);
 		return 1;
 	}
 
 	if (sscanf(buffer, "slabinfo - version: %d.%d", &major, &minor) != 2) {
 		fprintf(stderr, "not the good old slabinfo we know\n");
-		free(slabfile);
 		return 1;
 	}
 
@@ -330,7 +329,6 @@ int get_slabinfo(struct slab_info **list, struct slab_stat *stats)
 		ret = parse_slabinfo10(list, stats, slabfile);
 	else {
 		fprintf(stderr, "unrecognizable slabinfo version\n");
-		free(slabfile);
 		return 1;
 	}
 
diff --git a/proc/slab.h b/slab.h
similarity index 100%
rename from proc/slab.h
rename to slab.h
diff --git a/slabtop.1 b/slabtop.1
deleted file mode 100644
index 08d8ec5e..00000000
--- a/slabtop.1
+++ /dev/null
@@ -1,127 +0,0 @@
-.\" slabtop.1 - manpage for the slabtop(1) utility, part of procps-ng
-.\"
-.\" Copyright (C) 2003 Chris Rivera
-.\" Licensed under the terms of the GNU Library General Public License, v2
-.TH SLABTOP 1 "13 Sep 2003" "Linux" "Linux User's Manual"
-.SH NAME
-slabtop \- display kernel slab cache information in real time
-
-.SH SYNOPSIS
-.B slabtop
-.RI [ options ]
-
-.SH DESCRIPTION
-.B slabtop
-displays detailed kernel slab cache information in real time.  It displays a
-listing of the top caches sorted by one of the listed sort criteria.  It also
-displays a statistics header filled with slab layer information.
-
-.SH OPTIONS
-Normal invocation of 
-.B slabtop
-does not require any options.  The behavior, however, can be fine-tuned by
-specifying one or more of the following flags:
-.TP
-.B \-\-delay=\fIn\fR, \fB\-d \fIn
-Refresh the display every
-.I n
-in seconds.  By default,
-.B slabtop
-refreshes the display every three seconds.  To exit the program, hit
-.BR q.
-.TP
-.B \-\-sort=\fIS\fR, \fB\-s\fR \fIS
-Sort by \fIS\fR, where \fIS\fR is one of the sort criteria.
-.TP
-.B \-\-once\fR, \fB\-o
-Display the output once and then exit.
-.TP
-.B \-\-version\fR, \fB\-V
-Display version information and exit.
-.TP
-.B \-\-help
-Display usage information and exit.
-
-.SH SORT CRITERIA
-The following are valid sort criteria used to sort the individual slab caches
-and thereby determine what are the "top" slab caches to display.  The default
-sort criteria is to sort by the number of objects ("o").
-
-The sort criteria can also be changed while slabtop is running by pressing
-the associated character.
-.TP
-.BR a: 
-sort by number of active objects
-.TP
-.BR b: 
-sort by objects per slab
-.TP
-.BR c: 
-sort by cache size
-.TP
-.BR l: 
-sort by number of slabs
-.TP
-.BR v
-sort by number of active slabs
-.TP
-.BR n: 
-sort by name
-.TP
-.BR o: 
-sort by number of objects
-.TP
-.BR p: 
-sort by pages per slab
-.TP
-.BR s: 
-sort by object size
-.TP
-.BR u: 
-sort by cache utilization
-
-.SH COMMANDS
-.B slabtop
-accepts keyboard commands from the user during use.  The following are
-supported.  In the case of letters, both cases are accepted.
-
-Each of the valid sort characters are also accepted, to change the sort
-routine. See the section
-.IR "SORT CRITERIA" .
-
-.TP
-.BR <SPACEBAR>
-Refresh the screen.
-.TP
-.BR Q
-Quit the program.
-
-.SH FILES
-.TP
-.I /proc/slabinfo
-slab information
-
-.SH "SEE ALSO"
-.BR free (1),
-.BR ps (1),
-.BR top (1),
-.BR vmstat (8)
-
-.SH NOTES
-Currently,
-.B slabtop
-requires a 2.4 or later kernel (specifically, a version 1.1 or later
-.IR /proc/slabinfo ).
-Kernel 2.2 should be supported in the future.
-
-The slabtop statistic header is tracking how many bytes of slabs are being used
-and it not a measure of physical memory. The 'Slab' field in the /proc/meminfo
-file is tracking information about used slab physical memory.
-
-.SH AUTHORS
-Written by Chris Rivera and Robert Love.
-
-.B slabtop
-was inspired by Martin Bligh's perl script,
-.BR vmtop .
-Please send bug reports to <procps@freelists.org>.
diff --git a/slabtop.c b/slabtop.c
deleted file mode 100644
index 36025e2f..00000000
--- a/slabtop.c
+++ /dev/null
@@ -1,397 +0,0 @@
-/* 
- * slabtop.c - utility to display kernel slab information.
- *
- * Chris Rivera <cmrivera@ufl.edu>
- * Robert Love <rml@tech9.net>
- *
- * This program is licensed under the GNU Library General Public License, v2
- *
- * Copyright (C) 2003 Chris Rivera
- */
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-#include <errno.h>
-#include <signal.h>
-#include <ncurses.h>
-#include <termios.h>
-#include <getopt.h>
-#include <ctype.h>
-#include <sys/ioctl.h>
-
-#include <sys/select.h>
-#include <sys/time.h>
-#include <sys/types.h>
-#include <unistd.h>
-
-#include "proc/slab.h"
-#include "proc/version.h"
-
-#define DEF_SORT_FUNC		sort_nr_objs
-#define SLAB_STAT_ZERO		{ nr_objs: 0 }
-
-static unsigned short cols, rows;
-static struct termios saved_tty;
-static long delay = 3;
-static int (*sort_func)(const struct slab_info *, const struct slab_info *);
-
-static struct slab_info *merge_objs(struct slab_info *a, struct slab_info *b)
-{
-	struct slab_info sorted_list;
-	struct slab_info *curr = &sorted_list;
-
-	while ((a != NULL) && (b != NULL)) {
-		if (sort_func(a, b)) {
-			curr->next = a;
-			curr = a;
-			a = a->next;
-		} else {
-			curr->next = b;
-			curr = b;
-			b = b->next;
-		}
-	}
-
-	curr->next = (a == NULL) ? b : a;
-	return sorted_list.next;
-}
-
-/* 
- * slabsort - merge sort the slab_info linked list based on sort_func
- */
-static struct slab_info *slabsort(struct slab_info *list)
-{
-	struct slab_info *a, *b;
-
-	if ((list == NULL) || (list->next == NULL))
-		return list;
-
-	a = list;
-	b = list->next;
-
-	while ((b != NULL) && (b->next != NULL)) {
-		list = list->next;
-		b = b->next->next;
-	}
-	
-	b = list->next;
-	list->next = NULL;
-
-	return merge_objs(slabsort(a), slabsort(b));
-}
-
-/*
- * Sort Routines.  Each of these should be associated with a command-line
- * search option.  The functions should fit the prototype:
- *
- *	int sort_foo(const struct slab_info *a, const struct slab_info *b)
- *
- * They return one if the first parameter is larger than the second
- * Otherwise, they return zero.
- */
-
-static int sort_name(const struct slab_info *a, const struct slab_info *b)
-{
-	return (strcmp(a->name, b->name) < 0) ? 1 : 0;
-}
-
-static int sort_nr_objs(const struct slab_info *a, const struct slab_info *b)
-{
-	return (a->nr_objs > b->nr_objs);
-}
-
-static int sort_nr_active_objs(const struct slab_info *a,
-				const struct slab_info *b)
-{
-	return (a->nr_active_objs > b->nr_active_objs);
-}
-
-static int sort_obj_size(const struct slab_info *a, const struct slab_info *b)
-{
-	return (a->obj_size > b->obj_size);
-}
-
-static int sort_objs_per_slab(const struct slab_info *a,
-				const struct slab_info *b)
-{
-	return (a->objs_per_slab > b->objs_per_slab);
-}
-
-static int sort_pages_per_slab(const struct slab_info *a,
-		const struct slab_info *b)
-{
-	return (a->pages_per_slab > b->pages_per_slab);
-}
-
-static int sort_nr_slabs(const struct slab_info *a, const struct slab_info *b)
-{
-	return (a->nr_slabs > b->nr_slabs);
-}
-
-static int sort_nr_active_slabs(const struct slab_info *a,
-			const struct slab_info *b)
-{
-	return (a->nr_active_slabs > b->nr_active_slabs);
-}
-
-
-static int sort_use(const struct slab_info *a, const struct slab_info *b)
-{
-	return (a->use > b->use);
-}
-
-static int sort_cache_size(const struct slab_info *a, const struct slab_info *b)
-{
-	return (a->cache_size > b->cache_size);
-}
-
-/*
- * term_size - set the globals 'cols' and 'rows' to the current terminal size
- */
-static void term_size(int unused)
-{
-	struct winsize ws;
-	(void) unused;
-
-	if ((ioctl(1, TIOCGWINSZ, &ws) != -1) && ws.ws_row > 10) {
-		cols = ws.ws_col;
-		rows = ws.ws_row;
-	} else {
-		cols = 80;
-		rows = 24;
-	}
-}
-
-static void sigint_handler(int unused)
-{
-	(void) unused;
-
-	delay = 0;
-}
-
-static void usage(const char *cmd)
-{
-	fprintf(stderr, "usage: %s [options]\n\n", cmd);
-	fprintf(stderr, "options:\n");
-	fprintf(stderr, "  --delay=n, -d n    "
-		"delay n seconds between updates\n");
-	fprintf(stderr, "  --once, -o         "
-		"only display once, then exit\n");
-	fprintf(stderr, "  --sort=S, -s S     "
-		"specify sort criteria S (see below)\n");
-	fprintf(stderr, "  --version, -V      "
-		"display version information and exit\n");
-	fprintf(stderr, "  --help             display this help and exit\n\n");
-	fprintf(stderr, "The following are valid sort criteria:\n");
-	fprintf(stderr, "  a: sort by number of active objects\n");
-	fprintf(stderr, "  b: sort by objects per slab\n");
-	fprintf(stderr, "  c: sort by cache size\n");
-	fprintf(stderr, "  l: sort by number of slabs\n");
-	fprintf(stderr, "  v: sort by number of active slabs\n");
-	fprintf(stderr, "  n: sort by name\n");
-	fprintf(stderr, "  o: sort by number of objects\n");
-	fprintf(stderr, "  p: sort by pages per slab\n");
-	fprintf(stderr, "  s: sort by object size\n");
-	fprintf(stderr, "  u: sort by cache utilization\n");
-}
-
-/*
- * set_sort_func - return the slab_sort_func that matches the given key.
- * On unrecognizable key, DEF_SORT_FUNC is returned.
- */
-static void * set_sort_func(char key)
-{
-	switch (key) {
-	case 'n':
-		return sort_name;
-	case 'o':
-		return sort_nr_objs;
-	case 'a':
-		return sort_nr_active_objs;
-	case 's':
-		return sort_obj_size;
-	case 'b':
-		return sort_objs_per_slab;
-	case 'p':
-		return sort_pages_per_slab;
-	case 'l':
-		return sort_nr_slabs;
-	case 'v':
-		return sort_nr_active_slabs;
-	case 'c':
-		return sort_cache_size;
-	case 'u':
-		return sort_use;
-	default:
-		return DEF_SORT_FUNC;
-	}
-}
-
-static void parse_input(char c)
-{
-	c = toupper(c);
-	switch(c) {
-	case 'A':
-		sort_func = sort_nr_active_objs;
-		break;
-	case 'B':
-		sort_func = sort_objs_per_slab;
-		break;
-	case 'C':
-		sort_func = sort_cache_size;
-		break;
-	case 'L':
-		sort_func = sort_nr_slabs;
-		break;
-	case 'V':
-		sort_func = sort_nr_active_slabs;
-		break;
-	case 'N':
-		sort_func = sort_name;
-		break;
-	case 'O':
-		sort_func = sort_nr_objs;
-		break;
-	case 'P':
-		sort_func = sort_pages_per_slab;
-		break;
-	case 'S':
-		sort_func = sort_obj_size;
-		break;
-	case 'U':
-		sort_func = sort_use;
-		break;
-	case 'Q':
-		delay = 0;
-		break;
-	}
-}
-
-int main(int argc, char *argv[])
-{
-	int o;
-	unsigned short old_rows;
-	struct slab_info *slab_list = NULL;
-
-	struct option longopts[] = {
-		{ "delay",	1, NULL, 'd' },
-		{ "sort",	1, NULL, 's' },
-		{ "once",	0, NULL, 'o' },
-		{ "help",	0, NULL, 'h' },
-		{ "version",	0, NULL, 'V' },
-		{  NULL,	0, NULL, 0 }
-	};
-
-	sort_func = DEF_SORT_FUNC;
-
-	while ((o = getopt_long(argc, argv, "d:s:ohV", longopts, NULL)) != -1) {
-		int ret = 1;
-
-		switch (o) {
-		case 'd':
-			errno = 0;
-			delay = strtol(optarg, NULL, 10);
-			if (errno) {
-				perror("strtoul");
-				return 1;
-			}
-			if (delay < 0) {
-				fprintf(stderr, "error: can't have a "\
-					"negative delay\n");
-				exit(1);
-			}
-			break;
-		case 's':
-			sort_func = set_sort_func(optarg[0]);
-			break;
-		case 'o':
-			delay = 0;
-			break;
-		case 'V':
-			display_version();
-			return 0;
-		case 'h':
-			ret = 0;
-		default:
-			usage(argv[0]);
-			return ret;
-		}
-	}
-
-	if (tcgetattr(0, &saved_tty) == -1)
-		perror("tcgetattr");
-
-	initscr();
-	term_size(0);
-	old_rows = rows;
-	resizeterm(rows, cols);
-	signal(SIGWINCH, term_size);
-	signal(SIGINT, sigint_handler);
-
-	do {
-		struct slab_info *curr;
-		struct slab_stat stats = SLAB_STAT_ZERO;
-		struct timeval tv;
-		fd_set readfds;
-		char c;
-		int i;
-
-		if (get_slabinfo(&slab_list, &stats))
-			break;
-
-		if (old_rows != rows) {
-			resizeterm(rows, cols);
-			old_rows = rows;
-		}
-
-		move(0,0);
-		printw(	" Active / Total Objects (%% used)    : %d / %d (%.1f%%)\n"
-			" Active / Total Slabs (%% used)      : %d / %d (%.1f%%)\n"
-			" Active / Total Caches (%% used)     : %d / %d (%.1f%%)\n"
-			" Active / Total Size (%% used)       : %.2fK / %.2fK (%.1f%%)\n"
-			" Minimum / Average / Maximum Object : %.2fK / %.2fK / %.2fK\n\n",
-			stats.nr_active_objs, stats.nr_objs, 100.0 * stats.nr_active_objs / stats.nr_objs,
-			stats.nr_active_slabs, stats.nr_slabs, 100.0 * stats.nr_active_slabs / stats.nr_slabs,
-			stats.nr_active_caches, stats.nr_caches, 100.0 * stats.nr_active_caches / stats.nr_caches,
-			stats.active_size / 1024.0, stats.total_size / 1024.0, 100.0 * stats.active_size / stats.total_size,
-			stats.min_obj_size / 1024.0, stats.avg_obj_size / 1024.0, stats.max_obj_size / 1024.0
-		);
-
-		slab_list = slabsort(slab_list);
-
-		attron(A_REVERSE);
-		printw(	"%6s %6s %4s %8s %6s %8s %10s %-23s\n",
-			"OBJS", "ACTIVE", "USE", "OBJ SIZE", "SLABS",
-			"OBJ/SLAB", "CACHE SIZE", "NAME");
-		attroff(A_REVERSE);
-
-		curr = slab_list;
-		for (i = 0; i < rows - 8 && curr->next; i++) {
-			printw("%6u %6u %3u%% %7.2fK %6u %8u %9uK %-23s\n",
-				curr->nr_objs, curr->nr_active_objs, curr->use,
-				curr->obj_size / 1024.0, curr->nr_slabs,
-				curr->objs_per_slab, (unsigned)(curr->cache_size / 1024),
-				curr->name);
-			curr = curr->next;
-		}
-
-		refresh();
-		put_slabinfo(slab_list);
-
-		FD_ZERO(&readfds);
-		FD_SET(0, &readfds);
-		tv.tv_sec = delay;
-		tv.tv_usec = 0;
-		if (select(1, &readfds, NULL, NULL, &tv) > 0) {
-			if (read(0, &c, 1) != 1)
-				break;
-			parse_input(c);
-		}
-	} while (delay);
-
-	tcsetattr(0, TCSAFLUSH, &saved_tty);
-	free_slabinfo(slab_list);
-	endwin();
-	return 0;
-}
diff --git a/smaps.c b/smaps.c
new file mode 100644
index 00000000..17789a16
--- /dev/null
+++ b/smaps.c
@@ -0,0 +1,171 @@
+#if 0
+#include "procps.h"
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include "procps.h"
+
+struct smap_entry {
+	unsigned KLONG start;
+	unsigned KLONG beyond;
+	long long offset;
+	char flags[8];
+	unsigned dev_major;
+	unsigned dev_minor;
+	unsigned long long inode;
+
+	unsigned long rss;
+	unsigned long pss;
+	unsigned long sclean;
+	unsigned long sdirty;
+	unsigned long pclean;
+	unsigned long pdirty;
+	unsigned long ref;
+	unsigned long swap;
+};
+
+
+////////////////////////////////////////////////////////////////////////////////
+// This code will surely make normal programmers cry. I need speed though,
+// and /proc/*/smaps should make anybody cry. (WTF kind of brain damage...?)
+
+struct smap_summary {
+	unsigned long size;
+	unsigned long rss;
+	unsigned long pss;
+	unsigned long sclean;
+	unsigned long sdirty;
+	unsigned long pclean;
+	unsigned long pdirty;
+	unsigned long ref;
+	unsigned long swap;
+};
+
+struct ssjt {
+	char str[16];
+	int len;
+	int offset;
+};
+
+#define JTE(o,x) {#x,sizeof(#x)-1,o}
+
+void get_smap_sums(struct smap_summary *restrict ss, const char *restrict const filename){
+	static struct ssjt table[] = {
+		JTE(-1,default),
+		JTE( 1,Rss),
+		JTE(-1,default),
+		JTE( 2,Pss),
+		JTE( 8,Swap),
+		JTE( 5,Private_Clean),
+		JTE( 6,Private_Dirty),
+		JTE(-1,default),
+		JTE( 7,Referenced),
+		JTE(-1,default),
+		JTE( 0,Size),
+		JTE(-1,default),
+		JTE(-1,default),
+		JTE(-1,default),
+		JTE(-1,default),
+		JTE(-1,default), // KernelPageSize would go here
+		JTE(-1,default),
+		JTE(-1,default),
+		JTE( 4,Shared_Dirty),
+		JTE(-1,default),
+		JTE(-1,default),
+		JTE(-1,default),
+		JTE(-1,default),
+		JTE( 3,Shared_Clean),
+		JTE(-1,default),
+		JTE(-1,default),
+		JTE(-1,default),
+		JTE(-1,default),
+		JTE(-1,default),
+		JTE(-1,default),
+		JTE(-1,default),
+		JTE(-1,default),
+	};
+	char buf[20480];
+	int p1 = 0;
+	int p2 = 0;
+	memset(ss,0,sizeof *ss);
+	int fd = open(filename,O_RDONLY);
+	if(fd==-1)
+		return;
+	for(;;){
+		char *nlp = memchr(buf+p1,'\n',p2-p1);
+		if(!nlp){
+			if(p1){
+				// the memmove should never do anything, because the
+				// kernel seems to give us the greatest number of
+				// complete lines of text that fit in a single page
+				// (and thus p2-p1 is zero)
+				memmove(buf,buf+p1,p2-p1);
+				p2 -= p1;
+				p1 = 0;
+			}
+			ssize_t rb = read(fd,buf+p1,sizeof buf - p1);
+			if(rb < 1)
+				break;
+			p2 += rb;
+			nlp = memchr(buf+p1,'\n',p2-p1);
+			if(!nlp)
+				break;
+		}
+		char *s = buf+p1;
+		int len = nlp-s;
+		p1 += len+1;
+		if(len<27)
+			continue;
+//printf("j      <%13.13s>\n",s);
+		if(s[0]<'A' || s[0]>'Z')
+			continue;
+		unsigned hash = ( (s[8]&15) + (s[1]&15) ) ^ (s[0]&3);
+		hash &= 31;
+//printf("x   %2d <%13.13s>\n",hash,s);
+		if(s[table[hash].len] != ':')
+			continue;
+//printf("y   %2d <%13.13s>\n",hash,s);
+		if(memcmp(table[hash].str,s,table[hash].len))
+			continue;
+//printf("z   %2d <%13.13s>\n",hash,s);
+		s += table[hash].len;
+		while(*++s==' ')
+			;
+		unsigned long ul = 0;
+		for(;;){
+			char c = *s++;
+			if(c != ' '){
+				ul *= 10;
+				ul += c-'0';
+				continue;
+			}
+			break;
+		}
+//		if(table[hash].offset == 2)
+//			printf("Pss:%20lu kB\n",ul);
+		unsigned long *ulp = &ss->size + table[hash].offset;
+		*ulp += ul;
+//		memcpy(ss+table[hash].offset*sizeof(unsigned long), &ul, sizeof(unsigned long));
+	}
+	close(fd);
+}
+
+int main(int argc, char *argv[]){
+	struct smap_summary ss;
+	get_smap_sums(&ss, argv[1]);
+	printf("%9lu\n",ss.size);
+	printf("%9lu\n",ss.rss);
+	printf("%9lu\n",ss.pss);
+	printf("%9lu\n",ss.sclean);
+	printf("%9lu\n",ss.sdirty);
+	printf("%9lu\n",ss.pclean);
+	printf("%9lu\n",ss.pdirty);
+	printf("%9lu\n",ss.ref);
+	printf("%9lu\n",ss.swap);
+	return 0;
+}
+#endif
diff --git a/snice.1 b/snice.1
deleted file mode 100644
index 1595a808..00000000
--- a/snice.1
+++ /dev/null
@@ -1 +0,0 @@
-.so man1/skill.1
diff --git a/sysctl.8 b/sysctl.8
deleted file mode 100644
index 3bb46d74..00000000
--- a/sysctl.8
+++ /dev/null
@@ -1,117 +0,0 @@
-.\" Copyright 1999, George Staikos (staikos@0wned.org)
-.\" This file may be used subject to the terms and conditions of the
-.\" GNU General Public License Version 2, or any later version
-.\" at your option, as published by the Free Software Foundation.
-.\" This program is distributed in the hope that it will be useful,
-.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
-.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-.\" GNU General Public License for more details."
-.TH SYSCTL 8 "21 Sep 1999" "" ""
-.SH NAME
-sysctl \- configure kernel parameters at runtime
-.SH SYNOPSIS
-.B sysctl
-.RB [ \-n ]
-.RB [ \-e ]
-.I variable
-\&...
-.br
-.B sysctl
-.RB [ \-n ]
-.RB [ \-e ]
-.RB [ \-q ]
-.B \-w
-.IR variable = value
-\&...
-.br
-.B sysctl
-.RB [ \-n ]
-.RB [ \-e ]
-.RB [ \-q ]
-.B \-p
-.RI [ filename ]
-.br
-.B sysctl
-.RB [ \-n ]
-.RB [ \-e ]
-.B \-a
-.br
-.B sysctl
-.RB [ \-n ]
-.RB [ \-e ]
-.B \-A
-.SH DESCRIPTION
-.B sysctl
-is used to modify kernel parameters at runtime.  The parameters available
-are those listed under /proc/sys/.  Procfs is required for 
-.B sysctl
-support in Linux.  You can use
-.B sysctl
-to both read and write sysctl data.
-.SH PARAMETERS
-.TP
-.I variable
-The name of a key to read from.  An example is kernel.ostype.  The '/'
-separator is also accepted in place of a '.'.
-.TP
-.IR  variable = value
-To set a key, use the form
-.IR  variable = value
-where
-.I variable
-is the key and
-.I value
-is the value to set it to.  If the value contains quotes or characters
-which are parsed by the shell, you may need to enclose the value in double
-quotes.  This requires the
-.B \-w
-parameter to use.
-.TP
-.B \-n
-Use this option to disable printing of the key name when printing values.
-.TP
-.B \-e
-Use this option to ignore errors about unknown keys.
-.TP
-.B \-N
-Use this option to only print the names. It may be useful with shells that
-have programmable completion.
-.TP
-.B \-q
-Use this option to not display the values set to stdout.
-.TP
-.B \-w
-Use this option when you want to change a sysctl setting.
-.TP
-.B \-p
-Load in sysctl settings from the file specified or /etc/sysctl.conf if none given.
-Specifying \- as filename means reading data from standard input.
-.TP
-.B \-a
-Display all values currently available.
-.TP
-.B \-A
-Display all values currently available in table form.
-.SH EXAMPLES
-/sbin/sysctl \-a
-.br
-/sbin/sysctl \-n kernel.hostname
-.br
-/sbin/sysctl \-w kernel.domainname="example.com"
-.br
-/sbin/sysctl \-p /etc/sysctl.conf
-.SH FILES
-.I /proc/sys
-.br
-.I /etc/sysctl.conf
-.SH SEE ALSO
-.BR sysctl.conf (5)
-.SH BUGS
-The
-.B \-A
-parameter behaves just as
-.B \-a
-does.
-.SH AUTHOR
-George Staikos, <staikos@0wned.org>
-
diff --git a/sysctl.c b/sysctl.c
deleted file mode 100644
index 57d3e9aa..00000000
--- a/sysctl.c
+++ /dev/null
@@ -1,559 +0,0 @@
-
-/*
- * Sysctl 1.01 - A utility to read and manipulate the sysctl parameters
- *
- *
- * "Copyright 1999 George Staikos
- * This file may be used subject to the terms and conditions of the
- * GNU General Public License Version 2, or any later version
- * at your option, as published by the Free Software Foundation.
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details."
- *
- * Changelog:
- *            v1.01:
- *                   - added -p <preload> to preload values from a file
- *            Horms: 
- *                   - added -q to be quiet when modifying values
- *
- * Changes by Albert Cahalan, 2002.
- */
-
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-#include <dirent.h>
-#include <string.h>
-#include <errno.h>
-#include <libgen.h>
-#include "proc/procps.h"
-#include "proc/version.h"
-
-
-// Proof that C++ causes brain damage:
-typedef int bool;
-static bool true  = 1;
-static bool false = 0;
-
-/*
- *    Globals...
- */
-
-static const char PROC_PATH[] = "/proc/sys/";
-static const char DEFAULT_PRELOAD[] = "/etc/sysctl.conf";
-static bool NameOnly;
-static bool PrintName;
-static bool PrintNewline;
-static bool IgnoreError;
-static bool Quiet;
-
-/* error messages */
-static const char ERR_UNKNOWN_PARAMETER[] = "error: Unknown parameter \"%s\"\n";
-static const char ERR_MALFORMED_SETTING[] = "error: Malformed setting \"%s\"\n";
-static const char ERR_NO_EQUALS[] = "error: \"%s\" must be of the form name=value\n";
-static const char ERR_INVALID_KEY[] = "error: \"%s\" is an unknown key\n";
-static const char ERR_UNKNOWN_WRITING[] = "error: \"%s\" setting key \"%s\"\n";
-static const char ERR_UNKNOWN_READING[] = "error: \"%s\" reading key \"%s\"\n";
-static const char ERR_PERMISSION_DENIED[] = "error: permission denied on key '%s'\n";
-static const char ERR_OPENING_DIR[] = "error: unable to open directory \"%s\"\n";
-static const char ERR_PRELOAD_FILE[] = "error: unable to open preload file \"%s\"\n";
-static const char WARN_BAD_LINE[] = "warning: %s(%d): invalid syntax, continuing...\n";
-
-
-static void slashdot(char *restrict p, char old, char new){
-  p = strpbrk(p,"/.");
-  if(!p) return;            /* nothing -- can't be, but oh well */
-  if(*p==new) return;       /* already in desired format */
-  while(p){
-    char c = *p;
-    if(c==old) *p=new;
-    if(c==new) *p=old;
-    p = strpbrk(p+1,"/.");
-  }
-}
-
-
-
-/*
- *     Display the usage format
- *
- */
-static int Usage(const char *restrict const name) {
-   printf("usage:  %s [-n] [-e] variable ... \n"
-          "        %s [-n] [-e] [-q] -w variable=value ... \n" 
-          "        %s [-n] [-e] -a \n" 
-          "        %s [-n] [-e] [-q] -p <file>   (default /etc/sysctl.conf) \n"
-          "        %s [-n] [-e] -A\n", name, name, name, name, name);
-   return -1;
-}
-
-
-/*
- *     Strip the leading and trailing spaces from a string
- *
- */
-static char *StripLeadingAndTrailingSpaces(char *oneline) {
-   char *t;
-
-   if (!oneline || !*oneline)
-      return oneline;
-
-   t = oneline;
-   t += strlen(oneline)-1;
-
-   while ((*t==' ' || *t=='\t' || *t=='\n' || *t=='\r') && t!=oneline)
-      *t-- = 0;
-
-   t = oneline;
-
-   while ((*t==' ' || *t=='\t') && *t!=0)
-      t++;
-
-   return t;
-}
-
-static int DisplayAll(const char *restrict const path);
-
-/*
- *     Read a sysctl setting 
- *
- */
-static int ReadSetting(const char *restrict const name) {
-   int rc = 0;
-   char *restrict tmpname;
-   char *restrict outname;
-   char inbuf[1025];
-   FILE *restrict fp;
-   struct stat ts;
-
-   if (!name || !*name) {
-      fprintf(stderr, ERR_INVALID_KEY, name);
-      return -1;
-   }
-
-   /* used to open the file */
-   tmpname = malloc(strlen(name)+strlen(PROC_PATH)+2);
-   strcpy(tmpname, PROC_PATH);
-   strcat(tmpname, name); 
-   slashdot(tmpname+strlen(PROC_PATH),'.','/'); /* change . to / */
-
-   /* used to display the output */
-   outname = strdup(name);
-   slashdot(outname,'/','.'); /* change / to . */
-
-   if (stat(tmpname, &ts) < 0) {
-      if (!IgnoreError) {
-         perror(tmpname);
-         rc = -1;
-      }
-      goto out;
-   }
-   if ((ts.st_mode & S_IRUSR) == 0)
-      goto out;
-
-   if (S_ISDIR(ts.st_mode)) {
-      size_t len;
-      len = strlen(tmpname);
-      tmpname[len] = '/';
-      tmpname[len+1] = '\0';
-      rc = DisplayAll(tmpname);
-      goto out;
-   }
-
-   fp = fopen(tmpname, "r");
-
-   if (!fp) {
-      switch(errno) {
-      case ENOENT:
-         if (!IgnoreError) {
-            fprintf(stderr, ERR_INVALID_KEY, outname);
-            rc = -1;
-         }
-         break;
-      case EACCES:
-         fprintf(stderr, ERR_PERMISSION_DENIED, outname);
-         rc = -1;
-         break;
-      default:
-         fprintf(stderr, ERR_UNKNOWN_READING, strerror(errno), outname);
-         rc = -1;
-         break;
-      }
-   } else {
-      errno = 0;
-      if(fgets(inbuf, sizeof inbuf - 1, fp)) {
-         // this loop is required, see
-         // /sbin/sysctl -a | egrep -6 dev.cdrom.info
-         do {
-            if (NameOnly) {
-               fprintf(stdout, "%s\n", outname);
-            } else {
-               /* already has the \n in it */
-               if (PrintName) {
-                  fprintf(stdout, "%s = %s", outname, inbuf);
-               } else {
-                  if (!PrintNewline) {
-                    char *nlptr = strchr(inbuf,'\n');
-                    if(nlptr) *nlptr='\0';
-                  }
-                  fprintf(stdout, "%s", inbuf);
-               }
-            }
-         } while(fgets(inbuf, sizeof inbuf - 1, fp));
-      } else {
-         switch(errno) {
-         case EACCES:
-            fprintf(stderr, ERR_PERMISSION_DENIED, outname);
-            rc = -1;
-            break;
-         case EISDIR:{
-            size_t len;
-            len = strlen(tmpname);
-            tmpname[len] = '/';
-            tmpname[len+1] = '\0';
-            fclose(fp);
-            rc = DisplayAll(tmpname);
-            goto out;
-         }
-         default:
-            fprintf(stderr, ERR_UNKNOWN_READING, strerror(errno), outname);
-            rc = -1;
-         case 0:
-            break;
-         }
-      }
-      fclose(fp);
-   }
-out:
-   free(tmpname);
-   free(outname);
-   return rc;
-}
-
-
-
-/*
- *     Display all the sysctl settings 
- *
- */
-static int DisplayAll(const char *restrict const path) {
-   int rc = 0;
-   int rc2;
-   DIR *restrict dp;
-   struct dirent *restrict de;
-   struct stat ts;
-
-   dp = opendir(path);
-
-   if (!dp) {
-      fprintf(stderr, ERR_OPENING_DIR, path);
-      rc = -1;
-   } else {
-      readdir(dp);  // skip .
-      readdir(dp);  // skip ..
-      while (( de = readdir(dp) )) {
-         char *restrict tmpdir;
-         tmpdir = (char *restrict)malloc(strlen(path)+strlen(de->d_name)+2);
-         sprintf(tmpdir, "%s%s", path, de->d_name);
-         rc2 = stat(tmpdir, &ts);
-         if (rc2 != 0) {
-            perror(tmpdir);
-         } else {
-            if (S_ISDIR(ts.st_mode)) {
-               strcat(tmpdir, "/");
-               DisplayAll(tmpdir);
-            } else {
-               rc |= ReadSetting(tmpdir+strlen(PROC_PATH));
-            }
-         }
-         free(tmpdir);
-      }
-      closedir(dp);
-   }
-   return rc;
-}
-
-
-/*
- *     Write a sysctl setting 
- *
- */
-static int WriteSetting(const char *setting) {
-   int rc = 0;
-   const char *name = setting;
-   const char *value;
-   const char *equals;
-   char *tmpname;
-   char *outname;
-   FILE *fp;
-   struct stat ts;
-
-   if (!name) {        /* probably don't want to display this err */
-      return 0;
-   } /* end if */
-
-   equals = index(setting, '=');
- 
-   if (!equals) {
-      fprintf(stderr, ERR_NO_EQUALS, setting);
-      return -1;
-   }
-
-   value = equals + 1;      /* point to the value in name=value */   
-
-   if (!*name || !*value || name == equals) { 
-      fprintf(stderr, ERR_MALFORMED_SETTING, setting);
-      return -2;
-   }
-
-   /* used to open the file */
-   tmpname = malloc(equals-name+1+strlen(PROC_PATH));
-   strcpy(tmpname, PROC_PATH);
-   strncat(tmpname, name, (int)(equals-name)); 
-   tmpname[equals-name+strlen(PROC_PATH)] = 0;
-   slashdot(tmpname+strlen(PROC_PATH),'.','/'); /* change . to / */
-
-   /* used to display the output */
-   outname = malloc(equals-name+1);                       
-   strncpy(outname, name, (int)(equals-name)); 
-   outname[equals-name] = 0;
-   slashdot(outname,'/','.'); /* change / to . */
- 
-   if (stat(tmpname, &ts) < 0) {
-      if (!IgnoreError) {
-         perror(tmpname);
-         rc = -1;
-      }
-      goto out;
-   }
-
-   if ((ts.st_mode & S_IWUSR) == 0) {
-      fprintf(stderr, ERR_UNKNOWN_WRITING, strerror(EACCES), outname);
-      goto out;
-   }
-
-   if (S_ISDIR(ts.st_mode)) {
-      fprintf(stderr, ERR_UNKNOWN_WRITING, strerror(EACCES), outname);
-      goto out;
-   }
-
-   fp = fopen(tmpname, "w");
-
-   if (!fp) {
-      switch(errno) {
-      case ENOENT:
-         if (!IgnoreError) {
-            fprintf(stderr, ERR_INVALID_KEY, outname);
-            rc = -1;
-         }
-         break;
-      case EACCES:
-         fprintf(stderr, ERR_PERMISSION_DENIED, outname);
-         rc = -1;
-         break;
-      default:
-         fprintf(stderr, ERR_UNKNOWN_WRITING, strerror(errno), outname);
-         rc = -1;
-         break;
-      }
-   } else {
-      rc = fprintf(fp, "%s\n", value);
-      if (rc < 0) {
-         fprintf(stderr, ERR_UNKNOWN_WRITING, strerror(errno), outname);
-         fclose(fp);
-      } else {
-         rc=fclose(fp);
-         if (rc != 0) 
-            fprintf(stderr, ERR_UNKNOWN_WRITING, strerror(errno), outname);
-      }
-      if (rc==0 && !Quiet) {
-         if (NameOnly) {
-            fprintf(stdout, "%s\n", outname);
-         } else {
-            if (PrintName) {
-               fprintf(stdout, "%s = %s\n", outname, value);
-            } else {
-               if (PrintNewline)
-                  fprintf(stdout, "%s\n", value);
-               else
-                  fprintf(stdout, "%s", value);
-            }
-         }
-      }
-   }
-out:
-   free(tmpname);
-   free(outname);
-   return rc;
-}
-
-
-
-/*
- *     Preload the sysctl's from the conf file
- *           - we parse the file and then reform it (strip out whitespace)
- *
- */
-static int Preload(const char *restrict const filename) {
-   char oneline[256];
-   char buffer[256];
-   FILE *fp;
-   char *t;
-   int n = 0;
-   int rc = 0;
-   char *name, *value;
-
-   fp = (filename[0]=='-' && !filename[1])
-      ? stdin
-      : fopen(filename, "r")
-   ;
-
-   if (!fp) {
-      fprintf(stderr, ERR_PRELOAD_FILE, filename);
-      return -1;
-   }
-
-   while (fgets(oneline, sizeof oneline, fp)) {
-      n++;
-      t = StripLeadingAndTrailingSpaces(oneline);
-
-      if (strlen(t) < 2)
-         continue;
-
-      if (*t == '#' || *t == ';')
-         continue;
-
-      name = strtok(t, "=");
-      if (!name || !*name) {
-         fprintf(stderr, WARN_BAD_LINE, filename, n);
-         continue;
-      }
-
-      StripLeadingAndTrailingSpaces(name);
-
-      value = strtok(NULL, "\n\r");
-      if (!value || !*value) {
-         fprintf(stderr, WARN_BAD_LINE, filename, n);
-         continue;
-      }
-
-      while ((*value == ' ' || *value == '\t') && *value != 0)
-         value++;
-
-      // should NameOnly affect this?
-      sprintf(buffer, "%s=%s", name, value);
-      rc |= WriteSetting(buffer);
-   }
-
-   fclose(fp);
-   return rc;
-}
-
-
-
-/*
- *    Main... 
- *
- */
-int main(int argc, char *argv[]) {
-   const char *me = (const char *)basename(argv[0]);
-   bool SwitchesAllowed = true;
-   bool WriteMode = false;
-   int ReturnCode = 0;
-   const char *preloadfile = DEFAULT_PRELOAD;
-
-   PrintName = true;
-   PrintNewline = true;
-   IgnoreError = false;
-   Quiet = false;
-
-   if (argc < 2) {
-       return Usage(me);
-   }
-
-   argv++;
-
-   for (; argv && *argv && **argv; argv++) {
-      if (SwitchesAllowed && **argv == '-') {        /* we have a switch */
-         if ((*argv)[1] && (*argv)[2]){       // don't yet handle "sysctl -ew"
-              if (!strcmp("--help",*argv)) {
-                 Usage(me);
-                 exit(0);
-              }
-              if (!strcmp("--version",*argv)) {
-                 fprintf(stdout, "sysctl (%s)\n",procps_version);
-                 exit(0);
-              }
-              fprintf(stderr, ERR_UNKNOWN_PARAMETER, *argv);
-              return Usage(me);
-         }
-         switch((*argv)[1]) {
-         case 'b':
-              /* This is "binary" format, which means more for BSD. */
-              PrintNewline = false;
-           /* FALL THROUGH */
-         case 'n':
-              PrintName = false;
-           break;
-         case 'e':
-              // For FreeBSD, -e means a "%s=%s\n" format. ("%s: %s\n" default)
-              // We (and NetBSD) use "%s = %s\n" always, and -e to ignore errors.
-              IgnoreError = true;
-           break;
-         case 'N':
-              NameOnly = true;
-           break;
-         case 'w':
-              SwitchesAllowed = false;
-              WriteMode = true;
-           break;
-         case 'f':  // the NetBSD way
-         case 'p':
-              argv++;
-              if (argv && *argv && **argv) {
-                 preloadfile = *argv;
-              }
-              return Preload(preloadfile);
-	 case 'q':
-	      Quiet = true;
-	   break;
-	 case 'o':  // BSD: binary values too, 1st 16 bytes in hex
-	 case 'x':  // BSD: binary values too, whole thing in hex
-	      /* does nothing */ ;
-	   break;
-         case 'a': // string and integer values (for Linux, all of them)
-         case 'A': // same as -a -o
-         case 'X': // same as -a -x
-              SwitchesAllowed = false;
-              return DisplayAll(PROC_PATH);
-         case 'V':
-              fprintf(stdout, "sysctl (%s)\n",procps_version);
-              exit(0);
-         case 'd':   // BSD: print description ("vm.kvm_size: Size of KVM")
-         case 'h':   // BSD: human-readable (did FreeBSD 5 make -e default?)
-         case '?':
-              return Usage(me);
-         default:
-              fprintf(stderr, ERR_UNKNOWN_PARAMETER, *argv);
-              return Usage(me);
-         }
-      } else {
-         if (NameOnly && Quiet)   // nonsense
-            return Usage(me);
-         SwitchesAllowed = false;
-         if (WriteMode || index(*argv, '='))
-            ReturnCode = WriteSetting(*argv);
-         else
-            ReturnCode = ReadSetting(*argv);
-      }
-   }
-
-   return ReturnCode;
-}
-
-
diff --git a/sysctl.conf b/sysctl.conf
deleted file mode 100644
index 720294f0..00000000
--- a/sysctl.conf
+++ /dev/null
@@ -1,60 +0,0 @@
-# /etc/sysctl.conf - Configuration file for setting system variables
-# See sysctl.conf (5) for information.
-
-# you can have the CD-ROM close when you use it, and open
-# when you are done.
-#dev.cdrom.autoeject = 1
-#dev.cdrom.autoclose = 1
-
-# protection from the SYN flood attack
-net/ipv4/tcp_syncookies=1
-
-# see the evil packets in your log files
-net/ipv4/conf/all/log_martians=1
-
-# makes you vulnerable or not :-)
-net/ipv4/conf/all/accept_redirects=0
-net/ipv4/conf/all/accept_source_route=0
-net/ipv4/icmp_echo_ignore_broadcasts =1
-
-# needed for routing, including masquerading or NAT
-#net/ipv4/ip_forward=1
-
-# sets the port range used for outgoing connections
-#net.ipv4.ip_local_port_range = 32768    61000
-
-# Broken routers and obsolete firewalls will corrupt the window scaling
-# and ECN. Set these values to 0 to disable window scaling and ECN.
-# This may, rarely, cause some performance loss when running high-speed
-# TCP/IP over huge distances or running TCP/IP over connections with high
-# packet loss and modern routers. This sure beats dropped connections.
-#net.ipv4.tcp_default_win_scale = 0
-#net.ipv4.tcp_ecn = 0
-
-# Swapping too much or not enough? Disks spinning up when you'd
-# rather they didn't? Tweak these.
-#vm.vfs_cache_pressure = 100
-#vm.laptop_mode = 0
-#vm.swappiness = 60
-
-#kernel.printk_ratelimit_burst = 10
-#kernel.printk_ratelimit = 5
-#kernel.panic_on_oops = 0
-
-# Reboot 600 seconds after a panic
-#kernel.panic = 600
-
-# enable SysRq key (note: console security issues)
-#kernel.sysrq = 1
-
-# Change name of core file to start with the command name
-# so you get things like: emacs.core mozilla-bin.core X.core
-#kernel.core_pattern = %e.core
-
-# NIS/YP domain (not always equal to DNS domain)
-#kernel.domainname = example.com
-#kernel.hostname = darkstar
-
-# This limits PID values to 4 digits, which allows tools like ps
-# to save screen space.
-kernel/pid_max=10000
diff --git a/sysctl.conf.5 b/sysctl.conf.5
deleted file mode 100644
index 0d8b0731..00000000
--- a/sysctl.conf.5
+++ /dev/null
@@ -1,51 +0,0 @@
-.\" Copyright 1999, George Staikos (staikos@0wned.org)
-.\" This file may be used subject to the terms and conditions of the
-.\" GNU General Public License Version 2, or any later version
-.\" at your option, as published by the Free Software Foundation.
-.\" This program is distributed in the hope that it will be useful,
-.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
-.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-.\" GNU General Public License for more details."
-.TH SYSCTL.CONF 5 "21 Sep 1999" "" ""
-.SH NAME
-sysctl.conf \- sysctl(8) preload/configuration file 
-.SH DESCRIPTION
-.I sysctl.conf
-is a simple file containing sysctl values to be read in and set by sysctl(8).
-The syntax is simply as follows:
-.RS
-.sp
-.nf
-.ne 7
-# comment
-; comment
-
-  token  =   value
-.fi
-.sp
-.RE
-.PP
-Note that blank lines are ignored, and whitespace before and after a token or
-value is ignored, although a value can contain whitespace within.  Lines which
-begin with a # or ; are considered comments and ignored.
-.SH EXAMPLE
-.RS
-.sp
-.nf
-.ne 7
-# sysctl.conf sample
-#
-
-  kernel.domainname = example.com
-; this one has a space which will be written to the sysctl!
-  kernel.modprobe = /sbin/mod probe
-
-.fi
-.sp
-.RE
-.PP
-.SH SEE ALSO
-.BR sysctl(8)
-.SH AUTHOR
-George Staikos, <staikos@0wned.org>
-
diff --git a/proc/sysinfo.c b/sysinfo.c
similarity index 91%
rename from proc/sysinfo.c
rename to sysinfo.c
index 3fe70da0..3a86691a 100644
--- a/proc/sysinfo.c
+++ b/sysinfo.c
@@ -90,35 +90,6 @@ int uptime(double *restrict uptime_secs, double *restrict idle_secs) {
     return up;	/* assume never be zero seconds in practice */
 }
 
-unsigned long getbtime(void) {
-    static unsigned long btime = 0;
-    FILE *f;
-
-    if (btime)
-	return btime;
-
-    /* /proc/stat can get very large on multi-CPU systems so we
-       can't use FILE_TO_BUF */
-    if (!(f = fopen(STAT_FILE, "r"))) {
-	fputs(BAD_OPEN_MESSAGE, stderr);
-	fflush(NULL);
-	_exit(102);
-    }
-
-    while ((fgets(buf, sizeof buf, f))) {
-        if (sscanf(buf, "btime %lu", &btime) == 1)
-            break;
-    }
-    fclose(f);
-
-    if (!btime) {
-	fputs("missing btime in " STAT_FILE "\n", stderr);
-	exit(1);
-    }
-
-    return btime;
-}
-
 /***********************************************************************
  * Some values in /proc are expressed in units of 1/HZ seconds, where HZ
  * is the kernel clock tick rate. One of these units is called a jiffy.
@@ -153,33 +124,24 @@ unsigned long getbtime(void) {
 unsigned long long Hertz;
 
 static void old_Hertz_hack(void){
-  unsigned long long user_j, nice_j, sys_j, other_j, wait_j, hirq_j, sirq_j, stol_j;  /* jiffies (clock ticks) */
+  unsigned long long user_j, nice_j, sys_j, other_j;  /* jiffies (clock ticks) */
   double up_1, up_2, seconds;
   unsigned long long jiffies;
   unsigned h;
   char *restrict savelocale;
-  long hz;
 
-#ifdef _SC_CLK_TCK
-  if((hz = sysconf(_SC_CLK_TCK)) > 0){
-    Hertz = hz;
-    return;
-  }
-#endif
-
-  wait_j = hirq_j = sirq_j = stol_j = 0;
   savelocale = setlocale(LC_NUMERIC, NULL);
   setlocale(LC_NUMERIC, "C");
   do{
     FILE_TO_BUF(UPTIME_FILE,uptime_fd);  sscanf(buf, "%lf", &up_1);
     /* uptime(&up_1, NULL); */
     FILE_TO_BUF(STAT_FILE,stat_fd);
-    sscanf(buf, "cpu %Lu %Lu %Lu %Lu %Lu %Lu %Lu %Lu", &user_j, &nice_j, &sys_j, &other_j, &wait_j, &hirq_j, &sirq_j, &stol_j);
+    sscanf(buf, "cpu %Lu %Lu %Lu %Lu", &user_j, &nice_j, &sys_j, &other_j);
     FILE_TO_BUF(UPTIME_FILE,uptime_fd);  sscanf(buf, "%lf", &up_2);
     /* uptime(&up_2, NULL); */
   } while((long long)( (up_2-up_1)*1000.0/up_1 )); /* want under 0.1% error */
   setlocale(LC_NUMERIC, savelocale);
-  jiffies = user_j + nice_j + sys_j + other_j + wait_j + hirq_j + sirq_j + stol_j ;
+  jiffies = user_j + nice_j + sys_j + other_j;
   seconds = (up_1 + up_2) / 2;
   h = (unsigned)( (double)jiffies/seconds/smp_num_cpus );
   /* actual values used by 2.4 kernels: 32 64 100 128 1000 1024 1200 */
@@ -207,7 +169,7 @@ static void old_Hertz_hack(void){
     /* If 32-bit or big-endian (not Alpha or ia64), assume HZ is 100. */
     Hertz = (sizeof(long)==sizeof(int) || htons(999)==999) ? 100UL : 1024UL;
 #endif
-    fprintf(stderr, "Unknown HZ value! (%d) Assume %Ld.\n", h, Hertz);
+   // fprintf(stderr, "Unknown HZ value! (%d) Assume %Ld.\n", h, Hertz);
   }
 }
 
@@ -247,28 +209,24 @@ static int check_for_privs(void){
   return !!rc;
 }
 
-static void init_libproc(void) __attribute__((constructor));
+static void init_libproc(void) __attribute__((constructor(103)));
 static void init_libproc(void){
   have_privs = check_for_privs();
-  init_Linux_version(); /* Must be called before we check code */
-
-  cpuinfo();
+  // ought to count CPUs in /proc/stat instead of relying
+  // on glibc, which foolishly tries to parse /proc/cpuinfo
+  //
+  // SourceForge has an old Alpha running Linux 2.2.20 that
+  // appears to have a non-SMP kernel on a 2-way SMP box.
+  // _SC_NPROCESSORS_CONF returns 2, resulting in HZ=512
+  // _SC_NPROCESSORS_ONLN returns 1, which should work OK
+  smp_num_cpus = sysconf(_SC_NPROCESSORS_ONLN);
+  if(smp_num_cpus<1) smp_num_cpus=1; /* SPARC glibc is buggy */
 
-#ifdef __linux__
-  if(linux_version_code > LINUX_VERSION(2, 4, 0)){ 
+  if(linux_version_code > LINUX_VERSION(2, 4, 0)){
     Hertz = find_elf_note(AT_CLKTCK);
     if(Hertz!=NOTE_NOT_FOUND) return;
     fputs("2.4+ kernel w/o ELF notes? -- report this\n", stderr);
   }
-#endif /* __linux __ */
-#if defined(__FreeBSD_kernel__) || defined(__FreeBSD__)
-  /* On FreeBSD the Hertz hack is unrelaible, there is no ELF note and
-   * Hertz isn't defined in asm/params.h
-   * See Debian Bug #460331
-   */
-  Hertz = 100;
-  return;
-#endif /* __FreeBSD__ */
   old_Hertz_hack();
 }
 
@@ -298,7 +256,7 @@ void eight_cpu_numbers(double *restrict uret, double *restrict nret, double *res
     new_y = 0;
     tmp_z = 0.0;
     new_z = 0;
- 
+
     FILE_TO_BUF(STAT_FILE,stat_fd);
     sscanf(buf, "cpu %Lu %Lu %Lu %Lu %Lu %Lu %Lu %Lu", &new_u, &new_n, &new_s, &new_i, &new_w, &new_x, &new_y, &new_z);
     ticks_past = (new_u+new_n+new_s+new_i+new_w+new_x+new_y+new_z)-(old_u+old_n+old_s+old_i+old_w+old_x+old_y+old_z);
@@ -346,7 +304,7 @@ void eight_cpu_numbers(double *restrict uret, double *restrict nret, double *res
 void loadavg(double *restrict av1, double *restrict av5, double *restrict av15) {
     double avg_1=0, avg_5=0, avg_15=0;
     char *restrict savelocale;
-    
+
     FILE_TO_BUF(LOADAVG_FILE,loadavg_fd);
     savelocale = setlocale(LC_NUMERIC, NULL);
     setlocale(LC_NUMERIC, "C");
@@ -391,7 +349,11 @@ static void getrunners(unsigned int *restrict running, unsigned int *restrict bl
     fd = open(tbuf, O_RDONLY, 0);
     if (fd == -1) continue;
     memset(tbuf, '\0', sizeof tbuf); // didn't feel like checking read()
-    read(fd, tbuf, sizeof tbuf - 1); // need 32 byte buffer at most
+    if (read(fd, tbuf, sizeof tbuf - 1) < 0) { // need 32 byte buffer at most
+        perror(tbuf);
+        fflush(NULL);
+        _exit(103);
+    }
     close(fd);
 
     cp = strrchr(tbuf, ')');
@@ -430,8 +392,12 @@ void getstat(jiff *restrict cuse, jiff *restrict cice, jiff *restrict csys, jiff
     fd = open("/proc/stat", O_RDONLY, 0);
     if(fd == -1) crash("/proc/stat");
   }
-  read(fd,buff,BUFFSIZE-1);
-  *intr = 0; 
+  if (read(fd,buff,BUFFSIZE-1) < 0) {
+      perror("/proc/stat");
+      fflush(NULL);
+      _exit(103);
+  }
+  *intr = 0;
   *ciow = 0;  /* not separated out until the 2.5.41 kernel */
   *cxxx = 0;  /* not separated out until the 2.6.0-test4 kernel */
   *cyyy = 0;  /* not separated out until the 2.6.0-test4 kernel */
@@ -703,21 +669,21 @@ unsigned long vm_pageoutrun;  // times kswapd ran page reclaim
 unsigned long vm_allocstall; // times a page allocator ran direct reclaim
 unsigned long vm_pgrotated; // pages rotated to the tail of the LRU for immediate reclaim
 // seen on a 2.6.8-rc1 kernel, apparently replacing old fields
-static unsigned long vm_pgalloc_dma;          // 
-static unsigned long vm_pgalloc_high;         // 
-static unsigned long vm_pgalloc_normal;       // 
-static unsigned long vm_pgrefill_dma;         // 
-static unsigned long vm_pgrefill_high;        // 
-static unsigned long vm_pgrefill_normal;      // 
-static unsigned long vm_pgscan_direct_dma;    // 
-static unsigned long vm_pgscan_direct_high;   // 
-static unsigned long vm_pgscan_direct_normal; // 
-static unsigned long vm_pgscan_kswapd_dma;    // 
-static unsigned long vm_pgscan_kswapd_high;   // 
-static unsigned long vm_pgscan_kswapd_normal; // 
-static unsigned long vm_pgsteal_dma;          // 
-static unsigned long vm_pgsteal_high;         // 
-static unsigned long vm_pgsteal_normal;       // 
+static unsigned long vm_pgalloc_dma;          //
+static unsigned long vm_pgalloc_high;         //
+static unsigned long vm_pgalloc_normal;       //
+static unsigned long vm_pgrefill_dma;         //
+static unsigned long vm_pgrefill_high;        //
+static unsigned long vm_pgrefill_normal;      //
+static unsigned long vm_pgscan_direct_dma;    //
+static unsigned long vm_pgscan_direct_high;   //
+static unsigned long vm_pgscan_direct_normal; //
+static unsigned long vm_pgscan_kswapd_dma;    //
+static unsigned long vm_pgscan_kswapd_high;   //
+static unsigned long vm_pgscan_kswapd_normal; //
+static unsigned long vm_pgsteal_dma;          //
+static unsigned long vm_pgsteal_high;         //
+static unsigned long vm_pgsteal_normal;       //
 // seen on a 2.6.8-rc1 kernel
 static unsigned long vm_kswapd_inodesteal;    //
 static unsigned long vm_nr_unstable;          //
@@ -846,7 +812,7 @@ unsigned int getdiskstat(struct disk_stat **disks, struct partition_stat **parti
 
   *disks = NULL;
   *partitions = NULL;
-  buff[BUFFSIZE-1] = 0; 
+  buff[BUFFSIZE-1] = 0;
   fd = fopen("/proc/diskstats", "rb");
   if(!fd) crash("/proc/diskstats");
 
@@ -856,8 +822,8 @@ unsigned int getdiskstat(struct disk_stat **disks, struct partition_stat **parti
       break;
     }
     fields = sscanf(buff, " %*d %*d %*s %*u %*u %*u %*u %*u %*u %*u %*u %*u %*u %u", &dummy);
-    (*disks) = realloc(*disks, (cDisk+1)*sizeof(struct disk_stat));
     if (fields == 1){
+      (*disks) = realloc(*disks, (cDisk+1)*sizeof(struct disk_stat));
       sscanf(buff,  "   %*d    %*d %15s %u %u %llu %u %u %u %llu %u %u %u %u",
         //&disk_major,
         //&disk_minor,
@@ -889,7 +855,7 @@ unsigned int getdiskstat(struct disk_stat **disks, struct partition_stat **parti
         &(*partitions)[cPartition].requested_writes
       );
       (*partitions)[cPartition++].parent_disk = cDisk-1;
-      (*disks)[cDisk-1].partitions++;	
+      (*disks)[cDisk-1].partitions++;
     }
   }
 
@@ -902,7 +868,7 @@ unsigned int getdiskstat(struct disk_stat **disks, struct partition_stat **parti
 unsigned int getslabinfo (struct slab_cache **slab){
   FILE* fd;
   int cSlab = 0;
-  buff[BUFFSIZE-1] = 0; 
+  buff[BUFFSIZE-1] = 0;
   *slab = NULL;
   fd = fopen("/proc/slabinfo", "rb");
   if(!fd) crash("/proc/slabinfo");
@@ -952,22 +918,3 @@ unsigned get_pid_digits(void){
 out:
   return ret;
 }
-
-///////////////////////////////////////////////////////////////////////////
-
-void cpuinfo (void) {
-  // ought to count CPUs in /proc/stat instead of relying
-  // on glibc, which foolishly tries to parse /proc/cpuinfo
-  // note: that may have been the case but now /proc/stat
-  //       is the default source.  parsing of /proc/cpuinfo
-  //       only occurs if the open on /proc/stat fails
-  //
-  // SourceForge has an old Alpha running Linux 2.2.20 that
-  // appears to have a non-SMP kernel on a 2-way SMP box.
-  // _SC_NPROCESSORS_CONF returns 2, resulting in HZ=512
-  // _SC_NPROCESSORS_ONLN returns 1, which should work OK
-
-  smp_num_cpus = sysconf(_SC_NPROCESSORS_ONLN);
-  if (smp_num_cpus<1)        /* SPARC glibc is buggy */
-    smp_num_cpus=1;
-}
diff --git a/proc/sysinfo.h b/sysinfo.h
similarity index 95%
rename from proc/sysinfo.h
rename to sysinfo.h
index 194cb2a6..e30a38b9 100644
--- a/proc/sysinfo.h
+++ b/sysinfo.h
@@ -7,8 +7,8 @@
 EXTERN_C_BEGIN
 
 extern unsigned long long Hertz;   /* clock tick frequency */
-extern long smp_num_cpus;          /* number of CPUs */
-extern int have_privs;             /* boolean, true if setuid or similar */
+extern long smp_num_cpus;     /* number of CPUs */
+extern int have_privs;     /* boolean, true if setuid or similar */
 
 #if 0
 #define JT double
@@ -17,7 +17,6 @@ extern void eight_cpu_numbers(JT *uret, JT *nret, JT *sret, JT *iret, JT *wret,
 #endif
 
 extern int        uptime (double *uptime_secs, double *idle_secs);
-extern unsigned long getbtime(void);
 extern void       loadavg(double *av1, double *av5, double *av15);
 
 
@@ -132,7 +131,5 @@ extern unsigned int getslabinfo (struct slab_cache**);
 
 extern unsigned get_pid_digits(void) FUNCTION;
 
-extern void cpuinfo (void);
-
 EXTERN_C_END
 #endif /* SYSINFO_H */
diff --git a/tload.1 b/tload.1
deleted file mode 100644
index 8ec8c430..00000000
--- a/tload.1
+++ /dev/null
@@ -1,50 +0,0 @@
-.\"             -*-Nroff-*-
-.\"  This page Copyright (C) 1993 Matt Welsh, mdw@tc.cornell.edu.
-.\"  Freely distributable under the terms of the GPL
-.TH TLOAD 1 "20 Mar 1993 " "Cohesive Systems" "Linux User's Manual"
-.SH NAME
-tload \- graphic representation of system load average
-.SH SYNOPSIS
-.B tload
-.RB [ "\-V" "] [" "\-s"
-.IR scale "] ["
-.BI "\-d" " delay"
-.RI "] [" tty ]
-.SH DESCRIPTION
-\fBtload\fP prints a graph of the current system load average to the 
-specified \fItty\fP (or the tty of the tload process if none is specified).
-.SS Options
-The
-.BI "\-s" " scale"
-option allows a vertical scale to be specified for the
-display (in characters between graph ticks); thus, a smaller value
-represents a larger scale, and vice versa.
-
-The
-.BI "\-d" " delay"
-sets the delay between graph updates in seconds.
-.PP
-.SH FILES
-.I /proc/loadavg
-load average information
-
-.SH "SEE ALSO"
-.BR ps (1),
-.BR top (1),
-.BR uptime (1),
-.BR w (1)
-
-.SH BUGS
-The
-.BI "\-d" " delay"
-option sets the time argument for an
-.BR alarm (2);
-if \-d 0 is specified, the alarm is set to 0, which will never send the
-.B SIGALRM
-and update the display.
-
-.SH AUTHORS
-Branko Lankester, David Engel <david@ods.com>, and 
-Michael K. Johnson <johnsonm@redhat.com>.
-
-Please send bug reports to <albert@users.sf.net>
diff --git a/tload.c b/tload.c
deleted file mode 100644
index 14c02166..00000000
--- a/tload.c
+++ /dev/null
@@ -1,156 +0,0 @@
-/*
- * tload.c	- terminal version of xload
- *
- * Options:
- *	-s initial scaling exponent (default = 6)
- *	-d delay
- *
- * Copyright (c) 1992 Branko Lankester
- * /proc changes by David Engel (david@ods.com)
- * Made a little more efficient by Michael K. Johnson (johnsonm@sunsite.unc.edu)
- */
-#include "proc/version.h"
-#include "proc/sysinfo.h"
-#include <stdio.h>
-#include <stdlib.h>
-#include <setjmp.h>
-#include <signal.h>
-#include <string.h>
-#include <unistd.h>
-#include <termios.h>
-#include <fcntl.h>
-#include <sys/ioctl.h>
-
-static char *screen;
-
-static int nrows = 25;
-static int ncols = 80;
-static int scr_size;
-static int fd=1;
-static int dly=5;
-static jmp_buf jb;
-
-extern int optind;
-extern char *optarg;
-
-static void alrm(int signo)
-{
-    (void)signo;
-    signal(SIGALRM, alrm);
-    alarm(dly);
-}
-
-static void setsize(int i)
-{
-    struct winsize win;
-
-    signal(SIGWINCH, setsize);
-    if (ioctl(fd, TIOCGWINSZ, &win) != -1) {
-	if (win.ws_col > 0)
-	    ncols = win.ws_col;
-	if (win.ws_row > 0)
-	    nrows = win.ws_row;
-    }
-    scr_size = nrows * ncols;
-    if (screen == NULL)
-    	screen = (char *) malloc(scr_size);
-    else
-    	screen = (char *) realloc(screen, scr_size);
-
-    if (screen == NULL) {
-	perror("");
-	exit(1);
-    }
-    memset(screen, ' ', scr_size-1);
-    *(screen + scr_size - 2) = '\0';
-    if (i)
-	longjmp(jb, 0);
-}
-
-int main(int argc, char **argv)
-{
-    int lines, row, col=0;
-    int i, opt;
-    double av[3];
-    static double max_scale, scale_fact;
-    char *scale_arg = NULL;
-
-    while ((opt = getopt(argc, argv, "s:d:V")) != -1)
-	switch (opt) {
-	    case 's': scale_arg = optarg; break;
-	    case 'd': dly = atoi(optarg); break;
-	    case 'V': display_version(); exit(0); break;
-	    default:
-		printf("usage: tload [-V] [-d delay] [-s scale] [tty]\n");
-		exit(1);
-	}
-
-    if (argc > optind) {
-	if ((fd = open(argv[optind], 1)) == -1) {
-	    perror("tty");
-	    exit(1);
-	}
-    }
-
-    setsize(0);
-
-    if (scale_arg)
-      max_scale = atof(scale_arg);
-    else
-      max_scale = nrows;
-
-    scale_fact = max_scale;
-
-    setjmp(jb);
-    col = 0;
-    alrm(0);
-
-    while (1) {
-
- 	if (scale_fact < max_scale)
-	    scale_fact *= 2.0; /* help it drift back up. */
-
-	loadavg(&av[0], &av[1], &av[2]);
-
-    repeat:
-	lines = av[0] * scale_fact;
-	row = nrows-1;
-
-	while (--lines >= 0) {
-	    *(screen + row * ncols + col) = '*';
-	    if (--row < 0) {
-		scale_fact /= 2.0;
-		goto repeat;
-	    }
-	}
-	while (row >= 0)
-	    *(screen + row-- * ncols + col) = ' ';
-
-	for (i = 1; ; ++i) {
-	    char *p;
-	    row = nrows - (i * scale_fact);
-	    if (row < 0)
-		break;
-	    if (*(p = screen + row * ncols + col) == ' ')
-		*p = '-';
-	    else
-		*p = '=';
-	}
-
-	if (++col == ncols) {
-	    --col;
-	    memmove(screen, screen + 1, scr_size-1);
-
-	    for(row = nrows-2; row >= 0; --row)
-		*(screen + row * ncols + col) = ' ';
-	}
-	i = sprintf(screen, " %.2f, %.2f, %.2f",
-		av[0], av[1], av[2]);
-	if (i>0)
-	    screen[i] = ' ';
-
-	write(fd, "\033[H", 3);
-	write(fd, screen, scr_size - 1);
-	pause();
-    }
-}
diff --git a/top.1 b/top.1
deleted file mode 100644
index 3f61a36d..00000000
--- a/top.1
+++ /dev/null
@@ -1,1977 +0,0 @@
-.ig
-. manual page for NEW and IMPROVED linux top
-.
-. Copyright (c) 2002-2011, by: James C. Warner
-.    All rights reserved.      8921 Hilloway Road
-.                              Eden Prairie, Minnesota 55347 USA
-.
-. Permission is granted to copy, distribute and/or modify this document
-. under the terms of the GNU Free Documentation License, Version 1.1 or
-. any later version published by the Free Software Foundation;
-. with no Front-Cover Texts, no Back-Cover Texts, and with the following
-. Invariant Sections (and any sub-sections therein):
-.   all .ig sections, including this one
-.   STUPID TRICKS Sampler
-.   AUTHOR
-.
-. A copy of the Free Documentation License is included in the section
-. entitled "GNU Free Documentation License".
-.
-. [ that section is found near the end of this document & ]
-. [ can be made printable by disabling the .ig directive! ]
-.
-..
-\#  Setup ////////////////////////////////////////////////////////////////
-\#  ** Comment out '.nr' or set to 0 to eliminate WIDTH fiddlin' !
-.nr half_xtra 4
-.
-.ll +(\n[half_xtra] + \n[half_xtra])
-.
-\#  ** we use single quote char (') alot, so change the no-break ctrl char
-.c2 `
-.
-\#                      Our own Bullet style(s) --------------------------
-.de jBu
-.IP "o" 3
-..
-.
-\#                      Commonly used strings (for consistency) ----------
-\#                           - our em-dashes
-.ds Em \fR\ \--\ \fR
-.ds EM \fB\ \--\ \fR
-\#                           - our program name (makes great grammer)
-.ds We top
-.ds WE \fBtop\fR
-\#                           - other misc strs for consistent usage
-.ds F \fIOff\fR
-.ds O \fIOn\fR
-.
-.ds AK asterisk (\'*\')
-.ds AM alternate\-display mode
-.ds AS auxiliary storage
-.ds CF configuration file
-.ds CG \'current\' window/field group
-.ds CI interactive command
-.ds CO command\-line option
-.ds CT command toggle
-.ds CW \'current\' window
-.ds FG field group
-.ds FM full\-screen mode
-.ds KA arrow key
-.ds KS scrolling key
-.ds MP physical memory
-.ds MS shared memory
-.ds MV virtual memory
-.ds NT \fBNote\fR:
-.ds PU CPU
-.ds Pu cpu
-.ds SA summary area
-.ds TA task area
-.ds TD task display
-.ds TT \fBprocesses\fR or \fBthreads\fR
-.ds TW task window
-\#                      Reference to the various widths/sizes ------------
-\#                           - the max screen width limit
-.ds WX 512
-\#                           - the header width w/ all fields
-.ds WF approximately 200
-\#                           - max room for the command column
-.ds WC 300+
-\#                           - pid monitoring limit
-.ds WP 20
-\#                      Xref's that depend on/mention other stuff --------
-.ds Xa see
-.ds XC See the
-.ds Xc see the
-.ds XT See topic
-.ds Xt see topic
-.
-.\" Document /////////////////////////////////////////////////////////////
-.\" ----------------------------------------------------------------------
-.TH TOP 1 "April 2011" "Linux" "Linux User's Manual"
-.\" ----------------------------------------------------------------------
-
-.\" ----------------------------------------------------------------------
-.SH NAME
-.\" ----------------------------------------------------------------------
-\*(We \- display Linux processes
-
-.\" ----------------------------------------------------------------------
-.SH SYNOPSIS
-.\" ----------------------------------------------------------------------
-\*(WE \-\fBhv\fR|\-\fBbcHisS\fR \-\fBd\fI delay\fR \-\fBn\fI limit\fR
-\-\fBu\fR|\fBU\fI user\fR \-\fBp\fI pid\fR \-\fBw\fR [\fIcols\fR] \fR
-
-The traditional switches '-' and whitespace are optional.
-
-
-.\" ----------------------------------------------------------------------
-.SH DESCRIPTION
-.\" ----------------------------------------------------------------------
-The \*(WE program provides a dynamic real-time view of a running system.
-It can display\fB system\fR summary information as well as a list of
-\*(TT currently being managed by the Linux kernel.
-The types of system summary information shown and the types, order and
-size of information displayed for processes are all user configurable
-and that configuration can be made persistent across restarts.
-
-The program provides a limited interactive interface for process
-manipulation as well as a much more extensive interface for personal
-configuration \*(Em encompassing every aspect of its operation.
-And while \*(WE is referred to throughout this document, you are free
-to name the program anything you wish.
-That new name, possibly an alias, will then be reflected on \*(We's
-display and used when reading and writing a \*(CF.
-
-
-.\" ----------------------------------------------------------------------
-.SH OVERVIEW
-.\" ----------------------------------------------------------------------
-.\" ......................................................................
-.SS Documentation
-.\" ----------------------------------------------------------------------
-The remaining Table of Contents
-
-.Bd -literal
-    1. COMMAND\-LINE Options
-    2. SUMMARY Display
-       a. UPTIME and LOAD Averages
-       b. TASK and CPU States
-       c. MEMORY Usage
-    3. FIELDS / Columns Display
-       a. DESCRIPTIONS of Fields
-       b. MANAGING Fields
-    4. INTERACTIVE Commands
-       a. GLOBAL Commands
-       b. SUMMARY AREA Commands
-       c. TASK AREA Commands
-       d. COLOR Mapping
-    5. ALTERNATE\-DISPLAY Provisions
-       a. WINDOWS Overview
-       b. COMMANDS for Windows
-       c. SCROLLING a Window
-    6. FILES
-       a. SYSTEM Configuration File
-       b. PERSONAL Configuration File
-    7. STUPID TRICKS Sampler
-       a. Kernel Magic
-       b. Bouncing Windows
-       c. The Big Bird Window
-    8. BUGS, 9. HISTORY Former top, 10. AUTHOR, 11. SEE Also
-.Ed
-
-.\" ......................................................................
-.SS Operation
-.\" ----------------------------------------------------------------------
-When operating \*(We, the two most important keys are the help ('h' or '?')
-key and quit ('q') key.
-Alternatively, you could simply use the traditional interrupt key ('^C')
-when you're done.
-
-Some of \*(We's screens or functions require the use of cursor motion
-keys like the standard \*(KAs plus the Home, End, PgUp and PgDn keys.
-If your terminal or emulator does not provide those keys, the following
-keys are accepted for compatibility:
-.Bd -literal -compact
-      \fI key      equivalents \fR
-       Up       alt +\fB \\ \fR  or   alt +\fB k \fR
-       Down     alt +\fB / \fR  or   alt +\fB j \fR
-       Left     alt +\fB < \fR  or   alt +\fB h \fR
-       Right    alt +\fB > \fR  or   alt +\fB l \fR (lower case L)
-       PgUp     alt +\fB Up \fR
-       PgDn     alt +\fB Down \fR
-       Home     alt +\fB Left \fR
-       End      alt +\fB Right \fR
-.Ed
-
-When you start \*(We for the first time, you'll be presented with these
-traditional screen elements: 1) Summary Area; 2) Fields/Columns Header;
-3) Task Area.
-These areas will be explored in the sections that follow.
-There is also an Input/Message line between the Summary Area and Columns
-Header which needs no further explanation.
-
-\*(NT the width of \*(We's display will be limited to \*(WX positions.
-Displaying all fields requires \*(WF characters.
-Remaining screen width is usually allocated to any variable width columns
-currently visible.
-The variable width columns, such as COMMAND, are noted in topic
-3a. DESCRIPTIONS of Fields.
-Actual output width may also be influenced by the -w switch, which is
-discussed in topic 1. COMMAND\-LINE Options.
-
-.\" ......................................................................
-.SS Startup Defaults
-.\" ----------------------------------------------------------------------
-The following startup defaults assume no \*(CF, thus no user customizations.
-Even so, items shown with an \*(AK could be overridden through the
-command-line.
-All are explained in detail in the sections that follow.
-
-.Bd -literal
-    \fIGlobal-defaults\fR
-       'A' - Alt display      Off (full-screen)
-     * 'd' - Delay time       3.0 seconds
-     * 'H' - Threads mode     Off (summarize as tasks)
-       'I' - Irix mode        On\ \ (no, 'solaris' smp)
-     * 'p' - PID monitoring   Off (show all processes)
-     * 's' - Secure mode      Off (unsecured)
-       'B' - Bold enable      On\ \ (yes, bold globally)
-    \fISummary-Area-defaults\fR
-       'l' - Load Avg/Uptime  On\ \ (thus program name)
-       't' - Task/Cpu states  On\ \ (1+1 lines, see '1')
-       'm' - Mem/Swap usage   On\ \ (2 lines worth)
-       '1' - Single Cpu       On\ \ (thus 1 line if smp)
-    \fITask-Area-defaults\fR
-       'b' - Bold hilite      On\ \ (not 'reverse')
-     * 'c' - Command line     Off (name, not cmdline)
-     * 'i' - Idle tasks       On\ \ (show all tasks)
-       'R' - Reverse sort     On\ \ (pids high-to-low)
-     * 'S' - Cumulative time  Off (no, dead children)
-     * 'u' - User filter      Off (show euid only)
-     * 'U' - User filter      Off (show any uid)
-       'x' - Column hilite    Off (no, sort field)
-       'y' - Row hilite       On\ \ (yes, running tasks)
-       'z' - color/mono       Off (no, colors)
-.Ed
-
-
-.\" ----------------------------------------------------------------------
-.SH 1. COMMAND-LINE Options
-.\" ----------------------------------------------------------------------
-The command-line syntax for \*(We consists of:
-
-  \-\fBhv\fR | \-\fBbcHisS\fR \-\fBd\fI delay\fR \-\fBn\fI limit\fR
-\-\fBu\fR|\fBU\fI user\fR | \-\fBp\fI pid\fR \-\fBw\fR [\fIcols\fR] \fR
-
-The typically mandatory switches ('-') and even whitespace are completely
-optional.
-
-.TP 5
-\-\fBh\fR | \-\fBv\fR :\fI Help/Version \fR
-Show library version and the usage prompt, then quit.
-
-.TP 5
-\-\fBb\fR :\fI Batch-mode\fR operation \fR
-Starts \*(We in 'Batch' mode, which could be useful for sending output
-from \*(We to other programs or to a file.
-In this mode, \*(We will not accept input and runs until the iterations
-limit you've set with the '-n' \*(CO or until killed.
-
-.TP 5
-\-\fBc\fR :\fI Command-line/Program-name\fR toggle \fR
-Starts \*(We with the last remembered 'c' state reversed.
-Thus, if \*(We was displaying command lines, now that field will show program
-names, and visa versa.
-\*(XC 'c' \*(CI for additional information.
-
-.TP 5
-\-\fBd\fR :\fI Delay-time\fR interval as:\ \ \fB-d ss.tt\fR (\fIsecs\fR.\fItenths\fR) \fR
-Specifies the delay between screen updates, and overrides the corresponding
-value in one's personal \*(CF or the startup default.
-Later this can be changed with the 'd' or 's' \*(CIs.
-
-Fractional seconds are honored, but a negative number is not allowed.
-In all cases, however, such changes are prohibited if \*(We is running
-in 'Secure mode', except for root (unless the 's' \*(CO was used).
-For additional information on 'Secure mode' \*(Xt 6a. SYSTEM Configuration File.
-
-.TP 5
-\-\fBH\fR :\fI Threads-mode\fR operation \fR
-Instructs \*(We to display individual threads.
-Without this \*(CO a summation of all threads in each process is shown.
-Later this can be changed with the 'H' \*(CI.
-
-.TP 5
-\-\fBi\fR :\fI Idle-process\fR toggle \fR
-Starts \*(We with the last remembered 'i' state reversed.
-When this toggle is \*F, tasks that have not used any \*(PU since the
-last update will not be displayed.
-For additional information regarding this toggle
-\*(Xt 4c. TASK AREA Commands, SIZE.
-
-.TP 5
-\-\fBn\fR :\fI Number-of-iterations\fR limit as:\fB\ \ -n number \fR
-Specifies the maximum number of iterations, or frames, \*(We should
-produce before ending.
-
-.TP 5
-\-\fBp\fR :\fI Monitor-PIDs\fR mode as:\fB\ \ -pN1 -pN2 ...\fR\ \ or\fB\ \ -pN1,N2,N3 ... \fR
-Monitor only processes with specified process IDs.
-This option can be given up to \*(WP times, or you can provide a comma delimited
-list with up to \*(WP pids.
-Co-mingling both approaches is permitted.
-
-This is a \*(CO only and should you wish to return to normal operation,
-it is not necessary to quit and and restart \*(We \*(Em just issue any
-of these \*(CIs: '=', 'u' or 'U'.
-
-The 'p', 'u' and 'U' \*(COs are mutually exclusive.
-
-.TP 5
-\-\fBs\fR :\fI Secure-mode\fR operation \fR
-Starts \*(We with secure mode forced, even for root.
-This mode is far better controlled through the system \*(CF
-(\*(Xt 6. FILES).
-
-.TP 5
-\-\fBS\fR :\fI Cumulative-time\fR toggle \fR
-Starts \*(We with the last remembered 'S' state reversed.
-When 'Cumulative time' mode is \*O, each process is listed with the \*(Pu
-time that it and its dead children have used.
-\*(XC 'S' \*(CI for additional information regarding this mode.
-
-.TP 5
-\-\fBu\fR | \-\fBU\fR :\fI User-filter-mode\fR as:\ \ \fB-u\fR | \fB-U number\fR or\fB name \fR
-Display only processes with a user id or user name matching that given.
-The '-u' option matches on \fI effective\fR user whereas the '-U' option
-matches on\fI any\fR user (real, effective, saved, or filesystem).
-
-The 'p', 'u' and 'U' \*(COs are mutually exclusive.
-
-.TP 5
-\-\fBw\fR :\fI Output-width-override\fR as:\ \ \fB-w\fR [\fB number\fR ] \fR
-In 'Batch' mode, when used without an argument \*(We will format
-output using the COLUMNS= and LINES= environment variables, if set.
-Otherwise, width will be fixed at the maximum \*(WX columns.
-With an argument, output width can be decreased or increased (up to \*(WX)
-but the number of rows is considered unlimited.
-
-In normal display mode, when used without an argument \*(We will\fI attempt\fR
-to format output using the COLUMNS= and LINES= environment variables, if set.
-With an argument, output width can only be decreased, not increased.
-Whether using environment variables or an argument with -w, when\fI not\fR
-in 'Batch' mode actual terminal dimensions can never be exceeded.
-
-\*(NT Without the use of this \*(CO, output width is always based on the
-terminal at which \*(We was invoked whether or not in 'Batch' mode.
-
-.\" ----------------------------------------------------------------------
-.SH 2. SUMMARY Display
-.\" ----------------------------------------------------------------------
-Each of the following three areas are individually controlled through
-one or more \*(CIs.
-\*(XT 4b. SUMMARY AREA Commands for additional information regarding
-these provisions.
-
-.\" ......................................................................
-.SS 2a. UPTIME and LOAD Averages
-.\" ----------------------------------------------------------------------
-This portion consists of a single line containing:
-.Bd -literal -compact
-    \fBprogram\fR or\fB window\fR name, depending on display mode
-    current time and length of time since last boot
-    total number of users
-    system load avg over the last 1, 5 and 15 minutes
-.Ed
-
-.\" ......................................................................
-.SS 2b. TASK and CPU States
-.\" ----------------------------------------------------------------------
-This portion consists of a minimum of two lines.
-In an SMP environment, additional lines can reflect individual \*(PU
-state percentages.
-
-Line 1 shows total\fB tasks\fR or\fB threads\fR, depending on the state
-of the Threads-mode toggle.
-That total is further classified as:
-.Bd -literal -compact
-    running; sleeping; stopped; zombie
-.Ed
-
-Line 2 shows \*(PU state percentages based on the interval since the
-last refresh.  Where two labels are shown below, those for more recent
-kernel versions are shown first.
-.Bd -literal -compact
-    \fBus\fR,\fB user\fR    : time running un-niced user processes
-    \fBsy\fR,\fB system\fR  : time running kernel processes
-    \fBni\fR,\fB nice\fR    : time running niced user processes
-    \fBwa\fR,\fB IO-wait\fR : time waiting for I/O completion
-    \fBhi\fR : time spent servicing hardware interrupts
-    \fBsi\fR : time spent servicing software interrupts
-    \fBst\fR : time stolen from this vm by the hypervisor
-.Ed
-
-.\" ......................................................................
-.SS 2c. MEMORY Usage
-.\" ----------------------------------------------------------------------
-This portion consists of two lines which may express values in kilobytes (Kb),
-megabytes (Mb) or gigabytes (Gb) depending on the amount of currently
-installed \*(MP.
-
-Line 1 reflects \*(MP, classified as:
-    total, used, free, buffers
-
-Line 2 reflects \*(MV, classified as:
-    total, used, free, cached
-
-.\" ----------------------------------------------------------------------
-.SH 3. FIELDS / Columns
-.\" ----------------------------------------------------------------------
-.\" ......................................................................
-.SS 3a. DESCRIPTIONS of Fields
-.\" ----------------------------------------------------------------------
-Listed below are \*(We's available process fields (columns).
-They are shown in alphabetical order.
-You may customize their position and whether or not they are displayable
-with the 'f' or 'F' (Fields Management) \*(CIs.
-
-Any field is selectable as the sort field, and you control whether they
-are sorted high-to-low or low-to-high.
-For additional information on sort provisions
-\*(Xt 4c. TASK AREA Commands, SORTING.
-
-.TP 4
- 1.\fB CGROUPS \*(Em Control Groups \fR
-The names of the control group(s) to which a process belongs,
-or '-' if not applicable for that process.
-
-Control Groups provide for allocating resources (cpu, memory, network
-bandwidth, etc.) among installation-defined groups of processes.
-They enable fine-grained control over allocating, denying, prioritizing,
-managing and monitoring those resources.
-
-Many different hierarchies of cgroups can exist simultaneously on a system
-and each hierarchy is attached to one or more subsystems.
-A subsystem represents a single resource.
-
-\*(NT The 'CGROUPS' field, unlike most columns, is not fixed-width.
-When displayed, it plus any other variable width columns will be allocated
-all remaining screen width (up to the maximum \*(WX characters).
-
-.TP 4
- 2.\fB CODE \*(Em Code Size (kb) \fR
-The amount of \*(MP devoted to executable code, also known as
-the 'text resident set' size or TRS.
-
-.TP 4
- 3.\fB COMMAND \*(Em Command\fB Name\fR or Command\fB Line \fR
-Display the command line used to start a task or the name of the associated
-program.
-You toggle between command\fI line\fR and\fI name\fR with 'c', which is both
-a \*(CO and an \*(CI.
-
-When you've chosen to display command lines, processes without a command
-line (like kernel threads) will be shown with only the program name in
-brackets, as in this example:
-    \fR[ mdrecoveryd ]
-
-Either form of display is subject to potential truncation if it's too long to
-fit in this field's current width.
-That width depends upon other fields selected, their order and the current
-screen width.
-
-This field may also be impacted by the 'forest view' display mode.
-\*(XC 'V' \*(CI for additional information regarding that mode.
-
-\*(NT The 'COMMAND' field, unlike most columns, is not fixed-width.
-When displayed, it plus any other variable width columns will be allocated
-all remaining screen width (up to the maximum \*(WX characters).
-
-.TP 4
- 4.\fB %CPU \*(Em \*(PU Usage \fR
-The task's share of the elapsed \*(PU time since the last screen update,
-expressed as a percentage of total \*(PU time.
-In a true SMP environment, if 'Irix mode' is \*F, \*(We will operate
-in 'Solaris mode' where a task's \*(Pu usage will be divided by the total
-number of \*(PUs.
-You toggle 'Irix/Solaris' modes with the 'I' \*(CI.
-
-.TP 4
- 5.\fB DATA \*(Em Data + Stack Size (kb) \fR
-The amount of \*(MP devoted to other than executable code, also known as
-the 'data resident set' size or DRS.
-
-.TP 4
- 6.\fB Flags \*(Em Task Flags \fR
-This column represents the task's current scheduling flags which are
-expressed in hexadecimal notation and with zeros suppressed.
-These flags are officially documented in <linux/sched.h>.
-
-.TP 4
- 7.\fB GID \*(Em Group Id \fR
-The\fI effective\fR group ID.
-
-.TP 4
- 8.\fB GROUP \*(Em Group Name \fR
-The\fI effective\fR group name.
-
-.TP 4
- 9.\fB %MEM \*(Em Memory Usage (RES) \fR
-A task's currently used share of available \*(MP.
-
-.TP 4
-10.\fB NI \*(Em Nice Value \fR
-The nice value of the task.
-A negative nice value means higher priority, whereas a positive nice value
-means lower priority.
-Zero in this field simply means priority will not be adjusted in determining
-a task's dispatch-ability.
-
-.TP 4
-11.\fB nDRT \*(Em Dirty Pages Count \fR
-The number of pages that have been modified since they were last
-written to \*(AS.
-Dirty pages must be written to \*(AS before the corresponding physical
-memory location can be used for some other virtual page.
-
-.TP 4
-12.\fB nMaj \*(Em Major Page Fault Count \fR
-The number of\fB major\fR page faults that have occurred for a task.
-A page fault occurs when a process attempts to read from or write to a
-virtual page that is not currently present in its address space.
-A major page fault is when \*(AS access is involved in making that
-page available.
-
-.TP 4
-13.\fB nMin \*(Em Minor Page Fault count \fR
-The number of\fB minor\fR page faults that have occurred for a task.
-A page fault occurs when a process attempts to read from or write to a
-virtual page that is not currently present in its address space.
-A minor page fault does not involve \*(AS access in making that
-page available.
-
-.TP 4
-14.\fB nTH \*(Em Number of Threads \fR
-The number of threads associated with a process.
-
-.TP 4
-15.\fB P \*(Em Last used \*(PU (SMP) \fR
-A number representing the last used processor.
-In a true SMP environment this will likely change frequently since the kernel
-intentionally uses weak affinity.
-Also, the very act of running \*(We may break this weak affinity and cause more
-processes to change \*(PUs more often (because of the extra demand for
-\*(Pu time).
-
-.TP 4
-16.\fB PGRP \*(Em Process Group Id \fR
-Every process is member of a unique process group which is used for
-distribution of signals and by terminals to arbitrate requests for their
-input and output.
-When a process is created (forked), it becomes a member of the process
-group of its parent.
-By convention, this value equals the process ID (\*(Xa PID) of the first
-member of a process group, called the process group leader.
-
-.TP 4
-17.\fB PID \*(Em Process Id \fR
-The task's unique process ID, which periodically wraps, though never
-restarting at zero.
-In kernel terms, it is a dispatchable entity defined by a 'task_struct'.
-
-This value may also be used as: a process group ID (\*(Xa PGRP);
-a session ID for the session leader (\*(Xa SID);
-a thread group ID for the thread group leader (\*(Xa TGID);
-and a TTY process group ID for the process group leader (\*(Xa TPGID).
-
-.TP 4
-18.\fB PPID \*(Em Parent Process Id \fR
-The process ID (pid) of a task's parent.
-
-.TP 4
-19.\fB PR \*(Em Priority \fR
-The scheduling priority of the task.
-If you see 'rt' in this field, it means the task is running under
-'real time' scheduling priority.
-
-Under linux, real time priority is somewhat misleading since traditionally
-the operating itself was not preemptable.
-And while the 2.6 kernel can be made mostly preemptable, it is not always so.
-
-.TP 4
-20.\fB RES \*(Em Resident Memory Size (kb) \fR
-The non-swapped \*(MP a task has used.
-
-.TP 4
-21.\fB RUID \*(Em Real User Id \fR
-The\fI real\fR user ID.
-
-.TP 4
-22.\fB RUSER \*(Em Real User Name \fR
-The\fI real\fR user name.
-
-.TP 4
-23.\fB S \*(Em Process Status \fR
-The status of the task which can be one of:
-    '\fBD\fR' = uninterruptible sleep
-    '\fBR\fR' = running
-    '\fBS\fR' = sleeping
-    '\fBT\fR' = traced or stopped
-    '\fBZ\fR' = zombie
-
-Tasks shown as running should be more properly thought of as 'ready to run'
-\*(Em their task_struct is simply represented on the Linux run-queue.
-Even without a true SMP machine, you may see numerous tasks in this state
-depending on \*(We's delay interval and nice value.
-
-.TP 4
-24.\fB SHR \*(Em Shared Memory Size (kb) \fR
-The amount of \*(MS available to a task, not all of which is
-typically resident.
-It simply reflects memory that could be potentially shared with
-other processes.
-
-.TP 4
-25.\fB SID \*(Em Session Id \fR
-A session is a collection of process groups (\*(Xa PGRP),
-usually established by the login shell.
-A newly forked process joins the session of its creator.
-By convention, this value equals the process ID (\*(Xa PID) of the first
-member of the session, called the session leader, which is usually the
-login shell.
-
-.TP 4
-26.\fB SUID \*(Em Saved User Id \fR
-The\fI saved\fR user ID.
-
-.TP 4
-27.\fB SUPGIDS \*(Em Supplementary Group IDs \fR
-The IDs of any supplementary group(s) established at login or
-inherited from a task's parent.
-They are displayed in a comma delimited list.
-
-\*(NT The 'SUPGIDS' field, unlike most columns, is not fixed-width.
-When displayed, it plus any other variable width columns will be allocated
-all remaining screen width (up to the maximum \*(WX characters).
-
-.TP 4
-28.\fB SUPGRPS \*(Em Supplementary Group Names \fR
-The names of any supplementary group(s) established at login or
-inherited from a task's parent.
-They are displayed in a comma delimited list.
-
-\*(NT The 'SUPGRPS' field, unlike most columns, is not fixed-width.
-When displayed, it plus any other variable width columns will be allocated
-all remaining screen width (up to the maximum \*(WX characters).
-
-.TP 4
-29.\fB SUSER \*(Em Saved User Name \fR
-The\fI saved\fR user name.
-
-.TP 4
-30.\fB SWAP \*(Em Swapped Size (kb) \fR
-The non-resident portion of a task's address space.
-
-.TP 4
-31.\fB TGID \*(Em Thread Group Id \fR
-The ID of the thread group to which a task belongs.
-It is the PID of the thread group leader.
-In kernel terms, it represents those tasks that share an 'mm_struct'.
-
-.TP 4
-32.\fB TIME \*(Em \*(PU Time \fR
-Total \*(PU time the task has used since it started.
-When 'Cumulative mode' is \*O, each process is listed with the \*(Pu
-time that it and its dead children have used.
-You toggle 'Cumulative mode' with 'S', which is both a \*(CO and an \*(CI.
-\*(XC 'S' \*(CI for additional information regarding this mode.
-
-.TP 4
-33.\fB TIME+ \*(Em \*(PU Time, hundredths \fR
-The same as 'TIME', but reflecting more granularity through hundredths
-of a second.
-
-.TP 4
-34.\fB TPGID \*(Em Tty Process Group Id \fR
-The process group ID of the foreground process for the connected tty,
-or -1 if a process is not connected to a terminal.
-By convention, this value equals the process ID (\*(Xa PID) of the
-the process group leader (\*(Xa PGRP).
-
-.TP 4
-35.\fB TTY \*(Em Controlling Tty \fR
-The name of the controlling terminal.
-This is usually the device (serial port, pty, etc.) from which the
-process was started, and which it uses for input or output.
-However, a task need not be associated with a terminal, in which case
-you'll see '?' displayed.
-
-.TP 4
-36.\fB UID \*(Em User Id \fR
-The\fI effective\fR user ID of the task's owner.
-
-.TP 4
-37.\fB USER \*(Em User Name \fR
-The\fI effective\fR user name of the task's owner.
-
-.TP 4
-38.\fB VIRT \*(Em Virtual Memory Size (kb) \fR
-The total amount of \*(MV used by the task.
-It includes all code, data and shared libraries plus pages that have been
-swapped out and pages that have been mapped but not used.
-
-.TP 4
-39.\fB WCHAN \*(Em Sleeping in Function \fR
-Depending on the availability of the kernel link map ('System.map'), this
-field will show the name or the address of the kernel function in which the
-task is currently sleeping.
-Running tasks will display a dash ('-') in this column.
-
-By displaying this field, \*(We's own working set could be increased by over
-700Kb, depending on the kernel version.
-Should that occur, your only means of reducing that overhead will be to stop
-and restart \*(We.
-
-\*(NT The 'WCHAN' field, unlike most columns, is not fixed-width.
-When displayed, it plus any other variable width columns will be allocated
-all remaining screen width (up to the maximum \*(WX characters).
-
-.\" ......................................................................
-.SS 3b. MANAGING Fields
-.\" ----------------------------------------------------------------------
-After pressing the \*(CI 'f' or 'F' (Fields Management) you will be presented
-with a screen showing: 1) the \*(CW name; 2) the designated sort field;
-3) all fields in their current order along with descriptions.
-Entries marked with an asterisk are the currently displayed fields,
-screen width permitting.
-
-.RS +4
-.jBu
-As the on screen instructions indicate, you navigate among the fields with
-the\fB Up\fR and\fB Down\fR \*(KAs.
-The PgUp, PgDn, Home and End keys can also be used to quickly reach the
-first or last available field.
-
-.jBu
-The\fB Right\fR \*(KA selects a field for repositioning and
-the\fB Left\fR \*(KA or the <\fBEnter\fR> key commits that field's
-placement.
-
-.jBu
-The '\fBd\fR' key or the <\fBSpace\fR> bar toggles a field's display
-status, and thus the presence or absence of the asterisk.
-
-.jBu
-The '\fBs\fR' key designates a field as the sort field.
-\*(XT 4c. TASK AREA Commands, SORTING for additional information regarding
-your selection of a sort field.
-
-.jBu
-The '\fBa\fR' and '\fBw\fR' keys can be used to cycle through all available
-windows and the '\fBq\fR' or <\fBEsc\fR> keys exit Fields Management.
-.RS -4
-
-.PP
-The Fields Management screen can also be used to change the \*(CG in
-either \*(FM or \*(AM.
-Whatever was targeted when 'q' or <Esc> was pressed will be made current
-as you return to the \*(We display.
-\*(XT 5. ALTERNATE\-DISPLAY Provisions and the 'g' \*(CI for insight
-into \*(CWs and \*(FGs.
-
-.PP
-\*(NT Any window that has been scrolled\fI horizontally\fR will be reset if any
-field changes are made via the Fields Management screen.
-Any\fI vertical\fR scrolled position, however, will not be affected.
-\*(XT 5c. SCROLLING a Window for additional information regarding vertical
-and horizontal scrolling.
-
-
-.\" ----------------------------------------------------------------------
-.SH 4. INTERACTIVE Commands
-.\" ----------------------------------------------------------------------
-Listed below is a brief index of commands within categories.
-Some commands appear more than once \*(Em their meaning or scope may vary
-depending on the context in which they are issued.
-
-.Bd -literal
-  4a.\fI Global-Commands \fR
-        <Ent/Sp> ?, =, A, B, d, g, h, H, I, k, q, r, s, W, Z
-  4b.\fI Summary-Area-Commands \fR
-        l, t, 1, m
-  4c.\fI Task-Area-Commands \fR
-        Appearance:  b, x, y, z
-        Content:     c, f, F, S, u, U, V
-        Size:        #, i, n
-        Sorting:     <, >, f, F, R
-  4d.\fI Color-Mapping \fR
-        <Ret>, a, B, b, H, M, q, S, T, w, z, 0 - 7
-  5b.\fI Commands-for-Windows \fR
-        -, _, =, +, A, a, g, G, w
-  5c.\fI Scrolling-a-Window \fR
-        C, Up, Dn, Left, Right, PgUp, PgDn, Home, End
-.Ed
-
-.\" ......................................................................
-.SS 4a. GLOBAL Commands
-.\" ----------------------------------------------------------------------
-The global \*(CIs are\fB always\fR available\fR in both \*(FM and \*(AM.
-However, some of these \*(CIs are\fB not available\fR when running
-in 'Secure mode'.
-
-If you wish to know in advance whether or not your \*(We has been
-secured, simply ask for help and view the system summary on the second
-line.
-
-.TP 7
-\ \ \<\fBEnter\fR> or <\fBSpace\fR> :\fIRefresh-Display \fR
-These commands awaken \*(We and following receipt of any input
-the entire display will be repainted.
-They also force an update of any hotplugged \*(Pu or \*(MP changes.
-
-Use either of these keys if you have a large delay interval and wish
-to see current status,
-
-.TP 7
-\ \ \'\fB?\fR\' | \'\fBh\fR\' :\fIHelp \fR
-There are two help levels available.
-The first will provide a reminder of all the basic \*(CIs.
-If \*(We is\fI secured\fR, that screen will be abbreviated.
-
-Typing 'h' or '?' on that help screen will take you to help for
-those \*(CIs applicable to \*(AM.
-
-.TP 7
-\ \ \'\fB=\fR\' :\fIExit-Task-Limits \fR
-Removes restrictions on which tasks are shown.
-This command will reverse any 'i' (idle tasks) and 'n' (max tasks)
-commands that might be active.
-It also provides for an 'exit' from pid monitoring\fI and\fR user filtering.
-See the '-p' \*(CO for a discussion of PID monitoring and the 'U' or 'u'
-\*(CIs regarding user filtering.
-
-Additionally, any window that has been scrolled will be reset with
-this command.
-\*(XT 5c. SCROLLING a Window for additional information regarding
-vertical and horizontal scrolling.
-
-When operating in \*(AM this command has a broader meaning.
-
-.TP 7
-\ \ \'\fBA\fR\' :\fIAlternate-Display-Mode\fR toggle \fR
-This command will switch between \*(FM and \*(AM.
-\*(XT 5. ALTERNATE\-DISPLAY Provisions and the 'g' \*(CI for insight
-into \*(CWs and \*(FGs.
-
-.TP 7
-\ \ \'\fBB\fR\' :\fIBold-Disable/Enable\fR toggle \fR
-This command will influence use of the 'bold' terminfo capability and
-alters\fB both\fR the \*(SA and \*(TA for the \*(CW.
-While it is intended primarily for use with dumb terminals, it can be
-applied anytime.
-
-\*(NT When this toggle is \*O and \*(We is operating in monochrome mode,
-the\fB entire display\fR will appear as normal text.
-Thus, unless the 'x' and/or 'y' toggles are using reverse for emphasis,
-there will be no visual confirmation that they are even on.
-
-.TP 7
-*\ \'\fBd\fR\' | \'\fBs\fR\' :\fIChange-Delay-Time-interval \fR
-You will be prompted to enter the delay time, in seconds, between
-display updates.
-
-Fractional seconds are honored, but a negative number is not allowed.
-Entering 0 causes (nearly) continuous updates, with an unsatisfactory
-display as the system and tty driver try to keep up with \*(We's demands.
-The delay value is inversely proportional to system loading,
-so set it with care.
-
-If at any time you wish to know the current delay time, simply ask for
-help and view the system summary on the second line.
-
-.TP 7
-\ \ \'\fBg\fR\' :\fIChoose-Another-Window/Field-Group \fR
-You will be prompted to enter a number between 1 and 4 designating the
-\*(FG which should be made the \*(CW.
-You will soon grow comfortable with these 4 windows, especially after
-experimenting with \*(AM.
-
-.TP 7
-\ \ \'\fBH\fR\' :\fIThreads-mode\fR toggle \fR
-When this toggle is \*O, individual threads will be displayed for all
-processes in all visible \*(TWs.
-Otherwise, \*(We displays a summation of all threads in each process.
-
-.TP 7
-\ \ \'\fBI\fR\' :\fIIrix/Solaris-Mode\fR toggle \fR
-When operating in 'Solaris mode' ('I' toggled \*F), a task's \*(Pu usage
-will be divided by the total number of \*(PUs.
-After issuing this command, you'll be told the new state of this toggle.
-
-.TP 7
-*\ \'\fBk\fR\' :\fIKill-a-task \fR
-You will be prompted for a PID and then the signal to send.
-The default signal, as reflected in the prompt, is SIGTERM.
-However, you can send any signal, via number or name.
-
-If you wish to abort the kill process, do one of the following
-depending on your progress:
-    1) at the pid prompt, just press <Enter>
-    2) at the signal prompt, type 0
-
-.TP 7
-\ \ \'\fBq\fR\' :\fIQuit \fR
-
-.TP 7
-*\ \'\fBr\fR\' :\fIRenice-a-Task \fR
-You will be prompted for a PID and then the value to nice it to.
-Entering a positive value will cause a process to lose priority.
-Conversely, a negative value will cause a process to be viewed more
-favorably by the kernel.
-
-.TP 7
-\ \ \'\fBW\fR\' :\fIWrite-the-Configuration-File \fR
-This will save all of your options and toggles plus the current
-display mode and delay time.
-By issuing this command just before quitting \*(We, you will be able
-restart later in exactly that same state.
-
-.TP 7
-\ \ \'\fBZ\fR\' :\fIChange-Color-Mapping
-This key will take you to a separate screen where you can change the
-colors for the \*(CW, or for all windows.
-For details regarding this \*(CI \*(Xt 4d. COLOR Mapping.
-
-.IP "*" 3
-The commands shown with an \*(AK are not available in 'Secure mode',
-nor will they be shown on the level-1 help screen.
-
-.\" ......................................................................
-.SS 4b. SUMMARY AREA Commands
-.\" ----------------------------------------------------------------------
-The \*(SA \*(CIs are\fB always available\fR in both \*(FM and \*(AM.
-They affect the beginning lines of your display and will determine the
-position of messages and prompts.
-
-These commands always impact just the \*(CG.
-\*(XT 5. ALTERNATE\-DISPLAY Provisions and the 'g' \*(CI for insight into
-\*(CWs and \*(FGs.
-
-.TP 7
-\ \ \'\fBl\fR\' :\fILoad-Average/Uptime\fR toggle \fR
-This is also the line containing the program name (possibly an alias)
-when operating in \*(FM or the \*(CW name when operating in \*(AM.
-
-.TP 7
-\ \ \'\fBt\fR\' :\fITask/Cpu-States\fR toggle \fR
-This command affects from 2 to many \*(SA lines, depending on the state
-of the '1' toggle and whether or not \*(We is running under true SMP.
-
-This portion of the \*(SA is also influenced by the 'H' \*(CI toggle,
-as reflected in the total label which shows either 'Tasks' or 'Threads'.
-
-.TP 7
-\ \ \'\fB1\fR\' :\fISingle/Separate-Cpu-States\fR toggle \fR
-This command affects how the 't' command's Cpu States portion is shown.
-Although this toggle exists primarily to serve massively-parallel SMP
-machines, it is not restricted to solely SMP environments.
-
-When you see '%Cpu(s):' in the \*(SA, the '1' toggle is \*O and all
-\*(Pu information is gathered in a single line.
-Otherwise, each \*(Pu is displayed separately as: '%Cpu0, %Cpu1, ...'
-up to available screen height.
-
-.TP 7
-\ \ \'\fBm\fR\' :\fIMemory/Swap-Usage\fR toggle \fR
-This command affects the two \*(SA lines dealing with physical
-and virtual memory.
-
-.PP
-\*(NT If the entire \*(SA has been toggled \*F for any window, you would
-be left with just the\fB message line\fR.
-In that way, you will have maximized available task rows but (temporarily)
-sacrificed the program name in \*(FM or the \*(CW name when in \*(AM.
-
-.\" ......................................................................
-.SS 4c. TASK AREA Commands
-.\" ----------------------------------------------------------------------
-The \*(TA \*(CIs are\fB always\fR available in \*(FM.
-
-The \*(TA \*(CIs are\fB never available\fR in \*(AM\fI if\fR the \*(CW's
-\*(TD has been toggled \*F (\*(Xt 5. ALTERNATE\-DISPLAY Provisions).
-
-.PP
-.\" ..................................................
-.B APPEARANCE\fR of \*(TW
-.br
-.in +2
-The following commands will also be influenced by the state of the
-global 'B' (bold enable) toggle.
-.in
-
-.TP 7
-\ \ \'\fBb\fR\' :\fIBold/Reverse\fR toggle \fR
-This command will impact how the 'x' and 'y' toggles are displayed.
-Further, it will only be available when at least one of those toggles is \*O.
-
-.TP 7
-\ \ \'\fBx\fR\' :\fIColumn-Highlight\fR toggle \fR
-Changes highlighting for the current sort field.
-If you forget which field is being sorted this command can serve as a quick
-visual reminder, providing the sort field is being displayed.
-The sort field might\fI not\fR be visible because:
-    1) there is insufficient\fI Screen Width \fR
-    2) the 'f' \*(CI turned it \*F
-
-.TP 7
-\ \ \'\fBy\fR\' :\fIRow-Highlight\fR toggle \fR
-Changes highlighting for "running" tasks.
-For additional insight into this task state,
-\*(Xt 3a. DESCRIPTIONS of Fields, the 'S' field (Process Status).
-
-Use of this provision provides important insight into your system's health.
-The only costs will be a few additional tty escape sequences.
-
-.TP 7
-\ \ \'\fBz\fR\' :\fIColor/Monochrome\fR toggle \fR
-Switches the \*(CW between your last used color scheme and the older form
-of black-on-white or white-on-black.
-This command will alter\fB both\fR the \*(SA and \*(TA but does not affect
-the state of the 'x', 'y' or 'b' toggles.
-
-.PP
-.\" ..................................................
-.B CONTENT\fR of \*(TW
-.PD 0
-.TP 7
-\ \ \'\fBc\fR\' :\fICommand-Line/Program-Name\fR toggle \fR
-This command will be honored whether or not the 'COMMAND' column
-is currently visible.
-Later, should that field come into view, the change you applied will be seen.
-
-.TP 7
-\ \ \'\fBf\fR\' | \'\fBF\fR\' :\fIFields-Management \fR
-These keys display a separate screen where you can change which fields are
-displayed, their order and also designate the sort field.
-For additional information on these \*(CIs
-\*(Xt 3b. MANAGING Fields.
-
-.TP 7
-\ \ \'\fBS\fR\' :\fICumulative-Time-Mode\fR toggle \fR
-When 'Cumulative mode' is \*O, each process is listed with the \*(Pu
-time that it and its dead children have used.
-
-When \*F, programs that fork into many separate tasks will appear
-less demanding.
-For programs like 'init' or a shell this is appropriate but for others,
-like compilers, perhaps not.
-Experiment with two \*(TWs sharing the same sort field but with different 'S'
-states and see which representation you prefer.
-
-After issuing this command, you'll be informed of the new state of this toggle.
-If you wish to know in advance whether or not 'Cumulative mode' is in
-effect, simply ask for help and view the window summary on the second line.
-
-.TP 7
-\ \ \'\fBu\fR' | '\fBU\fR' :\fIShow-Specific-User-Only \fR
-You will be prompted for the\fB uid\fR or\fB name\fR of the user to display.
-The '-u' option matches on \fB effective\fR user whereas the '-U' option
-matches on\fB any\fR user (real, effective, saved, or filesystem).
-
-Thereafter, in that \*(TW only matching users will be shown, or possibly
-no processes will be shown.
-Different \*(TWs can can be used to filter different users.
-
-Later, if you wish to monitor all tasks again in the \*(CW, re-issue this
-command but just press <Enter> at the prompt.
-
-.TP 7
-\ \ \'\fBV\fR' :\fIForest-View-Mode\fR toggle \fR
-In this mode, processes are reordered according to their parents and
-the layout of the COMMAND column resembles that of a tree.
-In forest view mode it is still possible to toggle between program
-name and commamd line (\*(Xc 'c' \*(CI) or between processes and
-threads (\*(Xc 'H' \*(CI).
-
-\*(NT Typing any key affecting the sort order will exit forest view
-mode in the \*(CW.
-\*(XT 4c. TASK AREA Commands, SORTING for information on those keys.
-
-.PP
-.\" ..................................................
-.B SIZE\fR of \*(TW
-.PD 0
-.TP 7
-\ \ \'\fBi\fR\' :\fIIdle-Process\fR toggle \fR
-Displays all tasks or just active tasks.
-When this toggle is \*F, tasks that have not used any \*(PU since the
-last update will not be displayed.
-However, due to the granularity of the %CPU and TIME+ fields,
-some processes may still be displayed that\fI appear\fR to have
-used\fI no\fR \*(PU.
-
-If this command is applied to the last \*(TD when in \*(AM, then it will not
-affect the window's size, as all prior \*(TDs will have already been painted.
-
-.TP 7
-\ \ \'\fBn\fR\' | \'\fB#\fR\' :\fISet-Maximum-Tasks \fR
-You will be prompted to enter the number of tasks to display.
-The lessor of your number and available screen rows will be used.
-
-When used in \*(AM, this is the command that gives you precise control over
-the size of each currently visible \*(TD, except for the very last.
-It will not affect the last window's size, as all prior \*(TDs will have
-already been painted.
-
-\*(NT If you wish to increase the size of the last visible \*(TD when in \*(AM,
-simply decrease the size of the \*(TD(s) above it.
-
-.PP
-.\" ..................................................
-.B SORTING\fR of \*(TW
-.br
-.in +2
-For compatibility, this \*(We supports most of the former \*(We sort keys.
-Since this is primarily a service to former \*(We users, these commands do
-not appear on any help screen.
-.Bd -literal -compact
-  \fI command   sorted-field                  supported \fR
-     A         start time (non-display)     \fB No \fR
-     M         %MEM                          Yes
-     N         PID                           Yes
-     P         %CPU                          Yes
-     T         TIME+                         Yes
-.Ed
-
-Before using any of the following sort provisions, \*(We suggests that you
-temporarily turn on column highlighting using the 'x' \*(CI.
-That will help ensure that the actual sort environment matches your intent.
-
-The following \*(CIs will\fB only\fR be honored when the current sort field
-is\fB visible\fR.
-The sort field might\fI not\fR be visible because:
-     1) there is insufficient\fI Screen Width \fR
-     2) the 'f' \*(CI turned it \*F
-.in
-
-.TP 7
-\ \ \'\fB<\fR\' :\fIMove-Sort-Field-Left \fR
-Moves the sort column to the left unless the current sort field is
-the first field being displayed.
-
-.TP 7
-\ \ \'\fB>\fR\' :\fIMove-Sort-Field-Right \fR
-Moves the sort column to the right unless the current sort field is
-the last field being displayed.
-
-.PP
-.in +2
-The following \*(CIs will\fB always\fR be honored whether or not
-the current sort field is visible.
-.in
-
-.TP 7
-\ \ \'\fBf\fR\' | \'\fBF\fR\' :\fIFields-Management \fR
-These keys display a separate screen where you can change which field
-is used as the sort column, among other functions.
-This can be a convenient way to simply verify the current sort field,
-when running \*(We with column highlighting turned \*F.
-
-.TP 7
-\ \ \'\fBR\fR\' :\fIReverse/Normal-Sort-Field\fR toggle \fR
-Using this \*(CI you can alternate between high-to-low and low-to-high sorts.
-
-.PP
-.in +2
-\*(NT Field sorting uses internal values, not those in column display.
-Thus, the TTY and WCHAN fields will violate strict ASCII collating sequence.
-.in
-
-.\" ......................................................................
-.SS 4d. COLOR Mapping
-.\" ----------------------------------------------------------------------
-When you issue the 'Z' \*(CI, you will be presented with a separate screen.
-That screen can be used to change the colors in just the \*(CW or
-in all four windows before returning to the \*(We display.
-
-.P
-The following \*(CIs are available.
-.Bd -literal -compact
-    \fB4\fR upper case letters to select a\fB target \fR
-    \fB8\fR numbers to select a\fB color \fR
-    normal toggles available \fR
-        'B'       :bold disable/enable
-        'b'       :running tasks "bold"/reverse
-        'z'       :color/mono
-    other commands available \fR
-        'a'/'w'   :apply, then go to next/prior
-        <Enter>   :apply and exit
-        'q'       :abandon current changes and exit
-.Ed
-
-If you use 'a' or 'w' to cycle the targeted window, you will
-have applied the color scheme that was displayed when you left that window.
-You can, of course, easily return to any window and reapply different
-colors or turn colors \*F completely with the 'z' toggle.
-
-The Color Mapping screen can also be used to change the \*(CG in
-either \*(FM or \*(AM.
-Whatever was targeted when 'q' or <Enter> was pressed will be made current
-as you return to the \*(We display.
-
-
-.\" ----------------------------------------------------------------------
-.SH 5. ALTERNATE\-DISPLAY Provisions
-.\" ----------------------------------------------------------------------
-.\" ......................................................................
-.SS 5a. WINDOWS Overview
-.\" ----------------------------------------------------------------------
-.TP
-.B Field Groups/Windows\fR:
-.br
-In \*(FM there is a single window represented by the entire screen.
-That single window can still be changed to display 1 of 4 different\fB field
-groups\fR (\*(Xc 'g' \*(CI, repeated below).
-Each of the 4 \*(FGs has a unique separately configurable\fB \*(SA \fR
-and its own configurable\fB \*(TA\fR.
-
-In \*(AM, those 4 underlying \*(FGs can now be made visible
-simultaneously, or can be turned \*F individually at your command.
-
-The \*(SA will always exist, even if it's only the message line.
-At any given time only\fI one\fR \*(SA can be displayed.
-However, depending on your commands, there could be from\fI zero \fR
-to\fI four\fR separate \*(TDs currently showing on the screen.
-
-.TP
-.B Current Window\fR:
-.br
-The \*(CW is the window associated with the \*(SA and the window to which
-task related commands are always directed.
-Since in \*(AM you can toggle the \*(TD \*F, some commands might be
-restricted for the \*(CW.
-
-A further complication arises when you have toggled the first \*(SA
-line \*F.
-With the loss of the window name (the 'l' toggled line), you'll not easily
-know what window is the \*(CW.
-
-.\" ......................................................................
-.SS 5b. COMMANDS for Windows
-.\" ----------------------------------------------------------------------
-.TP 7
-\ \ \'\fB-\fR\' | \'\fB_\fR\' :\fIShow/Hide-Window(s)\fR toggles \fR
-The '-' key turns the \*(CW's \*(TD \*O and \*F.
-When \*O, that \*(TA will show a minimum of the columns header you've
-established with the 'f' \*(CI.
-It will also reflect any other \*(TA options/toggles you've applied
-yielding zero or more tasks.
-
-The '_' key does the same for all \*(TDs.
-In other words, it switches between the currently visible \*(TD(s) and any
-\*(TD(s) you had toggled \*F.
-If all 4 \*(TDs are currently visible, this \*(CI will leave the \*(SA
-as the only display element.
-
-.TP 7
-*\ \'\fB=\fR\' | \'\fB+\fR\' :\fIEqualize-(re-balance)-Window(s) \fR
-The '=' key forces the \*(CW's \*(TD to be visible.
-It also reverses any 'i' (idle tasks), 'n' (max tasks) and 'u'/'U'
-(user filter) commands that might be active.
-Also, if the window had been scrolled, it will be reset with this command.
-\*(XT 5c. SCROLLING a Window for additional information regarding vertical
-and horizontal scrolling.
-
-The '+' key does the same for all windows.
-The four \*(TDs will reappear, evenly balanced.
-They will also have retained any customizations you had previously applied,
-except for the 'i' (idle tasks), 'n' (max tasks), 'u'/'U' (user filter)
-and scrolling \*(CIs.
-
-.TP 7
-*\ \'\fBA\fR\' :\fIAlternate-Display-Mode\fR toggle \fR
-This command will switch between \*(FM and \*(AM.
-
-The first time you issue this command, all four \*(TDs will be shown.
-Thereafter when you switch modes, you will see only the \*(TD(s) you've
-chosen to make visible.
-
-.TP 7
-*\ \'\fBa\fR\' | \'\fBw\fR\' :\fINext-Window-Forward/Backward \fR
-This will change the \*(CW, which in turn changes the window to which
-commands are directed.
-These keys act in a circular fashion so you can reach any desired \*(CW
-using either key.
-
-Assuming the window name is visible (you have not toggled 'l' \*F),
-whenever the \*(CW name loses its emphasis/color, that's a reminder
-the \*(TD is \*F and many commands will be restricted.
-
-.TP 7
-*\ \'\fBg\fR\' :\fIChoose-Another-Window/Field-Group \fR
-You will be prompted to enter a number between 1 and 4 designating the
-\*(FG which should be made the \*(CW.
-
-In \*(FM, this command is necessary to alter the \*(CW.
-In \*(AM, it is simply a less convenient alternative to the 'a' and 'w'
-commands.
-
-.TP 7
-\ \ \'\fBG\fR\' :\fIChange-Window/Field-Group-Name \fR
-You will be prompted for a new name to be applied to the \*(CW.
-It does not require that the window name be visible
-(the 'l' toggle to be \*O).
-
-.IP "*" 3
-The \*(CIs shown with an \*(AK have use beyond \*(AM.
-.Bd -literal -compact
-    \'=', 'A', 'g'  are always available
-    \'a', 'w'       act the same with color mapping
-    \               and fields management
-.Ed
-
-.\" ......................................................................
-.SS 5c. SCROLLING a Window
-.\" ----------------------------------------------------------------------
-Typically a \*(TW is a partial view into a systems's total tasks/threads
-which shows only some of the available fields/columns.
-With these \*(KSs, you can move that view vertically or horizontally to
-reveal any desired task or column.
-
-.TP 4
-\fBUp\fR,\fBPgUp\fR :\fIScroll-Tasks \fR
-Move the view up toward the first task row, until the first task is
-displayed at the top of the \*(CW.
-The \fIUp\fR \*(KA moves a single line while \fIPgUp\fR scrolls the
-entire window.
-
-.TP 4
-\fBDown\fR,\fBPgDn\fR :\fIScroll-Tasks \fR
-Move the view down toward the last task row, until the last task is
-the only task displayed at the top of the \*(CW.
-The \fIDown\fR \*(KA moves a single line while \fIPgDn\fR scrolls the
-entire window.
-
-.TP 4
-\fBLeft\fR,\fBRight\fR :\fIScroll-Columns \fR
-Move the view of displayable fields horizontally one column at a time.
-
-\*(NT As a reminder, some fields/columns are not fixed-width but
-allocated all remaining screen width when visible.
-When scrolling right or left, that feature may produce some
-unexpected results initially.
-
-.TP 4
-\fBHome\fR :\fIJump-to-Home-Position \fR
-Reposition the display to the un-scrolled coordinates.
-
-.TP 4
-\fBEnd\fR :\fIJump-to-End-Position \fR
-Reposition the display so that the rightmost column reflects the last
-displayable field and the bottom task row represents the last task.
-
-\*(NT From this position it is still possible to scroll\fI down\fR
-and\fI right\fR using the \*(KAs.
-This is true until a single column and a single task is left as the only
-display element.
-
-.TP 4
-'\fBC\fR' :\fIShow-scroll-coordinates\fR toggle \fR
-Toggle an informational message which is displayed whenever the message
-line is not otherwise being used.
-
-.Bd -literal
-    "\fBscroll coordinates: y = n/n (tasks), x = n/n (fields)\fR"
-.Ed
-
-The coordinates shown as \fBn\fR/\fBn\fR are relative to the upper left
-corner of the \*(CW.
-
-.RS +4
-.TP 4
-\fBy = n/n (tasks) \fR
-The first \fBn\fR represents the topmost visible task and is controlled
-by \*(KSs.
-The second \fBn\fR is updated automatically to reflect total tasks.
-
-.TP 4
-\fBx = n/n (fields) \fR
-The first \fBn\fR represents the leftmost displayed column and is
-controlled by \*(KSs.
-The second \fBn\fR is the total number of displayable fields and is
-established with the '\fBf\fR' \*(CI.
-.RS -4
-
-.PP
-The above \*(CIs are\fB always\fR available in \*(FM but\fB never\fR
-available in \*(AM if the \*(CW's \*(TD has been toggled \*F.
-
-
-.\" ----------------------------------------------------------------------
-.SH 6. FILES
-.\" ----------------------------------------------------------------------
-.\" ......................................................................
-.SS 6a. SYSTEM Configuration File
-.\" ----------------------------------------------------------------------
-The presence of this file will influence which version of the 'help' screen
-is shown to an ordinary user.
-More importantly, it will limit what ordinary users are allowed
-to do when \*(We is running.
-They will not be able to issue the following commands.
-.Bd -literal -compact
-    k        Kill a task
-    r        Renice a task
-    d or s   Change delay/sleep interval
-.Ed
-
-The system \*(CF is\fB not\fR created by \*(We.
-Rather, you create this file manually and place it in the \fI/etc \fR
-directory.
-Its name must be 'toprc' and must have no leading '.' (period).
-It must have only two lines.
-
-Here is an example of the contents of\fI /etc/toprc\fR:
-.Bd -literal -compact
-    s        # line 1: 'secure' mode switch
-    5.0      # line 2: 'delay'\ \ interval in seconds
-.Ed
-
-.\" ......................................................................
-.SS 6b. PERSONAL Configuration File
-.\" ----------------------------------------------------------------------
-This file is written as '$HOME/.your-name-4-top' + 'rc'.
-Use the 'W' \*(CI to create it or update it.
-
-Here is the general layout:
-.Bd -literal -compact
-    global   # line 1: the program name/alias notation
-      "      # line 2: id,altscr,irixps,delay,curwin
-    per ea   # line a: winname,fieldscur
-    window   # line b: winflags,sortindx,maxtasks
-      "      # line c: summclr,msgsclr,headclr,taskclr
-.Ed
-
-If the $HOME variable is not present, \*(We will try to write the
-personal \*(CF to the current directory, subject to permissions.
-
-
-.\" ----------------------------------------------------------------------
-.SH 7. STUPID TRICKS Sampler
-.\" ----------------------------------------------------------------------
-Many of these 'tricks' work best when you give \*(We a scheduling boost.
-So plan on starting him with a nice value of -10, assuming you've got
-the authority.
-
-.\" ......................................................................
-.SS 7a. Kernel Magic
-.\" ----------------------------------------------------------------------
-.\" sorry, just can't help it -- don't ya love the sound of this?
-For these stupid tricks, \*(We needs \*(FM.
-.\" ( apparently AM static was a potential concern )
-
-.jBu
-The user interface, through prompts and help, intentionally implies
-that the delay interval is limited to tenths of a second.
-However, you're free to set any desired delay.
-If you want to see Linux at his scheduling best, try a delay of .09
-seconds or less.
-
-For this experiment, under x-windows open an xterm and maximize it.
-Then do the following:
-.Bd -literal -compact
-  . provide a scheduling boost and tiny delay via:
-      nice -n -10 top -d.09
-  . keep sorted column highlighting \*F so as to
-    minimize path length
-  . turn \*O reverse row highlighting for emphasis
-  . try various sort columns (TIME/MEM work well),
-    and normal or reverse sorts to bring the most
-    active processes into view
-.Ed
-
-What you'll see is a very busy Linux doing what he's always done for you,
-but there was no program available to illustrate this.
-
-.jBu
-Under an xterm using 'white-on-black' colors, on \*(We's Color Mapping screen
-set the task color to black and be sure that task highlighting is set to bold,
-not reverse.
-Then set the delay interval to around .3 seconds.
-
-After bringing the most active processes into view, what you'll see are
-the ghostly images of just the currently running tasks.
-
-.jBu
-Delete the existing rcfile, or create a new symlink.
-Start this new version then type 'T' (a secret key,
-\*(Xt 4c. Task Area Commands, SORTING) followed by 'W' and 'q'.
-Finally, restart the program with -d0 (zero delay).
-
-Your display will be refreshed at three times the rate of the former \*(We,
-a 300% speed advantage.
-As \*(We climbs the TIME ladder, be as patient as you can while speculating
-on whether or not \*(We will ever reach the \*(We.
-
-.\" ......................................................................
-.SS 7b. Bouncing Windows
-.\" ----------------------------------------------------------------------
-For these stupid tricks, \*(We needs \*(AM.
-
-.jBu
-With 3 or 4 \*(TDs visible, pick any window other than the last
-and turn idle processes \*F using the 'i' \*(CT.
-Depending on where you applied 'i', sometimes several \*(TDs are bouncing and
-sometimes it's like an accordion, as \*(We tries his best to allocate space.
-
-.jBu
-Set each window's summary lines differently: one with no memory ('m'); another
-with no states ('t'); maybe one with nothing at all, just the message line.
-Then hold down 'a' or 'w' and watch a variation on bouncing windows \*(Em
-hopping windows.
-
-.jBu
-Display all 4 windows and for each, in turn, set idle processes to \*F using
-the 'i' \*(CT.
-You've just entered the "extreme bounce" zone.
-
-.\" ......................................................................
-.SS 7c. The Big Bird Window
-.\" ----------------------------------------------------------------------
-This stupid trick also requires \*(AM.
-
-.jBu
-Display all 4 windows and make sure that 1:Def is the \*(CW.
-Then, keep increasing window size with the 'n' \*(CI until all the other
-\*(TDs are "pushed out of the nest".
-
-When they've all been displaced, toggle between all visible/invisible windows
-using the '_' \*(CT.
-Then ponder this:
-.br
-   is \*(We fibbing or telling honestly your imposed truth?
-.PP
-
-.\" ----------------------------------------------------------------------
-.SH 8. BUGS
-.\" ----------------------------------------------------------------------
-To report bugs, follow the instructions at:
-    http://www.debian.org/Bugs/Reporting
-
-
-.\" ----------------------------------------------------------------------
-.SH 9. HISTORY Former top
-.\" ----------------------------------------------------------------------
-The original top was written by Roger Binns,
-based on Branko Lankester's <lankeste@fwi.uva.nl> ps program.
-
-Robert Nation <nation@rocket.sanders.lockheed.com>
-adapted it for the proc file system.
-
-Helmut Geyer <Helmut.Geyer@iwr.uni-heidelberg.de>
-added support for configurable fields.
-
-Plus many other individuals contributed over the years.
-
-
-.\" ----------------------------------------------------------------------
-.SH 10. AUTHOR
-.\" ----------------------------------------------------------------------
-This entirely new and enhanced replacement was written by:
-    Jim Warner, <james.warner@comcast.net>
-.ig
-   ( as a means to learn Linux, can you believe it? )
-   ( & he accidentally learned a little groff, too! )
-   ( then after ten years he did it all over again! )
-..
-
-With invaluable help from:
-    Craig Small, <csmall@enc.com.au>
-.\" Craig Small. <csmall-procps@enc.com.au>
-.\" Craig Small, <csmall@debian.org>
-.\" Craig Small, <csmall@small.dropbear.id.au>
-    Albert Cahalan, <albert@users.sf.net>
-
-.ig
-.rj 2
-.B -*-\fR few though they are, some yet believe\fB -*- \fR
-.B -*-\~\~\~\~\~\~\~\fRin-the-\fBart\fR-of-programming\~\~\~\~\~\~\~\fB-*- \fR
-..
-
- \" ----------------------------------------------------------------------
-.SH 11. SEE Also
-.\" ----------------------------------------------------------------------
-.BR free (1),
-.BR ps (1),
-.BR uptime (1),
-.BR atop (1),
-.BR slabtop (1),
-.BR vmstat (8),
-.BR w (1).
-
-
-.\" ----------------------------------------------------------------------
-.ig
-.rj 1
-\-*-
-.PD
-.in -3
-Copyright (c) 2002,2011 \*(Em James C. Warner
-
-Permission is granted to copy, distribute and/or modify this document
-under the terms of the GNU Free Documentation License, Version 1.1 or
-any later version published by the Free Software Foundation;
-with no Front-Cover Texts, no Back-Cover Texts, and with the following
-Invariant Sections and any sub-sections therein:
-.na
-.hy 0
-.in +3
-STUPID\ TRICKS\ Sampler;
-.br
-AUTHOR
-.in
-A copy of the license is included in the section entitled
-\(dqGNU Free Documentation License\(dq.
-..
-.
-.\" end: active doc ||||||||||||||||||||||||||||||||||||||||||||||||||||||
-.\" ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-
-.ig
-.\" ----------------------------------------------------------------------
-.SH GNU Free Documentation License
-Version 1.1, March 2000
-
-Copyright (C) 2000  Free Software Foundation, Inc.
-    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-
-Everyone is permitted to copy and distribute verbatim copies
-of this license document, but changing it is not allowed.
-
-.SS 0. PREAMBLE
-The purpose of this License is to make a manual, textbook, or other
-written document "free" in the sense of freedom: to assure everyone
-the effective freedom to copy and redistribute it, with or without
-modifying it, either commercially or noncommercially.  Secondarily,
-this License preserves for the author and publisher a way to get
-credit for their work, while not being considered responsible for
-modifications made by others.
-
-This License is a kind of "copyleft", which means that derivative
-works of the document must themselves be free in the same sense.  It
-complements the GNU General Public License, which is a copyleft
-license designed for free software.
-
-We have designed this License in order to use it for manuals for free
-software, because free software needs free documentation: a free
-program should come with manuals providing the same freedoms that the
-software does.  But this License is not limited to software manuals;
-it can be used for any textual work, regardless of subject matter or
-whether it is published as a printed book.  We recommend this License
-principally for works whose purpose is instruction or reference.
-
-.SS 1. APPLICABILITY AND DEFINITIONS
-This License applies to any manual or other work that contains a
-notice placed by the copyright holder saying it can be distributed
-under the terms of this License.  The "Document", below, refers to any
-such manual or work.  Any member of the public is a licensee, and is
-addressed as "you".
-
-A "Modified Version" of the Document means any work containing the
-Document or a portion of it, either copied verbatim, or with
-modifications and/or translated into another language.
-
-A "Secondary Section" is a named appendix or a front-matter section of
-the Document that deals exclusively with the relationship of the
-publishers or authors of the Document to the Document's overall subject
-(or to related matters) and contains nothing that could fall directly
-within that overall subject.  (For example, if the Document is in part a
-textbook of mathematics, a Secondary Section may not explain any
-mathematics.)  The relationship could be a matter of historical
-connection with the subject or with related matters, or of legal,
-commercial, philosophical, ethical or political position regarding
-them.
-
-The "Invariant Sections" are certain Secondary Sections whose titles
-are designated, as being those of Invariant Sections, in the notice
-that says that the Document is released under this License.
-
-The "Cover Texts" are certain short passages of text that are listed,
-as Front-Cover Texts or Back-Cover Texts, in the notice that says that
-the Document is released under this License.
-
-A "Transparent" copy of the Document means a machine-readable copy,
-represented in a format whose specification is available to the
-general public, whose contents can be viewed and edited directly and
-straightforwardly with generic text editors or (for images composed of
-pixels) generic paint programs or (for drawings) some widely available
-drawing editor, and that is suitable for input to text formatters or
-for automatic translation to a variety of formats suitable for input
-to text formatters.  A copy made in an otherwise Transparent file
-format whose markup has been designed to thwart or discourage
-subsequent modification by readers is not Transparent.  A copy that is
-not "Transparent" is called "Opaque".
-
-Examples of suitable formats for Transparent copies include plain
-ASCII without markup, Texinfo input format, LaTeX input format, SGML
-or XML using a publicly available DTD, and standard-conforming simple
-HTML designed for human modification.  Opaque formats include
-PostScript, PDF, proprietary formats that can be read and edited only
-by proprietary word processors, SGML or XML for which the DTD and/or
-processing tools are not generally available, and the
-machine-generated HTML produced by some word processors for output
-purposes only.
-
-The "Title Page" means, for a printed book, the title page itself,
-plus such following pages as are needed to hold, legibly, the material
-this License requires to appear in the title page.  For works in
-formats which do not have any title page as such, "Title Page" means
-the text near the most prominent appearance of the work's title,
-preceding the beginning of the body of the text.
-
-.SS 2. VERBATIM COPYING
-You may copy and distribute the Document in any medium, either
-commercially or noncommercially, provided that this License, the
-copyright notices, and the license notice saying this License applies
-to the Document are reproduced in all copies, and that you add no other
-conditions whatsoever to those of this License.  You may not use
-technical measures to obstruct or control the reading or further
-copying of the copies you make or distribute.  However, you may accept
-compensation in exchange for copies.  If you distribute a large enough
-number of copies you must also follow the conditions in section 3.
-
-You may also lend copies, under the same conditions stated above, and
-you may publicly display copies.
-
-.SS 3. COPYING IN QUANTITY
-If you publish printed copies of the Document numbering more than 100,
-and the Document's license notice requires Cover Texts, you must enclose
-the copies in covers that carry, clearly and legibly, all these Cover
-Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on
-the back cover.  Both covers must also clearly and legibly identify
-you as the publisher of these copies.  The front cover must present
-the full title with all words of the title equally prominent and
-visible.  You may add other material on the covers in addition.
-Copying with changes limited to the covers, as long as they preserve
-the title of the Document and satisfy these conditions, can be treated
-as verbatim copying in other respects.
-
-If the required texts for either cover are too voluminous to fit
-legibly, you should put the first ones listed (as many as fit
-reasonably) on the actual cover, and continue the rest onto adjacent
-pages.
-
-If you publish or distribute Opaque copies of the Document numbering
-more than 100, you must either include a machine-readable Transparent
-copy along with each Opaque copy, or state in or with each Opaque copy
-a publicly-accessible computer-network location containing a complete
-Transparent copy of the Document, free of added material, which the
-general network-using public has access to download anonymously at no
-charge using public-standard network protocols.  If you use the latter
-option, you must take reasonably prudent steps, when you begin
-distribution of Opaque copies in quantity, to ensure that this
-Transparent copy will remain thus accessible at the stated location
-until at least one year after the last time you distribute an Opaque
-copy (directly or through your agents or retailers) of that edition to
-the public.
-
-It is requested, but not required, that you contact the authors of the
-Document well before redistributing any large number of copies, to give
-them a chance to provide you with an updated version of the Document.
-
-.SS 4. MODIFICATIONS
-You may copy and distribute a Modified Version of the Document under
-the conditions of sections 2 and 3 above, provided that you release
-the Modified Version under precisely this License, with the Modified
-Version filling the role of the Document, thus licensing distribution
-and modification of the Modified Version to whoever possesses a copy
-of it.  In addition, you must do these things in the Modified Version:
-
-.HP 3
-.B A\fR.\ Use in the Title Page (and on the covers, if any) a title distinct
-from that of the Document, and from those of previous versions (which should,
-if there were any, be listed in the History section of the Document).
-You may use the same title as a previous version if the original publisher of
-that version gives permission.
-.HP 3
-.B B\fR.\ List on the Title Page, as authors, one or more persons or entities
-responsible for authorship of the modifications in the Modified Version,
-together with at least five of the principal authors of the Document
-(all of its principal authors, if it has less than five).
-.HP 3
-.B C\fR.\ State on the Title page the name of the publisher of the Modified
-Version, as the publisher.
-.HP 3
-.B D\fR.\ Preserve all the copyright notices of the Document.
-.HP 3
-.B E\fR.\ Add an appropriate copyright notice for your modifications adjacent
-to the other copyright notices.
-.HP 3
-.B F\fR.\ Include, immediately after the copyright notices, a license notice
-giving the public permission to use the Modified Version under the terms of
-this License, in the form shown in the Addendum below.
-.HP 3
-.B G\fR.\ Preserve in that license notice the full lists of Invariant Sections
-and required Cover Texts given in the Document's license notice.
-.HP 3
-.B H\fR.\ Include an unaltered copy of this License.
-.HP 3
-.B I\fR.\ Preserve the section entitled "History", and its title, and add to it
-an item stating at least the title, year, new authors, and publisher of the
-Modified Version as given on the Title Page.
-If there is no section entitled "History" in the Document, create one stating
-the title, year, authors, and publisher of the Document as given on its Title
-Page, then add an item describing the Modified Version as stated in the
-previous sentence.
-.HP 3
-.B J\fR.\ Preserve the network location, if any, given in the Document for
-public access to a Transparent copy of the Document, and likewise the network
-locations given in the Document for previous versions it was based on.
-These may be placed in the "History" section.
-You may omit a network location for a work that was published at least four
-years before the Document itself, or if the original publisher of the version
-it refers to gives permission.
-.HP 3
-.B K\fR.\ In any section entitled "Acknowledgements" or "Dedications", preserve
-the section's title, and preserve in the section all the substance and tone of
-each of the contributor acknowledgements and/or dedications given therein.
-.HP 3
-.B L\fR.\ Preserve all the Invariant Sections of the Document, unaltered in their
-text and in their titles.
-Section numbers or the equivalent are not considered part of the section titles.
-.HP 3
-.B M\fR.\ Delete any section entitled "Endorsements".
-Such a section may not be included in the Modified Version.
-.HP 3
-.B N\fR.\ Do not retitle any existing section as "Endorsements" or to conflict
-in title with any Invariant Section.
-
-.PP
-If the Modified Version includes new front-matter sections or
-appendices that qualify as Secondary Sections and contain no material
-copied from the Document, you may at your option designate some or all
-of these sections as invariant.  To do this, add their titles to the
-list of Invariant Sections in the Modified Version's license notice.
-These titles must be distinct from any other section titles.
-
-You may add a section entitled "Endorsements", provided it contains
-nothing but endorsements of your Modified Version by various
-parties--for example, statements of peer review or that the text has
-been approved by an organization as the authoritative definition of a
-standard.
-
-You may add a passage of up to five words as a Front-Cover Text, and a
-passage of up to 25 words as a Back-Cover Text, to the end of the list
-of Cover Texts in the Modified Version.  Only one passage of
-Front-Cover Text and one of Back-Cover Text may be added by (or
-through arrangements made by) any one entity.  If the Document already
-includes a cover text for the same cover, previously added by you or
-by arrangement made by the same entity you are acting on behalf of,
-you may not add another; but you may replace the old one, on explicit
-permission from the previous publisher that added the old one.
-
-The author(s) and publisher(s) of the Document do not by this License
-give permission to use their names for publicity for or to assert or
-imply endorsement of any Modified Version.
-
-.SS 5. COMBINING DOCUMENTS
-You may combine the Document with other documents released under this
-License, under the terms defined in section 4 above for modified
-versions, provided that you include in the combination all of the
-Invariant Sections of all of the original documents, unmodified, and
-list them all as Invariant Sections of your combined work in its
-license notice.
-
-The combined work need only contain one copy of this License, and
-multiple identical Invariant Sections may be replaced with a single
-copy.  If there are multiple Invariant Sections with the same name but
-different contents, make the title of each such section unique by
-adding at the end of it, in parentheses, the name of the original
-author or publisher of that section if known, or else a unique number.
-Make the same adjustment to the section titles in the list of
-Invariant Sections in the license notice of the combined work.
-
-In the combination, you must combine any sections entitled "History"
-in the various original documents, forming one section entitled
-"History"; likewise combine any sections entitled "Acknowledgements",
-and any sections entitled "Dedications".  You must delete all sections
-entitled "Endorsements."
-
-.SS 6. COLLECTIONS OF DOCUMENTS
-You may make a collection consisting of the Document and other documents
-released under this License, and replace the individual copies of this
-License in the various documents with a single copy that is included in
-the collection, provided that you follow the rules of this License for
-verbatim copying of each of the documents in all other respects.
-
-You may extract a single document from such a collection, and distribute
-it individually under this License, provided you insert a copy of this
-License into the extracted document, and follow this License in all
-other respects regarding verbatim copying of that document.
-
-.SS 7. AGGREGATION WITH INDEPENDENT WORKS
-A compilation of the Document or its derivatives with other separate
-and independent documents or works, in or on a volume of a storage or
-distribution medium, does not as a whole count as a Modified Version
-of the Document, provided no compilation copyright is claimed for the
-compilation.  Such a compilation is called an "aggregate", and this
-License does not apply to the other self-contained works thus compiled
-with the Document, on account of their being thus compiled, if they
-are not themselves derivative works of the Document.
-
-If the Cover Text requirement of section 3 is applicable to these
-copies of the Document, then if the Document is less than one quarter
-of the entire aggregate, the Document's Cover Texts may be placed on
-covers that surround only the Document within the aggregate.
-Otherwise they must appear on covers around the whole aggregate.
-
-.SS 8. TRANSLATION
-Translation is considered a kind of modification, so you may
-distribute translations of the Document under the terms of section 4.
-Replacing Invariant Sections with translations requires special
-permission from their copyright holders, but you may include
-translations of some or all Invariant Sections in addition to the
-original versions of these Invariant Sections.  You may include a
-translation of this License provided that you also include the
-original English version of this License.  In case of a disagreement
-between the translation and the original English version of this
-License, the original English version will prevail.
-
-.SS 9. TERMINATION
-You may not copy, modify, sublicense, or distribute the Document except
-as expressly provided for under this License.  Any other attempt to
-copy, modify, sublicense or distribute the Document is void, and will
-automatically terminate your rights under this License.  However,
-parties who have received copies, or rights, from you under this
-License will not have their licenses terminated so long as such
-parties remain in full compliance.
-
-.SS 10. FUTURE REVISIONS OF THIS LICENSE
-The Free Software Foundation may publish new, revised versions
-of the GNU Free Documentation License from time to time.  Such new
-versions will be similar in spirit to the present version, but may
-differ in detail to address new problems or concerns.  See
-http://www.gnu.org/copyleft/.
-
-Each version of the License is given a distinguishing version number.
-If the Document specifies that a particular numbered version of this
-License "or any later version" applies to it, you have the option of
-following the terms and conditions either of that specified version or
-of any later version that has been published (not as a draft) by the
-Free Software Foundation.  If the Document does not specify a version
-number of this License, you may choose any version ever published (not
-as a draft) by the Free Software Foundation.
-
-.SS ADDENDUM: How to use this License for your documents
-To use this License in a document you have written, include a copy of
-the License in the document and put the following copyright and
-license notices just after the title page:
-
-.IP "" 3
-Copyright (c)  YEAR  YOUR NAME.
-
-Permission is granted to copy, distribute and/or modify this document under the
-terms of the GNU Free Documentation License, Version 1.1 or any later version
-published by the Free Software Foundation;\ \ with the Invariant Sections being
-LIST THEIR TITLES, with the Front-Cover Texts being LIST, and with the
-Back-Cover Texts being LIST.
-A copy of the license is included in the section entitled "GNU
-Free Documentation License".
-
-If you have no Invariant Sections, write "with no Invariant Sections"
-instead of saying which ones are invariant.  If you have no
-Front-Cover Texts, write "no Front-Cover Texts" instead of
-"Front-Cover Texts being LIST"; likewise for Back-Cover Texts.
-
-If your document contains nontrivial examples of program code, we
-recommend releasing these examples in parallel under your choice of
-free software license, such as the GNU General Public License,
-to permit their use in free software.
-
-.\" ----------------------------------------------------------------------
-.SH \fRend of\fB GNU Free Documentation License
-.IP ""
-.PP
-..
-.\" end: gfdl license ||||||||||||||||||||||||||||||||||||||||||||||||||||
-.\" ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
diff --git a/top.c b/top.c
deleted file mode 100644
index c22d4f00..00000000
--- a/top.c
+++ /dev/null
@@ -1,3745 +0,0 @@
-/* top.c - Source file:         show Linux processes */
-/*
- * Copyright (c) 2002-2011, by: James C. Warner
- *    All rights reserved.      8921 Hilloway Road
- *                              Eden Prairie, Minnesota 55347 USA
- *
- * This file may be used subject to the terms and conditions of the
- * GNU Library General Public License Version 2, or any later version
- * at your option, as published by the Free Software Foundation.
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Library General Public License for more details.
- */
-/* For contributions to this program, the author wishes to thank:
- *    Craig Small, <csmall@small.dropbear.id.au>
- *    Albert D. Cahalan, <albert@users.sf.net>
- */
-#include <sys/ioctl.h>
-#include <sys/resource.h>
-#include <sys/time.h>
-#include <sys/types.h>
-
-#include <ctype.h>
-#include <curses.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <pwd.h>
-#include <signal.h>
-#include <stdarg.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <term.h>       // foul sob, defines all sorts of stuff...
-#undef    tab
-#undef    TTY
-#include <termios.h>
-#include <time.h>
-#include <unistd.h>
-#include <values.h>
-
-#include "proc/devname.h"
-#include "proc/procps.h"
-#include "proc/readproc.h"
-#include "proc/sig.h"
-#include "proc/sysinfo.h"
-#include "proc/version.h"
-#include "proc/wchan.h"
-#include "proc/whattime.h"
-
-#include "top.h"
-
-/*######  Miscellaneous global stuff  ####################################*/
-
-        /* The original and new terminal definitions
-           (only set when not in 'Batch' mode) */
-static struct termios Tty_original,    // our inherited terminal definition
-#ifdef TERMIOS_ONLY
-                      Tty_tweaked,     // for interactive 'line' input
-#endif
-                      Tty_raw;         // for unsolicited input
-static int Ttychanged = 0;
-
-        /* Program name used in error messages and local 'rc' file name */
-static char *Myname;
-
-        /* The 'local' config file support */
-static char  Rc_name [OURPATHSZ];
-static RCF_t Rc = DEF_RCFILE;
-
-        /* The run-time acquired page stuff */
-static unsigned Page_size;
-static unsigned Pg2K_shft = 0;
-
-        /* SMP, Irix/Solaris mode, Linux 2.5.xx support */
-        /* (assume no IO-wait stats, overridden if linux 2.5.41) */
-static int         Cpu_tot;
-static float       Cpu_pmax;
-static const char *Cpu_States_fmts = STATES_line2x4;
-
-        /* Specific process id monitoring support */
-static pid_t Monpids [MONPIDMAX] = { 0 };
-static int   Monpidsidx = 0;
-
-        /* A postponed error message */
-static char Msg_delayed [MEDBUFSIZ];
-static int  Msg_awaiting = 0;
-
-        /* Current screen dimensions.
-           note: the number of processes displayed is tracked on a per window
-                 basis (see the WIN_t).  Max_lines is the total number of
-                 screen rows after deducting summary information overhead. */
-        /* Current terminal screen size. */
-static int Screen_cols, Screen_rows, Max_lines;
-
-        /* This is really the number of lines needed to display the summary
-           information (0 - nn), but is used as the relative row where we
-           stick the cursor between frames. */
-static int Msg_row;
-
-        /* Global/Non-windows mode stuff that is NOT persistent */
-static int No_ksyms = -1,       // set to '0' if ksym avail, '1' otherwise
-           PSDBopen = 0,        // set to '1' if psdb opened (now postponed)
-           Batch = 0,           // batch mode, collect no input, dumb output
-           Loops = -1,          // number of iterations, -1 loops forever
-           Secure_mode = 0,     // set if some functionality restricted
-           Thread_mode = 0,     // set w/ 'H' - show threads via readeither()
-           Width_mode = 0;      // set w/ 'w' - potential output override
-
-        /* Unchangeable cap's stuff built just once (if at all) and
-           thus NOT saved in a WIN_t's RCW_t.  To accomodate 'Batch'
-           mode, they begin life as empty strings so the overlying
-           logic need not change ! */
-static char  Cap_clr_eol    [CAPBUFSIZ] = "",    // global and/or static vars
-             Cap_nl_clreos  [CAPBUFSIZ] = "",    // are initialized to zeros!
-             Cap_clr_scr    [CAPBUFSIZ] = "",    // the assignments used here
-             Cap_curs_norm  [CAPBUFSIZ] = "",    // cost nothing but DO serve
-             Cap_curs_huge  [CAPBUFSIZ] = "",    // to remind people of those
-             Cap_curs_hide  [CAPBUFSIZ] = "",    // batch requirements!
-             Cap_home       [CAPBUFSIZ] = "",
-             Cap_norm       [CAPBUFSIZ] = "",
-             Cap_reverse    [CAPBUFSIZ] = "",
-             Caps_off       [CAPBUFSIZ] = "",
-             Caps_endline   [CAPBUFSIZ] = "";
-#ifndef RMAN_IGNORED
-static char  Cap_rmam       [CAPBUFSIZ] = "",
-             Cap_smam       [CAPBUFSIZ] = "";
-        /* set to 1 if writing to the last column would be troublesome
-           (we don't distinguish the lowermost row from the other rows) */
-static int   Cap_avoid_eol = 0;
-#endif
-static int   Cap_can_goto = 0;
-
-        /* Some optimization stuff, to reduce output demands...
-           The Pseudo_ guys are managed by adj_geometry and frame_make.  They
-           are exploited in a macro and represent 90% of our optimization.
-           The Stdout_buf is transparent to our code and regardless of whose
-           buffer is used, stdout is flushed at frame end or if interactive. */
-static char  *Pseudo_screen;
-static int    Pseudo_row = -1;
-static size_t Pseudo_size;
-#ifndef OFF_STDIOLBF
-        // less than stdout's normal buffer but with luck mostly '\n' anyway
-static char  Stdout_buf[2048];
-#endif
-
-        /* Our four WIN_t's, and which of those is considered the 'current'
-           window (ie. which window is associated with any summ info displayed
-           and to which window commands are directed) */
-static WIN_t  Winstk [GROUPSMAX];
-static WIN_t *Curwin;
-
-        /* Frame oriented stuff that can't remain local to any 1 function
-           and/or that would be too cumbersome managed as parms,
-           and/or that are simply more efficiently handled as globals
-           [ 'Frames_...' (plural) stuff persists beyond 1 frame ]
-           [ or are used in response to async signals received ! ] */
-   // Frames_paused set by sig_paused(), unset by pause_pgm()
-static volatile int Frames_paused;     // become a paused background job
-   // Frames_resize set by do_key() & sig_resize(), unset by calibrate_fields()
-static volatile int Frames_resize;     // time to rebuild all column headers
-static          int Frames_libflags;   // PROC_FILLxxx flags
-
-static int          Frame_maxtask;     // last known number of active tasks
-                                       // ie. current 'size' of proc table
-static float        Frame_etscale;     // so we can '*' vs. '/' WHEN 'pcpu'
-static unsigned     Frame_running,     // state categories for this frame
-                    Frame_sleepin,
-                    Frame_stopped,
-                    Frame_zombied;
-static int          Frame_srtflg,      // the subject window's sort direction
-                    Frame_ctimes,      // the subject window's ctimes flag
-                    Frame_cmdlin;      // the subject window's cmdlin flag
-
-        /* Support for 'history' processing so we can calculate %cpu */
-static int    HHist_siz;               // max number of HST_t structs
-static HST_t *PHist_sav,               // alternating 'old/new' HST_t anchors
-             *PHist_new;
-#ifndef OFF_HST_HASH
-#define       HHASH_SIZ  1024
-static int    HHash_one [HHASH_SIZ],   // actual hash tables ( hereafter known
-              HHash_two [HHASH_SIZ],   // as PHash_sav/PHash_new )
-              HHash_nul [HHASH_SIZ];   // 'empty' hash table image
-static int   *PHash_sav = HHash_one,   // alternating 'old/new' hash tables
-             *PHash_new = HHash_two;
-#endif
-
-/*######  Sort callbacks  ################################################*/
-
-        /*
-         * These happen to be coded in the enum identifier alphabetic order,
-         * not the order of the enum 'pflgs' value.  Also note that a callback
-         * routine may serve more than one column.
-         */
-
-SCB_STRV(CGR, 1, cgroup, cgroup[0])
-SCB_STRV(CMD, Frame_cmdlin, cmdline, cmd)
-SCB_NUM1(COD, trs)
-SCB_NUMx(CPN, processor)
-SCB_NUM1(CPU, pcpu)
-SCB_NUM1(DAT, drs)
-SCB_NUM1(DRT, dt)
-SCB_NUM1(FLG, flags)
-SCB_NUM1(FL1, maj_flt)
-SCB_NUM1(FL2, min_flt)
-SCB_NUMx(GID, egid)
-SCB_STRS(GRP, egroup)
-SCB_NUMx(NCE, nice)
-#ifdef OOMEM_ENABLE
-SCB_NUM1(OOA, oom_adj)
-SCB_NUM1(OOM, oom_score)
-#endif
-SCB_NUMx(PGD, pgrp)
-SCB_NUMx(PID, tid)
-SCB_NUMx(PPD, ppid)
-SCB_NUMx(PRI, priority)
-SCB_NUM1(RES, resident)                // also serves MEM !
-SCB_STRX(SGD, supgid)
-SCB_STRS(SGN, supgrp)
-SCB_NUM1(SHR, share)
-SCB_NUM1(SID, session)
-SCB_NUMx(STA, state)
-SCB_NUM1(SWP, vm_swap)
-SCB_NUMx(TGD, tgid)
-SCB_NUMx(THD, nlwp)
-                                       // also serves TM2 !
-static int SCB_NAME(TME) (const proc_t **P, const proc_t **Q) {
-   if (Frame_ctimes) {
-      if (((*P)->cutime + (*P)->cstime + (*P)->utime + (*P)->stime)
-        < ((*Q)->cutime + (*Q)->cstime + (*Q)->utime + (*Q)->stime))
-           return SORT_lt;
-      if (((*P)->cutime + (*P)->cstime + (*P)->utime + (*P)->stime)
-        > ((*Q)->cutime + (*Q)->cstime + (*Q)->utime + (*Q)->stime))
-           return SORT_gt;
-   } else {
-      if (((*P)->utime + (*P)->stime) < ((*Q)->utime + (*Q)->stime))
-         return SORT_lt;
-      if (((*P)->utime + (*P)->stime) > ((*Q)->utime + (*Q)->stime))
-         return SORT_gt;
-   }
-   return SORT_eq;
-}
-SCB_NUM1(TPG, tpgid)
-SCB_NUMx(TTY, tty)
-SCB_NUMx(UED, euid)
-SCB_STRS(UEN, euser)
-SCB_NUMx(URD, ruid)
-SCB_STRS(URN, ruser)
-SCB_NUMx(USD, suid)
-SCB_STRS(USN, suser)
-SCB_NUM1(VRT, size)
-SCB_NUM1(WCH, wchan)
-
-#ifdef OFF_HST_HASH
-        /* special sort for prochlp() ! -------------------------- */
-static int sort_HST_t (const HST_t *P, const HST_t *Q) {
-   return P->pid - Q->pid;
-}
-#endif
-
-/*######  Tiny useful routine(s)  ########################################*/
-
-        /*
-         * This routine simply formats whatever the caller wants and
-         * returns a pointer to the resulting 'const char' string... */
-static const char *fmtmk (const char *fmts, ...) __attribute__((format(printf,1,2)));
-static const char *fmtmk (const char *fmts, ...) {
-   static char buf[BIGBUFSIZ];          // with help stuff, our buffer
-   va_list va;                          // requirements now exceed 1k
-
-   va_start(va, fmts);
-   vsnprintf(buf, sizeof(buf), fmts, va);
-   va_end(va);
-   return (const char *)buf;
-} // end: fmtmk
-
-
-        /*
-         * This guy is just our way of avoiding the overhead of the standard
-         * strcat function (should the caller choose to participate) */
-static inline char *scat (char *dst, const char *src) {
-   while (*dst) dst++;
-   while ((*(dst++) = *(src++)));
-   return --dst;
-} // end: scat
-
-
-        /*
-         * Trim the rc file lines and any 'open_psdb_message' which arrives
-         * with an inappropriate newline (thanks to 'sysmap_mmap') */
-static char *strim (char *str) {
-   static const char ws[] = "\b\f\n\r\t\v\x1b\x9b";  // 0x1b + 0x9b are escape
-   char *p;
-
-   if ((p = strpbrk(str, ws))) *p = '\0';
-   return str;
-} // end: strim
-
-
-        /*
-         * This guy just facilitates Batch and protects against dumb ttys
-         * -- we'd 'inline' him but he's only called twice per frame,
-         * yet used in many other locations. */
-static const char *tg2 (int x, int y) {
-   // it's entirely possible we're trying for an invalid row...
-   return Cap_can_goto ? tgoto(cursor_address, x, y) : "";
-} // end: tg2
-
-/*######  Exit/Interrput routines  #######################################*/
-
-        /*
-         * The real program end */
-static void bye_bye (const char *str) NORETURN;
-static void bye_bye (const char *str) {
-   if (Ttychanged) {
-      tcsetattr(STDIN_FILENO, TCSAFLUSH, &Tty_original);
-      putp(tg2(0, Screen_rows));
-      putp(Cap_curs_norm);
-#ifndef RMAN_IGNORED
-      putp(Cap_smam);
-#endif
-   }
-   fflush(stdout);
-
-#ifdef ATEOJ_RPTSTD
-{  proc_t *p;
-   if (!str) { fprintf(stderr,
-      "\n%s's Summary report:"
-      "\n\tProgram"
-      "\n\t   Linux version = %u.%u.%u, %s"
-      "\n\t   Hertz = %u (%u bytes, %u-bit time)"
-      "\n\t   Page_size = %d, Cpu_tot = %d"
-      "\n\t   sizeof(CPU_t) = %u, sizeof(HST_t) = %u (%u HST_t's/Page), HHist_siz = %u"
-      "\n\t   sizeof(proc_t) = %u, sizeof(proc_t.cmd) = %u, sizeof(proc_t*) = %u"
-      "\n\t   Frames_libflags = %08lX"
-      "\n\t   SCREENMAX = %u, ROWMINSIZ = %u, ROWMAXSIZ = %u"
-      "\n\tTerminal: %s"
-      "\n\t   device = %s, ncurses = v%s"
-      "\n\t   max_colors = %d, max_pairs = %d"
-      "\n\t   Cap_can_goto = %s"
-      "\n\t   Screen_cols = %d, Screen_rows = %d"
-      "\n\t   Max_lines = %d, most recent Pseudo_size = %u"
-#ifndef OFF_STDIOLBF
-      "\n\t   Stdout_buf = %u, BUFSIZ = %u"
-#endif
-      "\n\tWindows and Curwin->"
-      "\n\t   sizeof(WIN_t) = %u, GROUPSMAX = %d"
-      "\n\t   winname = %s, grpname = %s"
-#ifdef CASEUP_HEXES
-      "\n\t   winflags = %08X, maxpflgs = %d"
-#else
-      "\n\t   winflags = %08x, maxpflgs = %d"
-#endif
-      "\n\t   fieldscur = %s, sortindx  = %d"
-      "\n\t   maxtasks = %d, varcolsz = %d, winlines = %d"
-      "\n\t   strlen(columnhdr) = %d"
-      "\n"
-      , __func__
-      , LINUX_VERSION_MAJOR(linux_version_code)
-      , LINUX_VERSION_MINOR(linux_version_code)
-      , LINUX_VERSION_PATCH(linux_version_code)
-      , procps_version
-      , (unsigned)Hertz, (unsigned)sizeof(Hertz), (unsigned)sizeof(Hertz) * 8
-      , Page_size, Cpu_tot
-      , (unsigned) sizeof(CPU_t), (unsigned)sizeof(HST_t), Page_size / (unsigned)sizeof(HST_t), HHist_siz
-      , (unsigned)sizeof(proc_t), (unsigned)sizeof(p->cmd), (unsigned)sizeof(proc_t*)
-      , (long)Frames_libflags
-      , (unsigned)SCREENMAX, (unsigned)ROWMINSIZ, (unsigned)ROWMAXSIZ
-#ifdef PRETENDNOCAP
-      , "dumb"
-#else
-      , termname()
-#endif
-      , ttyname(STDOUT_FILENO), NCURSES_VERSION
-      , max_colors, max_pairs
-      , Cap_can_goto ? "yes" : "No!"
-      , Screen_cols, Screen_rows
-      , Max_lines, (unsigned)Pseudo_size
-#ifndef OFF_STDIOLBF
-      , (unsigned)sizeof(Stdout_buf), (unsigned)BUFSIZ
-#endif
-      , (unsigned)sizeof(WIN_t), GROUPSMAX
-      , Curwin->rc.winname, Curwin->grpname
-      , Curwin->rc.winflags, Curwin->maxpflgs
-      , Curwin->rc.fieldscur, Curwin->rc.sortindx
-      , Curwin->rc.maxtasks, Curwin->varcolsz, Curwin->winlines
-      , (int)strlen(Curwin->columnhdr)
-      );
-   }
-}
-#endif // end: ATEOJ_RPTSTD
-
-#ifndef OFF_HST_HASH
-#ifdef ATEOJ_RPTHSH
-   if (!str) {
-      int i, j, pop, total_occupied, maxdepth, maxdepth_sav, numdepth
-         , cross_foot, sz = HHASH_SIZ * (unsigned)sizeof(int);
-      int depths[HHASH_SIZ];
-
-      for (i = 0, total_occupied = 0, maxdepth = 0; i < HHASH_SIZ; i++) {
-         int V = PHash_new[i];
-         j = 0;
-         if (-1 < V) {
-            ++total_occupied;
-            while (-1 < V) {
-               V = PHist_new[V].lnk;
-               if (-1 < V) j++;
-            }
-         }
-         depths[i] = j;
-         if (maxdepth < j) maxdepth = j;
-      }
-      maxdepth_sav = maxdepth;
-
-      fprintf(stderr,
-         "\n%s's Supplementary HASH report:"
-         "\n\tTwo Tables providing for %d entries each + 1 extra for 'empty' image"
-         "\n\t%dk (%d bytes) per table, %d total bytes (including 'empty' image)"
-         "\n\tResults from latest hash (PHash_new + PHist_new)..."
-         "\n"
-         "\n\tTotal hashed = %d"
-         "\n\tLevel-0 hash entries = %d (%d%% occupied)"
-         "\n\tMax Depth = %d"
-         "\n\n"
-         , __func__
-         , HHASH_SIZ, sz / 1024, sz, sz * 3
-         , Frame_maxtask
-         , total_occupied, (total_occupied * 100) / HHASH_SIZ
-         , maxdepth + 1);
-
-      if (total_occupied) {
-         for (pop = total_occupied, cross_foot = 0; maxdepth; maxdepth--) {
-            for (i = 0, numdepth = 0; i < HHASH_SIZ; i++)
-               if (depths[i] == maxdepth) ++numdepth;
-            fprintf(stderr,
-               "\t %5d (%3d%%) hash table entries at depth %d\n"
-               , numdepth, (numdepth * 100) / total_occupied, maxdepth + 1);
-            pop -= numdepth;
-            cross_foot += numdepth;
-            if (0 == pop && cross_foot == total_occupied) break;
-         }
-         if (pop) {
-            fprintf(stderr, "\t %5d (%3d%%) unchained hash table entries\n"
-               , pop, (pop * 100) / total_occupied);
-            cross_foot += pop;
-         }
-         fprintf(stderr,
-            "\t -----\n"
-            "\t %5d total entries occupied\n", cross_foot);
-
-         if (maxdepth_sav) {
-            fprintf(stderr, "\nPIDs at max depth: ");
-            for (i = 0; i < HHASH_SIZ; i++)
-               if (depths[i] == maxdepth_sav) {
-                  j = PHash_new[i];
-                  fprintf(stderr, "\n\tpos %4d:  %05d", i, PHist_new[j].pid);
-                  while (-1 < j) {
-                     j = PHist_new[j].lnk;
-                     if (-1 < j) fprintf(stderr, ", %05d", PHist_new[j].pid);
-                  }
-               }
-            fprintf(stderr, "\n");
-         }
-      }
-   }
-#endif // end: ATEOJ_RPTHSH
-#endif // end: OFF_HST_HASH
-
-   if (str) {
-      fputs(str, stderr);
-      exit(1);
-   }
-   putp("\n");
-   exit(0);
-} // end: bye_bye
-
-
-        /*
-         * Standard error handler to normalize the look of all err output */
-static void error_exit (const char *str) NORETURN;
-static void error_exit (const char *str) {
-   static char buf[MEDBUFSIZ];
-
-   /* we'll use our own buffer so callers can still use fmtmk() and, yes the
-      leading tab is not the standard convention, but the standard is wrong
-      -- OUR msg won't get lost in screen clutter, like so many others! */
-   snprintf(buf, sizeof(buf), "\t%s: %s\n", Myname, str);
-   bye_bye(buf);
-} // end: error_exit
-
-
-        /*
-         * Called in response to Frames_paused (tku: sig_paused) */
-static void pause_pgm (void) {
-   Frames_paused = 0;
-   // reset terminal (maybe)
-   if (Ttychanged) tcsetattr(STDIN_FILENO, TCSAFLUSH, &Tty_original);
-   putp(tg2(0, Screen_rows));
-   putp(Cap_curs_norm);
-#ifndef RMAN_IGNORED
-   putp(Cap_smam);
-#endif
-   fflush(stdout);
-   raise(SIGSTOP);
-   // later, after SIGCONT...
-   if (Ttychanged) tcsetattr(STDIN_FILENO, TCSAFLUSH, &Tty_raw);
-#ifndef RMAN_IGNORED
-   putp(Cap_rmam);
-#endif
-} // end: pause_pgm
-
-
-        /*
-         * Catches all remaining signals not otherwise handled */
-static void sig_abexit (int sig) NORETURN;
-static void sig_abexit (int sig) {
-   static const char *ab_msg =
-      "\n\tsignal %d (%s) was caught by %s, please"
-      "\n\tsee http://www.debian.org/Bugs/Reporting\n";
-   sigset_t ss;
-
-   sigfillset(&ss);
-   sigprocmask(SIG_BLOCK, &ss, NULL);
-   bye_bye(fmtmk(ab_msg, sig, signal_number_to_name(sig), Myname));
-} // end: sig_abexit
-
-
-        /*
-         * Catches:
-         *    SIGALRM, SIGHUP, SIGINT, SIGPIPE, SIGQUIT and SIGTERM */
-static void sig_endpgm (int dont_care_sig) NORETURN;
-static void sig_endpgm (int dont_care_sig) {
-   sigset_t ss;
-
-   sigfillset(&ss);
-   sigprocmask(SIG_BLOCK, &ss, NULL);
-   bye_bye(NULL);
-   (void)dont_care_sig;
-} // end: sig_endpgm
-
-
-        /*
-         * Catches:
-         *    SIGTSTP, SIGTTIN and SIGTTOU */
-static void sig_paused (int dont_care_sig) {
-   (void)dont_care_sig;
-   Frames_paused = 1;
-} // end: sig_paused
-
-
-        /*
-         * Catches:
-         *    SIGCONT and SIGWINCH */
-static void sig_resize (int dont_care_sig) {
-   (void)dont_care_sig;
-   Frames_resize = 1;
-} // end: sig_resize
-
-/*######  Misc Color/Display support  ####################################*/
-
-        /*
-         * Make the appropriate caps/color strings for a window/field group.
-         * note: we avoid the use of background color so as to maximize
-         *       compatibility with the user's xterm settings */
-static void capsmk (WIN_t *q) {
-   /* macro to test if a basic (non-color) capability is valid
-         thanks: Floyd Davidson <floyd@ptialaska.net> */
- #define tIF(s)  s ? s : ""
-   static int capsdone = 0;
-
-   // we must NOT disturb our 'empty' terminfo strings!
-   if (Batch) return;
-
-   // these are the unchangeable puppies, so we only do 'em once
-   if (!capsdone) {
-      STRLCPY(Cap_clr_eol, tIF(clr_eol))
-      STRLCPY(Cap_clr_scr, tIF(clear_screen))
-      // due to leading newline, only 1 function may use this (and carefully)
-      snprintf(Cap_nl_clreos, sizeof(Cap_nl_clreos), "\n%s", tIF(clr_eos));
-      STRLCPY(Cap_curs_huge, tIF(cursor_visible))
-      STRLCPY(Cap_curs_norm, tIF(cursor_normal))
-      STRLCPY(Cap_curs_hide, tIF(cursor_invisible))
-      STRLCPY(Cap_home, tIF(cursor_home))
-      STRLCPY(Cap_norm, tIF(exit_attribute_mode))
-      STRLCPY(Cap_reverse, tIF(enter_reverse_mode))
-#ifndef RMAN_IGNORED
-      if (!eat_newline_glitch) {
-         STRLCPY(Cap_rmam, tIF(exit_am_mode))
-         STRLCPY(Cap_smam, tIF(enter_am_mode))
-         if (!*Cap_rmam || !*Cap_smam) {
-            *Cap_rmam = '\0';
-            *Cap_smam = '\0';
-            if (auto_right_margin)
-               Cap_avoid_eol = 1;
-         }
-         putp(Cap_rmam);
-      }
-#endif
-      snprintf(Caps_off, sizeof(Caps_off), "%s%s", Cap_norm, tIF(orig_pair));
-      snprintf(Caps_endline, sizeof(Caps_endline), "%s%s", Caps_off, Cap_clr_eol);
-      if (tgoto(cursor_address, 1, 1)) Cap_can_goto = 1;
-      capsdone = 1;
-   }
-
-   /* the key to NO run-time costs for configurable colors -- we spend a
-      little time with the user now setting up our terminfo strings, and
-      the job's done until he/she/it has a change-of-heart */
-   STRLCPY(q->cap_bold, CHKw(q, View_NOBOLD) ? Cap_norm : tIF(enter_bold_mode))
-   if (CHKw(q, Show_COLORS) && max_colors > 0) {
-      STRLCPY(q->capclr_sum, tparm(set_a_foreground, q->rc.summclr))
-      snprintf(q->capclr_msg, sizeof(q->capclr_msg), "%s%s"
-         , tparm(set_a_foreground, q->rc.msgsclr), Cap_reverse);
-      snprintf(q->capclr_pmt, sizeof(q->capclr_pmt), "%s%s"
-         , tparm(set_a_foreground, q->rc.msgsclr), q->cap_bold);
-      snprintf(q->capclr_hdr, sizeof(q->capclr_hdr), "%s%s"
-         , tparm(set_a_foreground, q->rc.headclr), Cap_reverse);
-      snprintf(q->capclr_rownorm, sizeof(q->capclr_rownorm), "%s%s"
-         , Caps_off, tparm(set_a_foreground, q->rc.taskclr));
-   } else {
-      q->capclr_sum[0] = '\0';
-      STRLCPY(q->capclr_msg, Cap_reverse)
-      STRLCPY(q->capclr_pmt, q->cap_bold)
-      STRLCPY(q->capclr_hdr, Cap_reverse)
-      STRLCPY(q->capclr_rownorm, Cap_norm)
-   }
-
-   // composite(s), so we do 'em outside and after the if
-   snprintf(q->capclr_rowhigh, sizeof(q->capclr_rowhigh), "%s%s"
-      , q->capclr_rownorm, CHKw(q, Show_HIBOLD) ? q->cap_bold : Cap_reverse);
- #undef tIF
-} // end: capsmk
-
-
-        /*
-         * Show an error, but not right now.
-         * Due to the postponed opening of ksym, using open_psdb_message,
-         * if P_WCH had been selected and the program is restarted, the
-         * message would otherwise be displayed prematurely. */
-static void msg_save (const char *fmts, ...) __attribute__((format(printf,1,2)));
-static void msg_save (const char *fmts, ...) {
-   char tmp[MEDBUFSIZ];
-   va_list va;
-
-   va_start(va, fmts);
-   vsnprintf(tmp, sizeof(tmp), fmts, va);
-   va_end(va);
-   // we'll add some extra attention grabbers to whatever this is
-   snprintf(Msg_delayed, sizeof(Msg_delayed), "***  %s  ***", strim(tmp));
-   Msg_awaiting = 1;
-} // end: msg_save
-
-
-        /*
-         * Show an error message (caller may include '\a' for sound) */
-static void show_msg (const char *str) {
-   PUTT("%s%s %.*s %s%s"
-      , tg2(0, Msg_row)
-      , Curwin->capclr_msg
-      , Screen_cols - 2
-      , str
-      , Caps_off
-      , Cap_clr_eol);
-   fflush(stdout);
-   usleep(MSG_USLEEP);
-   Msg_awaiting = 0;
-} // end: show_msg
-
-
-        /*
-         * Show an input prompt + larger cursor (if possible) */
-static int show_pmt (const char *str) {
-   int rc;
-
-   PUTT("%s%s%.*s: %s%s%s"
-      , tg2(0, Msg_row)
-      , Curwin->capclr_pmt
-      , Screen_cols - 3
-      , str
-      , Cap_curs_huge
-      , Caps_off
-      , Cap_clr_eol);
-   fflush(stdout);
-   // +2 for the ': ' chars we added or -1 for the cursor...
-   return ((rc = (int)strlen(str)+2) < Screen_cols) ? rc : Screen_cols-1;
-} // end: show_pmt
-
-
-        /*
-         * Show a special coordinate message, in support of scrolling */
-static inline void show_scroll (void) {
-   char tmp[SMLBUFSIZ];
-   int totpflgs = Curwin->totpflgs;
-   int begpflgs = Curwin->begpflg + 1;
-
-#ifndef USE_X_COLHDR
-   if (CHKw(Curwin, Show_HICOLS)) {
-      totpflgs -= 2;
-      if (ENUpos(Curwin, Curwin->rc.sortindx) < Curwin->begpflg) begpflgs -= 2;
-   }
-#endif
-   if (1 > totpflgs) totpflgs = 1;
-   if (1 > begpflgs) begpflgs = 1;
-   snprintf(tmp, sizeof(tmp)
-      , "scroll coordinates: y = %d/%d (tasks), x = %d/%d (fields)"
-      , Curwin->begtask + 1, Frame_maxtask
-      , begpflgs, totpflgs);
-   PUTT("%s%s  %.*s%s", tg2(0, Msg_row), Caps_off, Screen_cols - 2, tmp, Cap_clr_eol);
-   putp(tg2(0, Msg_row));
-} // end: show_scroll
-
-
-        /*
-         * Show lines with specially formatted elements, but only output
-         * what will fit within the current screen width.
-         *    Our special formatting consists of:
-         *       "some text <_delimiter_> some more text <_delimiter_>...\n"
-         *    Where <_delimiter_> is a two byte combination consisting of a
-         *    tilde followed by an ascii digit in the the range of 1 - 8.
-         *       examples: ~1,  ~5,  ~8, etc.
-         *    The tilde is effectively stripped and the next digit
-         *    converted to an index which is then used to select an
-         *    'attribute' from a capabilities table.  That attribute
-         *    is then applied to the *preceding* substring.
-         * Once recognized, the delimiter is replaced with a null character
-         * and viola, we've got a substring ready to output!  Strings or
-         * substrings without delimiters will receive the Cap_norm attribute.
-         *
-         * Caution:
-         *    This routine treats all non-delimiter bytes as displayable
-         *    data subject to our screen width marching orders.  If callers
-         *    embed non-display data like tabs or terminfo strings in our
-         *    glob, a line will truncate incorrectly at best.  Worse case
-         *    would be truncation of an embedded tty escape sequence.
-         *
-         *    Tabs must always be avoided or our efforts are wasted and
-         *    lines will wrap.  To lessen but not eliminate the risk of
-         *    terminfo string truncation, such non-display stuff should
-         *    be placed at the beginning of a "short" line. */
-static void show_special (int interact, const char *glob) {
-  /* note: the following is for documentation only,
-           the real captab is now found in a group's WIN_t !
-     +------------------------------------------------------+
-     | char *captab[] = {                 :   Cap's/Delim's |
-     |   Cap_norm, Cap_norm,              =   \000, \001,   |
-     |   cap_bold, capclr_sum,            =   \002, \003,   |
-     |   capclr_msg, capclr_pmt,          =   \004, \005,   |
-     |   capclr_hdr,                      =   \006,         |
-     |   capclr_rowhigh,                  =   \007,         |
-     |   capclr_rownorm  };               =   \010 [octal!] |
-     +------------------------------------------------------+ */
-  /* ( pssst, after adding the termcap transitions, row may )
-     ( exceed 300+ bytes, even in an 80x24 terminal window! ) */
-   char tmp[SMLBUFSIZ], lin[MEDBUFSIZ], row[LRGBUFSIZ];
-   char *rp, *lin_end, *sub_beg, *sub_end;
-   int room;
-
-   // handle multiple lines passed in a bunch
-   while ((lin_end = strchr(glob, '\n'))) {
-      // create a local copy we can extend and otherwise abuse
-      memcpy(lin, glob, (unsigned)(lin_end - glob));
-      // zero terminate this part and prepare to parse substrings
-      lin[lin_end - glob] = '\0';
-      room = Screen_cols;
-      sub_beg = sub_end = lin;
-      *(rp = row) = '\0';
-
-      while (*sub_beg) {
-         int ch = *sub_end;
-         if ('~' == ch) ch = *(sub_end + 1) - '0';
-         switch (ch) {
-            case 0:                    // no end delim, captab makes normal
-               *(sub_end + 1) = '\0';  // extend str end, then fall through
-               *(sub_end + 2) = '\0';  // ( +1 optimization for usual path )
-            case 1 ... 8:
-               *sub_end = '\0';
-               snprintf(tmp, sizeof(tmp), "%s%.*s%s", Curwin->captab[ch], room, sub_beg, Caps_off);
-               rp = scat(rp, tmp);
-               room -= (sub_end - sub_beg);
-               sub_beg = (sub_end += 2);
-               break;
-            default:                   // nothin' special, just text
-               ++sub_end;
-         }
-         if (0 >= room) break;         // skip substrings that won't fit
-      }
-
-      if (interact) PUTT("%s%s\n", row, Cap_clr_eol);
-      else PUFF("%s%s\n", row, Caps_endline);
-      glob = ++lin_end;                // point to next line (maybe)
-
-   } // end: while 'lines'
-
-   /* If there's anything left in the glob (by virtue of no trailing '\n'),
-      it probably means caller wants to retain cursor position on this final
-      line.  That, in turn, means we're interactive and so we'll just do our
-      'fit-to-screen' thingy while also leaving room for the cursor... */
-   if (*glob) PUTT("%.*s", Screen_cols -1, glob);
-} // end: show_special
-
-/*######  Low Level Memory/Keyboard support  #############################*/
-
-        /*
-         * Handle our own memory stuff without the risk of leaving the
-         * user's terminal in an ugly state should things go sour. */
-
-static void *alloc_c (size_t num) MALLOC;
-static void *alloc_c (size_t num) {
-   void *pv;
-
-   if (!num) ++num;
-   if (!(pv = calloc(1, num)))
-      error_exit("failed memory allocate");
-   return pv;
-} // end: alloc_c
-
-
-static void *alloc_r (void *ptr, size_t num) MALLOC;
-static void *alloc_r (void *ptr, size_t num) {
-   void *pv;
-
-   if (!num) ++num;
-   if (!(pv = realloc(ptr, num)))
-      error_exit("failed memory re-allocate");
-   return pv;
-} // end: alloc_r
-
-
-        /*
-         * This routine isolates ALL user INPUT and ensures that we
-         * wont be mixing I/O from stdio and low-level read() requests */
-static int chin (int ech, char *buf, unsigned cnt) {
-   fd_set fs;
-   int rc = -1;
-
-   fflush(stdout);
-#ifdef TERMIOS_ONLY
-   if (ech) {
-      tcsetattr(STDIN_FILENO, TCSAFLUSH, &Tty_tweaked);
-      rc = read(STDIN_FILENO, buf, cnt);
-      tcsetattr(STDIN_FILENO, TCSAFLUSH, &Tty_raw);
-   } else {
-      FD_ZERO(&fs);
-      FD_SET(STDIN_FILENO, &fs);
-      if (0 < select(STDIN_FILENO + 1, &fs, NULL, NULL, NULL))
-         rc = read(STDIN_FILENO, buf, cnt);
-   }
-#else
-   (void)ech;
-   FD_ZERO(&fs);
-   FD_SET(STDIN_FILENO, &fs);
-   if (0 < select(STDIN_FILENO + 1, &fs, NULL, NULL, NULL))
-      rc = read(STDIN_FILENO, buf, cnt);
-#endif
-
-   // zero means EOF, might happen if we erroneously get detached from terminal
-   if (0 == rc) bye_bye(NULL);
-
-   // it may have been the beginning of a lengthy escape sequence
-   tcflush(STDIN_FILENO, TCIFLUSH);
-
-   // note: we do NOT produce a vaid 'string'
-   return rc;
-} // end: chin
-
-
-        /*
-         * Support for single keystroke input AND escaped cursor motion keys
-         * note: we support more keys than we currently need, in case
-         *       we attract new consumers in the future */
-static int keyin (int init) {
-   static char buf12[CAPBUFSIZ], buf13[CAPBUFSIZ]
-      , buf14[CAPBUFSIZ], buf15[CAPBUFSIZ];
-   static struct {
-      const char *str;
-      int key;
-   } tinfo_tab[] = {
-      { "\n", kbd_ENTER    }, { NULL, kbd_UP       }, { NULL, kbd_DOWN     },
-      { NULL, kbd_RIGHT    }, { NULL, kbd_LEFT     }, { NULL, kbd_PGUP     },
-      { NULL, kbd_PGDN     }, { NULL, kbd_END      }, { NULL, kbd_HOME     },
-      { NULL, kbd_BKSP     }, { NULL, kbd_INS      }, { NULL, kbd_DEL      },
-         // next 4 destined to be meta + arrow keys...
-      { buf12, kbd_PGUP    }, { buf13, kbd_PGDN    },
-      { buf14, kbd_END     }, { buf15, kbd_HOME    },
-         // remainder are alternatives for above, just in case
-         // ( the k,j,l,h entries are meta key + vim cursor motion keys )
-      { "\033\\",kbd_UP    }, { "\033/", kbd_DOWN  }, { "\033>", kbd_RIGHT },
-      { "\033<", kbd_LEFT  }, { "\033k", kbd_UP    }, { "\033j", kbd_DOWN  },
-      { "\033l", kbd_RIGHT }, { "\033h", kbd_LEFT  } };
-   char buf[SMLBUFSIZ], *pb;
-   int i;
-
-   if (init) {
-    #define tOk(s)  s ? s : ""
-      tinfo_tab[1].str  = tOk(key_up);
-      tinfo_tab[2].str  = tOk(key_down);
-      tinfo_tab[3].str  = tOk(key_right);
-      tinfo_tab[4].str  = tOk(key_left);
-      tinfo_tab[5].str  = tOk(key_ppage);
-      tinfo_tab[6].str  = tOk(key_npage);
-      tinfo_tab[7].str  = tOk(key_end);
-      tinfo_tab[8].str  = tOk(key_home);
-      tinfo_tab[9].str  = tOk(key_backspace);
-      tinfo_tab[10].str = tOk(key_ic);
-      tinfo_tab[11].str = tOk(key_dc);
-      STRLCPY(buf12, fmtmk("\033%s", tOk(key_up)));
-      STRLCPY(buf13, fmtmk("\033%s", tOk(key_down)));
-      STRLCPY(buf14, fmtmk("\033%s", tOk(key_right)));
-      STRLCPY(buf15, fmtmk("\033%s", tOk(key_left)));
-      // next is critical so returned results match bound terminfo keys
-      putp(tOk(keypad_xmit));
-      return 0;
-    #undef tOk
-   }
-
-   memset(buf, '\0', sizeof(buf));
-   if (1 > chin(0, buf, sizeof(buf)-1)) return 0;
-
-   /* some emulators implement 'key repeat' too well and we get duplicate
-      key sequences -- so we'll focus on the last escaped sequence, while
-      also allowing use of the meta key... */
-   if (!(pb = strrchr(buf, '\033'))) pb = buf;
-   else if (pb > buf && '\033' == *(pb - 1)) --pb;
-
-   for (i = 0; i < MAXTBL(tinfo_tab); i++)
-      if (!strcmp(tinfo_tab[i].str, pb))
-         return tinfo_tab[i].key;
-
-   // no match, so we'll return single keystrokes only
-   if (buf[1]) return 0;
-   return buf[0];
-} // end: keyin
-
-
-#ifdef TERMIOS_ONLY
-        /*
-         * Get line oriented interactive input from the user,
-         * using native tty support */
-static char *linein (const char *prompt) {
-   static char buf[MEDBUFSIZ];
-
-   show_pmt(prompt);
-   memset(buf, '\0', sizeof(buf));
-   chin(1, buf, sizeof(buf)-1);
-   putp(Cap_curs_norm);
-
-   // note: we DO produce a vaid 'string'
-   return strim(buf);
-} // end: linein
-
-#else
-        /*
-         * Get line oriented interactive input from the user,
-         * going way beyond native tty support !
-         * Unlike native tty input support, this function provides:
-         * . true line editing, not just destructive backspace
-         * . an input limit that's sensitive to current screen dimensions
-         * . immediate signal response without the need to wait for '\n' */
-static char *linein (const char *prompt) {
-    // thank goodness memmove allows the two strings to overlap
- #define sqzSTR  { memmove(&buf[pos], &buf[pos+1], bufMAX-pos); \
-       buf[sizeof(buf)-1] = '\0'; }
- #define expSTR  if (len+1 < bufMAX && len+beg+1 < Screen_cols) { \
-       memmove(&buf[pos+1], &buf[pos], bufMAX-pos); buf[pos] = ' '; }
- #define logCOL  (pos+1)
- #define phyCOL  (beg+pos+1)
- #define bufMAX  ((int)sizeof(buf)-2)  // -1 for '\0' string delimeter
-   static char buf[MEDBUFSIZ+1];       // +1 for '\0' string delimeter
-   int beg, pos, len;
-   int key;
-
-   pos = 0;
-   beg = show_pmt(prompt);
-   memset(buf, '\0', sizeof(buf));
-   do {
-      len = strlen(buf);
-      switch (key = keyin(0)) {
-         case kbd_ESC:
-            buf[0] = '\0';             // fall through !
-         case kbd_ENTER:
-            break;
-         case kbd_DEL:
-         case kbd_DOWN:
-            sqzSTR
-            break;
-         case kbd_BKSP :
-            if (0 < pos) { --pos; sqzSTR }
-            break;
-         case kbd_INS:
-         case kbd_UP:
-            expSTR
-            break;
-         case kbd_LEFT:
-            if (0 < pos) --pos;
-            break;
-         case kbd_RIGHT:
-            if (pos < len) ++pos;
-            break;
-         case kbd_HOME:
-            pos = 0;
-            break;
-         case kbd_END:
-            pos = len;
-            break;
-         default:                      // what we REALLY wanted (maybe)
-            if (isprint(key) && logCOL < bufMAX && phyCOL < Screen_cols)
-               buf[pos++] = key;
-            break;
-      }
-      putp(fmtmk("%s%s%s", tg2(beg, Msg_row), Cap_clr_eol, buf));
-      putp(tg2(beg+pos, Msg_row));
-   } while (key && kbd_ENTER != key && kbd_ESC != key);
-
-   return buf;
- #undef sqzSTR
- #undef expSTR
- #undef logCOL
- #undef phyCOL
- #undef bufMAX
-} // end: linein
-#endif
-
-/*######  Small Utility routines  ########################################*/
-
-        /*
-         * Get a float from the user */
-static float get_float (const char *prompt) {
-   char *line;
-   float f;
-
-   if (!(*(line = linein(prompt)))) return -1.0;
-   // note: we're not allowing negative floats
-   if (strcspn(line, "+,.0123456789")) {
-      show_msg("Unacceptable floating point");
-      return -1.0;
-   }
-   sscanf(line, "%f", &f);
-   return f;
-} // end: get_float
-
-
-        /*
-         * Get an integer from the user, returning INT_MIN for error */
-static int get_int (const char *prompt) {
-   char *line;
-   int n;
-
-   if (!(*(line = linein(prompt)))) return INT_MIN;
-   // note: we've got to allow negative ints (renice)
-   if (strcspn(line, "-+0123456789")) {
-      show_msg("Unacceptable integer");
-      return INT_MIN;
-   }
-   sscanf(line, "%d", &n);
-   return n;
-} // end: get_int
-
-
-        /*
-         * Do some scaling stuff.
-         * We'll interpret 'num' as one of the following types and
-         * try to format it to fit 'width'.
-         *    SK_no (0) it's a byte count
-         *    SK_Kb (1) it's kilobytes
-         *    SK_Mb (2) it's megabytes
-         *    SK_Gb (3) it's gigabytes
-         *    SK_Tb (4) it's terabytes  */
-static const char *scale_num (unsigned long num, const int width, const int type) {
-      // kilobytes, megabytes, gigabytes, terabytes, duh!
-   static double scale[] = { 1024.0, 1024.0*1024, 1024.0*1024*1024, 1024.0*1024*1024*1024, 0 };
-      // kilo, mega, giga, tera, none
-#ifdef CASEUP_SUFIX
-   static char nextup[] =  { 'K', 'M', 'G', 'T', 0 };
-#else
-   static char nextup[] =  { 'k', 'm', 'g', 't', 0 };
-#endif
-   static char buf[SMLBUFSIZ];
-   double *dp;
-   char *up;
-
-   // try an unscaled version first...
-   if (width >= snprintf(buf, sizeof(buf), "%lu", num)) return buf;
-
-   // now try successively higher types until it fits
-   for (up = nextup + type, dp = scale; 0 < *dp; ++dp, ++up) {
-      // the most accurate version
-      if (width >= snprintf(buf, sizeof(buf), "%.1f%c", num / *dp, *up))
-         return buf;
-      // the integer version
-      if (width >= snprintf(buf, sizeof(buf), "%lu%c", (unsigned long)(num / *dp), *up))
-         return buf;
-   }
-   // well shoot, this outta' fit...
-   return "?";
-} // end: scale_num
-
-
-        /*
-         * Do some scaling stuff.
-         * format 'tics' to fit 'width'. */
-static const char *scale_tics (TIC_t tics, const int width) {
-#ifdef CASEUP_SUFIX
- #define HH "%uH"
- #define DD "%uD"
- #define WW "%uW"
-#else
- #define HH "%uh"
- #define DD "%ud"
- #define WW "%uw"
-#endif
-   static char buf[SMLBUFSIZ];
-   unsigned long nt;    // narrow time, for speed on 32-bit
-   unsigned cc;         // centiseconds
-   unsigned nn;         // multi-purpose whatever
-
-   nt  = (tics * 100ull) / Hertz;               // up to 68 weeks of cpu time
-   cc  = nt % 100;                              // centiseconds past second
-   nt /= 100;                                   // total seconds
-   nn  = nt % 60;                               // seconds past the minute
-   nt /= 60;                                    // total minutes
-   if (width >= snprintf(buf, sizeof(buf), "%lu:%02u.%02u", nt, nn, cc))
-      return buf;
-   if (width >= snprintf(buf, sizeof(buf), "%lu:%02u", nt, nn))
-      return buf;
-   nn  = nt % 60;                               // minutes past the hour
-   nt /= 60;                                    // total hours
-   if (width >= snprintf(buf, sizeof(buf), "%lu,%02u", nt, nn))
-      return buf;
-   nn = nt;                                     // now also hours
-   if (width >= snprintf(buf, sizeof(buf), HH, nn))
-      return buf;
-   nn /= 24;                                    // now days
-   if (width >= snprintf(buf, sizeof(buf), DD, nn))
-      return buf;
-   nn /= 7;                                     // now weeks
-   if (width >= snprintf(buf, sizeof(buf), WW, nn))
-      return buf;
-      // well shoot, this outta' fit...
-   return "?";
- #undef HH
- #undef DD
- #undef WW
-} // end: scale_tics
-
-
-        /*
-         * Validate the passed string as a user name or number,
-         * and/or update the window's 'u/U' selection stuff. */
-static const char *user_certify (WIN_t *q, const char *str, char typ) {
-   struct passwd *pwd;
-   char *endp;
-   uid_t num;
-
-   q->usrseltyp = 0;
-   Monpidsidx = 0;
-   if (*str) {
-      num = (uid_t)strtoul(str, &endp, 0);
-      if ('\0' == *endp)
-         pwd = getpwuid(num);
-      else
-         pwd = getpwnam(str);
-      if (!pwd) return "Invalid user";
-      q->usrseluid = pwd->pw_uid;
-      q->usrseltyp = typ;
-   }
-   return NULL;
-} // end: user_certify
-
-
-        /*
-         * Determine if this proc_t matches the 'u/U' selection criteria
-         * for a given window -- it's called from only one place, and
-         * likely inlined even without the directive */
-static inline int user_matched (WIN_t *q, const proc_t *p) {
-   switch(q->usrseltyp) {
-      case 0:                                    // uid selection inactive
-         return 1;
-      case 'U':                                  // match any uid
-         if (p->ruid == q->usrseluid) return 1;
-         if (p->suid == q->usrseluid) return 1;
-         if (p->fuid == q->usrseluid) return 1;
-      // fall through...
-      case 'u':                                  // match effective uid
-         if (p->euid == q->usrseluid) return 1;
-      // fall through...
-      default:                                   // no match, don't display
-         ;
-   }
-   return 0;
-} // end: user_matched
-
-/*######  Fields Management support  #####################################*/
-
-   /* These are the Fieldstab.lflg values used here and in calibrate_fields.
-      (own identifiers as documentation and protection against changes) */
-#define L_stat     PROC_FILLSTAT
-#define L_statm    PROC_FILLMEM
-#define L_status   PROC_FILLSTATUS
-#define L_CGROUP   PROC_EDITCGRPCVT | PROC_FILLCGROUP
-#define L_CMDLINE  PROC_EDITCMDLCVT | PROC_FILLARG
-#define L_EUSER    PROC_FILLUSR
-#define L_OUSER    PROC_FILLSTATUS | PROC_FILLUSR
-#define L_EGROUP   PROC_FILLSTATUS | PROC_FILLGRP
-#define L_SUPGRP   PROC_FILLSTATUS | PROC_FILLSUPGRP
-   // make 'none' non-zero (used to be important to Frames_libflags)
-#define L_NONE     PROC_SPARE_1
-   // from either 'stat' or 'status' (preferred), via bits not otherwise used
-#define L_EITHER   PROC_SPARE_2
-   // for calibrate_fields and summary_show 1st pass
-#define L_DEFAULT  PROC_FILLSTAT
-
-        /* These are our gosh darn 'Fields' !
-           They MUST be kept in sync with pflags !!
-           note: for integer data, the length modifiers found in .fmts may
-                 NOT reflect the true field type found in proc_t -- this plus
-                 a cast when/if displayed provides minimal width protection. */
-static FLD_t Fieldstab[] = {
-   // a temporary macro, soon to be undef'd...
- #define SF(f) (QFP_t)SCB_NAME(f)
-
-/* .head + .fmts anomolies:
-        entries shown with NULL are either valued at runtime (see zap_fieldstab)
-        or, in the case of .fmts, may represent variable width fields
-   .lflg anomolies:
-        P_UED, L_NONE  - natural outgrowth of 'stat()' in readproc        (euid)
-        P_CPU, L_stat  - never filled by libproc, but requires times      (pcpu)
-        P_CMD, L_stat  - may yet require L_CMDLINE in calibrate_fields    (cmd/cmdline)
-        L_EITHER       - must L_status, else L_stat == 64-bit math (__udivdi3) on 32-bit !
-     .head          .fmts     .width  .scale  .sort     .lflg      .desc
-     ------------   --------  ------  ------  --------  --------   ---------------------- */
-   { NULL,          NULL,        -1,     -1,  SF(PID),  L_NONE,    "Process Id"           },
-   { NULL,          NULL,        -1,     -1,  SF(PPD),  L_EITHER,  "Parent Process pid"   },
-   { "  UID ",      "%5d ",      -1,     -1,  SF(UED),  L_NONE,    "Effective User Id"    },
-   { "USER     ",   "%-8.8s ",   -1,     -1,  SF(UEN),  L_EUSER,   "Effective User Name"  },
-   { " RUID ",      "%5d ",      -1,     -1,  SF(URD),  L_status,  "Real User Id"         },
-   { "RUSER    ",   "%-8.8s ",   -1,     -1,  SF(URN),  L_OUSER,   "Real User Name"       },
-   { " SUID ",      "%5d ",      -1,     -1,  SF(USD),  L_status,  "Saved User Id"        },
-   { "SUSER    ",   "%-8.8s ",   -1,     -1,  SF(USN),  L_OUSER,   "Saved User Name"      },
-   { "  GID ",      "%5d ",      -1,     -1,  SF(GID),  L_NONE,    "Group Id"             },
-   { "GROUP    ",   "%-8.8s ",   -1,     -1,  SF(GRP),  L_EGROUP,  "Group Name"           },
-   { NULL,          NULL,        -1,     -1,  SF(PGD),  L_stat,    "Process Group Id"     },
-   { "TTY      ",   "%-8.8s ",    8,     -1,  SF(TTY),  L_stat,    "Controlling Tty"      },
-   { NULL,          NULL,        -1,     -1,  SF(TPG),  L_stat,    "Tty Process Grp Id"   },
-   { NULL,          NULL,        -1,     -1,  SF(SID),  L_stat,    "Session Id"           },
-   { " PR ",        "%3d ",      -1,     -1,  SF(PRI),  L_stat,    "Priority"             },
-   { " NI ",        "%3d ",      -1,     -1,  SF(NCE),  L_stat,    "Nice Value"           },
-   { "nTH ",        "%3d ",      -1,     -1,  SF(THD),  L_EITHER,  "Number of Threads"    },
-   { NULL,          NULL,        -1,     -1,  SF(CPN),  L_stat,    "Last Used Cpu (SMP)"  },
-   { " %CPU ",      NULL,        -1,     -1,  SF(CPU),  L_stat,    "CPU Usage"            },
-   { "  TIME ",     "%6.6s ",     6,     -1,  SF(TME),  L_stat,    "CPU Time"             },
-   { "   TIME+  ",  "%9.9s ",     9,     -1,  SF(TME),  L_stat,    "CPU Time, hundredths" },
-   { "%MEM ",       "%#4.1f ",   -1,     -1,  SF(RES),  L_statm,   "Memory Usage (RES)"   },
-   { " VIRT ",      "%5.5s ",     5,  SK_Kb,  SF(VRT),  L_statm,   "Virtual Image (kb)"   },
-   { "SWAP ",       "%4.4s ",     4,  SK_Kb,  SF(SWP),  L_status,  "Swapped Size (kb)"    },
-   { " RES ",       "%4.4s ",     4,  SK_Kb,  SF(RES),  L_statm,   "Resident Size (kb)"   },
-   { "CODE ",       "%4.4s ",     4,  SK_Kb,  SF(COD),  L_statm,   "Code Size (kb)"       },
-   { "DATA ",       "%4.4s ",     4,  SK_Kb,  SF(DAT),  L_statm,   "Data+Stack Size (kb)" },
-   { " SHR ",       "%4.4s ",     4,  SK_Kb,  SF(SHR),  L_statm,   "Shared Mem Size (kb)" },
-   { "nMaj ",       "%4.4s ",     4,  SK_no,  SF(FL1),  L_stat,    "Major Page Faults"    },
-   { "nMin ",       "%4.4s ",     4,  SK_no,  SF(FL2),  L_stat,    "Minor Page Faults"    },
-   { "nDRT ",       "%4.4s ",     4,  SK_no,  SF(DRT),  L_statm,   "Dirty Pages Count"    },
-   { "S ",          "%c ",       -1,     -1,  SF(STA),  L_EITHER,  "Process Status"       },
-   // next 2 entries are special: '.head' is variable width (see calibrate_fields)
-   { "COMMAND  ",   NULL,        -1,     -1,  SF(CMD),  L_EITHER,  "Command Name/Line"    },
-   { "WCHAN    ",   NULL,        -1,     -1,  SF(WCH),  L_stat,    "Sleeping in Function" },
-   // next entry's special: the 0's will be replaced with '.'!
-#ifdef CASEUP_HEXES
-   { "Flags    ",   "%08lX ",    -1,     -1,  SF(FLG),  L_stat,    "Task Flags <sched.h>" },
-#else
-   { "Flags    ",   "%08lx ",    -1,     -1,  SF(FLG),  L_stat,    "Task Flags <sched.h>" },
-#endif
-   // next 3 entries as P_CMD/P_WCH: '.head' must be same length -- they share varcolsz
-   { "CGROUPS  ",   NULL,        -1,     -1,  SF(CGR),  L_CGROUP,  "Control Groups"       },
-   { "SUPGIDS  ",   NULL,        -1,     -1,  SF(SGD),  L_status,  "Supp Groups IDs"      },
-   { "SUPGRPS  ",   NULL,        -1,     -1,  SF(SGN),  L_SUPGRP,  "Supp Groups Names"    },
-   { NULL,          NULL,        -1,     -1,  SF(TGD),  L_status,  "Thread Group Id"      }
-#ifdef OOMEM_ENABLE
-#define L_oom      PROC_FILLOOM
-  ,{ "Adj ",        "%3d ",      -1,     -1,  SF(OOA),  L_oom,     "oom_adjustment (2^X)" }
-  ,{ " Badness ",   "%8d ",      -1,     -1,  SF(OOM),  L_oom,     "oom_score (badness)"  }
-#undef L_oom
-#endif
- #undef SF
-};
-
-
-        /*
-         * A calibrate_fields() *Helper* function to refresh the
-         * cached screen geometry and related variables */
-static void adj_geometry (void) {
-   static size_t pseudo_max = 0;
-   static int w_set = 0, w_cols = 0, w_rows = 0;
-   struct winsize wz;
-
-   Screen_cols = columns;    // <term.h>
-   Screen_rows = lines;      // <term.h>
-
-   if (-1 != ioctl(STDOUT_FILENO, TIOCGWINSZ, &wz)
-   && 0 < wz.ws_col && 0 < wz.ws_row) {
-      Screen_cols = wz.ws_col;
-      Screen_rows = wz.ws_row;
-   }
-
-#ifndef RMAN_IGNORED
-   // be crudely tolerant of crude tty emulators
-   if (Cap_avoid_eol) Screen_cols--;
-#endif
-
-   // we might disappoint some folks (but they'll deserve it)
-   if (SCREENMAX < Screen_cols) Screen_cols = SCREENMAX;
-
-   if (!w_set) {
-      if (Width_mode > 0)              // -w with arg, we'll try to honor
-         w_cols = Width_mode;
-      else
-      if (Width_mode < 0) {            // -w without arg, try environment
-         char *env_columns = getenv("COLUMNS"),
-              *env_lines = getenv("LINES"),
-              *ep;
-         if (env_columns && *env_columns) {
-            long t, tc = 0;
-            t = strtol(env_columns, &ep, 0);
-            if (!*ep && (t > 0) && (t <= 0x7fffffffL)) tc = t;
-            if (0 < tc) w_cols = (int)tc;
-         }
-         if (env_lines && *env_lines) {
-            long t, tr = 0;
-            t = strtol(env_lines, &ep, 0);
-            if (!*ep && (t > 0) && (t <= 0x7fffffffL)) tr = t;
-            if (0 < tr) w_rows = (int)tr;
-         }
-         if (!w_cols) w_cols = SCREENMAX;
-         if (w_cols && w_cols < W_MIN_COL) w_cols = W_MIN_COL;
-         if (w_rows && w_rows < W_MIN_ROW) w_rows = W_MIN_ROW;
-      }
-      w_set = 1;
-   }
-
-   /* keep our support for output optimization in sync with current reality
-      note: when we're in Batch mode, we don't really need a Pseudo_screen
-            and when not Batch, our buffer will contain 1 extra 'line' since
-            Msg_row is never represented -- but it's nice to have some space
-            between us and the great-beyond... */
-   if (Batch) {
-      if (w_cols) Screen_cols = w_cols;
-      Screen_rows = w_rows ? w_rows : MAXINT;
-      Pseudo_size = (sizeof(*Pseudo_screen) * ROWMAXSIZ);
-   } else {
-      if (w_cols && w_cols < Screen_cols) Screen_cols = w_cols;
-      if (w_rows && w_rows < Screen_rows) Screen_rows = w_rows;
-      Pseudo_size = (sizeof(*Pseudo_screen) * ROWMAXSIZ) * Screen_rows;
-   }
-   // we'll only grow our Pseudo_screen, never shrink it
-   if (pseudo_max < Pseudo_size) {
-      pseudo_max = Pseudo_size;
-      Pseudo_screen = alloc_r(Pseudo_screen, pseudo_max);
-   }
-   PSU_CLREOS(0);
-   if (Frames_resize) putp(Cap_clr_scr);
-} // end: adj_geometry
-
-
-        /*
-         * After ensuring the intergrity of our cached screen dimensions,
-         * via adj_geometry(), for each visible window:
-         *    1) Set the number of fields/columns to display
-         *    2) Create the field columns heading
-         *    3) Set maximum width for any variable columns, if in use
-         * In the process, the required PROC_FILLxxx flags will be rebuilt! */
-static void calibrate_fields (void) {
-   sigset_t newss, oldss;
-   FLG_t f;
-   char *s;
-   const char *h;
-   WIN_t *w = Curwin;
-#ifdef EQUCOLHDRYES
-   int x, hdrmax = 0;
-#endif
-   int i, needpsdb = 0;
-   int varcolcnt;
-
-   // block SIGWINCH signals while we do our thing...
-   sigemptyset(&newss);
-   sigaddset(&newss, SIGWINCH);
-   if (-1 == sigprocmask(SIG_BLOCK, &newss, &oldss))
-      error_exit(fmtmk("failed sigprocmask, SIG_BLOCK: %s", strerror(errno)));
-
-   adj_geometry();
-   Frames_libflags = 0;
-
-   do {
-      if (VIZISw(w)) {
-         w->hdrcaplen = 0;   // really only used with USE_X_COLHDR
-         // build window's pflgsall array, establish upper bounds for maxpflgs
-         for (i = 0, w->totpflgs = 0; i < P_MAXPFLGS; i++) {
-            if (FLDviz(w, i)) {
-               f = FLDget(w, i);
-#ifdef USE_X_COLHDR
-               w->pflgsall[w->totpflgs++] = f;
-#else
-               if (CHKw(w, Show_HICOLS) && f == w->rc.sortindx) {
-                  w->pflgsall[w->totpflgs++] = X_XON;
-                  w->pflgsall[w->totpflgs++] = f;
-                  w->pflgsall[w->totpflgs++] = X_XOF;
-               } else
-                  w->pflgsall[w->totpflgs++] = f;
-#endif
-            }
-         }
-
-         /* build a preliminary columns header not to exceed screen width
-            while accounting for a possible leading window number */
-         w->varcolsz = varcolcnt = 0;
-         *(s = w->columnhdr) = '\0';
-         if (Rc.mode_altscr) s = scat(s, " ");
-         for (i = 0; i + w->begpflg < w->totpflgs; i++) {
-            f = w->pflgsall[i + w->begpflg];
-            w->procflgs[i] = f;
-#ifndef USE_X_COLHDR
-            if (P_MAXPFLGS <= f) continue;
-#endif
-            h = Fieldstab[f].head;
-            // oops, won't fit -- we're outta here...
-            if (Screen_cols < ((int)(s - w->columnhdr) + (int)strlen(h))) break;
-            if (!Fieldstab[f].fmts) { ++varcolcnt; w->varcolsz += strlen(h) - 1; }
-            s = scat(s, h);
-         }
-#ifndef USE_X_COLHDR
-         if (X_XON == w->procflgs[i - 1]) --i;
-#endif
-
-         /* establish the final maxpflgs and prepare to grow the variable column
-            heading(s) via varcolsz - it may be a fib if their pflags weren't
-            encountered, but that's ok because they won't be displayed anyway */
-         w->maxpflgs = i;
-         w->varcolsz += Screen_cols - strlen(w->columnhdr);
-         if (varcolcnt) w->varcolsz = w->varcolsz / varcolcnt;
-
-         /* establish the field where all remaining fields would still
-            fit within screen width, including a leading window number */
-         *(s = w->columnhdr) = '\0';
-         if (Rc.mode_altscr) s = scat(s, " ");
-         for (i = w->totpflgs - 1; -1 < i; i--) {
-            f = w->pflgsall[i];
-#ifndef USE_X_COLHDR
-            if (P_MAXPFLGS < f) { w->endpflg = i; continue; }
-#endif
-            h = Fieldstab[f].head;
-            if (Screen_cols < ((int)(s - w->columnhdr) + (int)strlen(h))) break;
-            s = scat(s, h);
-            w->endpflg = i;
-         }
-#ifndef USE_X_COLHDR
-         if (X_XOF == w->pflgsall[w->endpflg]) ++w->endpflg;
-#endif
-
-         /* finally, we can build the true run-time columns header, format any
-            variable column heading(s), if they're really being displayed, and
-            rebuild the all-important PROC_FILLxxx flags that will be used
-            until/if we're we're called again */
-         memset((s = w->columnhdr), 0, sizeof(w->columnhdr));
-         if (Rc.mode_altscr) s = scat(s, fmtmk("%d", w->winnum));
-         for (i = 0; i < w->maxpflgs; i++) {
-            f = w->procflgs[i];
-#ifdef USE_X_COLHDR
-            if (CHKw(w, Show_HICOLS) && f == w->rc.sortindx) {
-               s = scat(s, fmtmk("%s%s", Caps_off, w->capclr_msg));
-               w->hdrcaplen += strlen(Caps_off) + strlen(w->capclr_msg);
-            }
-#else
-            if (P_MAXPFLGS <= f) continue;
-#endif
-            h = Fieldstab[f].head;
-            if (P_WCH == f) needpsdb = 1;
-            if (P_CMD == f && CHKw(w, Show_CMDLIN)) Frames_libflags |= L_CMDLINE;
-            if (Fieldstab[f].fmts) s = scat(s, h);
-            else s = scat(s, fmtmk(VARCOL_fmts, w->varcolsz, w->varcolsz, h));
-            Frames_libflags |= Fieldstab[w->procflgs[i]].lflg;
-#ifdef USE_X_COLHDR
-            if (CHKw(w, Show_HICOLS) && f == w->rc.sortindx) {
-               s = scat(s, fmtmk("%s%s", Caps_off, w->capclr_hdr));
-               w->hdrcaplen += strlen(Caps_off) + strlen(w->capclr_hdr);
-            }
-#endif
-         }
-#ifdef EQUCOLHDRYES
-         // prepare to even out column header lengths...
-         if (hdrmax + w->hdrcaplen < (x = strlen(w->columnhdr))) hdrmax = x - w->hdrcaplen;
-         // must sacrifice last header positon to avoid task row abberations
-         w->eolcap = Caps_endline;
-#else
-         if (Screen_cols > (int)strlen(w->columnhdr)) w->eolcap = Caps_endline;
-         else w->eolcap = Caps_off;
-#endif
-         // with forest view mode, we'll need tgid & ppid...
-         if (CHKw(w, Show_FOREST)) Frames_libflags |= L_status;
-         // for 'busy' only processes, we'll need pcpu (utime & stime)...
-         if (!CHKw(w, Show_IDLEPS)) Frames_libflags |= L_stat;
-         // we must also accommodate an out of view sort field...
-         f = w->rc.sortindx;
-         Frames_libflags |= Fieldstab[f].lflg;
-         if (P_CMD == f && CHKw(w, Show_CMDLIN)) Frames_libflags |= L_CMDLINE;
-      } // end: VIZISw(w)
-
-      if (Rc.mode_altscr) w = w->next;
-   } while (w != Curwin);
-
-#ifdef EQUCOLHDRYES
-   /* now we can finally even out column header lengths
-      (we're assuming entire columnhdr was memset to '\0') */
-   if (Rc.mode_altscr && SCREENMAX > Screen_cols)
-      for (i = 0; i < GROUPSMAX; i++) {
-         w = &Winstk[i];
-         if (CHKw(w, Show_TASKON))
-            if (hdrmax + w->hdrcaplen > (x = strlen(w->columnhdr)))
-               memset(&w->columnhdr[x], ' ', hdrmax + w->hdrcaplen - x);
-      }
-#endif
-
-   // do we need the kernel symbol table (and is it already open?)
-   if (needpsdb) {
-      if (-1 == No_ksyms) {
-         No_ksyms = 0;
-         if (open_psdb_message(NULL, msg_save))
-            No_ksyms = 1;
-         else
-            PSDBopen = 1;
-      }
-   }
-
-   // finalize/touchup the libproc PROC_FILLxxx flags for current config...
-   if ((Frames_libflags & L_EITHER) && !(Frames_libflags & L_stat))
-      Frames_libflags |= L_status;
-   if (!Frames_libflags) Frames_libflags = L_DEFAULT;
-   if (Monpidsidx) Frames_libflags |= PROC_PID;
-
-   Frames_resize = 0;
-   if (-1 == sigprocmask(SIG_SETMASK, &oldss, NULL))
-      error_exit(fmtmk("failed sigprocmask, SIG_SETMASK: %s", strerror(errno)));
-} // end: calibrate_fields
-
-
-        /*
-         * Display each field represented in the current window's fieldscur
-         * array along with its description.  Mark with bold and a leading
-         * asterisk those fields associated with the "on" or "active" state.
-         *
-         * Special highlighting will be accorded the "focus" field with such
-         * highlighting potentially extended to include the description.
-         *
-         * Below is the current Fieldstab space requirement and how
-         * we apportion it.  The xSUFX is considered sacrificial,
-         * something we can reduce or do without.
-         *            0        1         2         3
-         *            12345678901234567890123456789012
-         *            * HEADING = Longest Description!
-         *      xPRFX ----------______________________ xSUFX
-         *    ( xPRFX has pos 2 & 10 for 'extending' when at minimums )
-         *
-         * The first 4 screen rows are reserved for explanatory text.
-         * Thus, with our current 39 fields, a maximum of 6 columns and
-         * 1 space between columns, a tty will still remain useable under
-         * these extremes:
-         *            rows  cols   displayed
-         *            ----  ----   ------------------
-         *             11    66    xPRFX only          (w/ room for +3)
-         *             11   198    full xPRFX + xSUFX  (w/ room for +3)
-         *             24    22    xPRFX only          (w/ room for +1)
-         *             24    66    full xPRFX + xSUFX  (w/ room for +1)
-         *    ( if not, the user deserves our most cryptic messages )
-         */
-static void display_fields (int focus, int extend) {
- #define mxCOL  6
- #define yRSVD  4
- #define xSUFX  22
- #define xPRFX (10 + xadd)
- #define xTOTL (xPRFX + xSUFX)
-   WIN_t *w = Curwin;                  // avoid gcc bloat with a local copy
-   int i;                              // utility int (a row, tot cols, ix)
-   int smax;                           // printable width of xSUFX
-   int xadd = 0;                       // spacing between data columns
-   int cmax = Screen_cols;             // total data column width
-   int rmax = Screen_rows - yRSVD;     // total useable rows
-
-   fflush(stdout);
-   i = (P_MAXPFLGS % mxCOL) ? 1 : 0;
-   if (rmax < i + (P_MAXPFLGS / mxCOL)) error_exit("++rows");
-   i = P_MAXPFLGS / rmax;
-   if (P_MAXPFLGS % rmax) ++i;
-   if (i > 1) { cmax /= i; xadd = 1; }
-   if (cmax > xTOTL) cmax = xTOTL;
-   smax = cmax - xPRFX;
-   if (smax < 0) error_exit("++cols");
-
-   for (i = 0; i < P_MAXPFLGS; ++i) {
-      char sbuf[xSUFX+1];
-      int b = FLDviz(w, i);
-      FLG_t f = FLDget(w, i);
-      const char *h, *e = (i == focus && extend) ? w->capclr_msg : "";
-
-      // advance past leading header spaces and prep sacrificial suffix
-      for (h = Fieldstab[f].head; ' ' == *h; ++h) ;
-      snprintf(sbuf, sizeof(sbuf), "= %s", Fieldstab[f].desc);
-
-      PUTT("%s%c%s%s %s%-7.7s%s%s%s %-*.*s%s"
-         , tg2((i / rmax) * cmax, (i % rmax) + yRSVD)
-         , b ? '*' : ' '
-         , b ? w->cap_bold : Cap_norm
-         , e
-         , i == focus ? w->capclr_msg : ""
-         , h
-         , Cap_norm
-         , b ? w->cap_bold : ""
-         , e
-         , smax, smax
-         , sbuf
-         , Cap_norm);
-   }
-
-   putp(Caps_off);
- #undef mxCOL
- #undef yRSVD
- #undef xSUFX
- #undef xPRFX
- #undef xTOTL
-} // end: display_fields
-
-
-        /*
-         * Manage all fields aspects (order/toggle/sort), for all windows. */
-static void fields_utility (void) {
- #define unSCRL  w->begpflg = 0;
- #define swapEM  { char c; unSCRL; c = w->rc.fieldscur[i]; \
-       w->rc.fieldscur[i] = *p; *p = c; p = &w->rc.fieldscur[i]; }
- #define spewFI  { char *t; f = w->rc.sortindx; t = strchr(w->rc.fieldscur, f + FLD_OFFSET); \
-       if (!t) t = strchr(w->rc.fieldscur, (f + FLD_OFFSET) | 0x80); \
-       i = (t) ? (int)(t - w->rc.fieldscur) : 0; }
-   WIN_t *w = Curwin;             // avoid gcc bloat with a local copy
-   const char *h = NULL;
-   char *p = NULL;
-   int i, key;
-   FLG_t f;
-
-   putp(Cap_clr_scr);
-   spewFI
-
-   do {
-      // advance past leading spaces, if any
-      if (!h) for (h = Fieldstab[f].head; ' ' == *h; ++h) ;
-      display_fields(i, (p != NULL));
-      putp(Cap_home);
-      show_special(1, fmtmk(FIELDS_heading, w->grpname, CHKw(w, Show_FOREST) ? "forest view" : h));
-
-      switch (key = keyin(0)) {
-         case kbd_UP:
-            if (i > 0) { --i; if (p) swapEM }
-            break;
-         case kbd_DOWN:
-            if (i + 1 < P_MAXPFLGS) { ++i; if (p) swapEM }
-            break;
-         case kbd_LEFT:
-         case kbd_ENTER:
-            p = NULL;
-            break;
-         case kbd_RIGHT:
-            p = &w->rc.fieldscur[i];
-            break;
-         case kbd_HOME:
-         case kbd_PGUP:
-            if (!p) i = 0;
-            break;
-         case kbd_END:
-         case kbd_PGDN:
-            if (!p) i = P_MAXPFLGS - 1;
-            break;
-         case kbd_SPACE:
-         case 'd':
-            if (!p) { FLDtog(w, i); unSCRL }
-            break;
-         case 's':
-#ifdef TREE_NORESET
-            if (!p && !CHKw(w, Show_FOREST)) { w->rc.sortindx = f = FLDget(w, i); h = NULL; unSCRL }
-#else
-            if (!p) { w->rc.sortindx = f = FLDget(w, i); h = NULL; unSCRL; OFFw(w, Show_FOREST); }
-#endif
-            break;
-         case 'a':
-         case 'w':
-            Curwin = w = ('a' == key) ? w->next : w->prev;
-            spewFI
-            p = NULL;
-            h = NULL;
-            break;
-         default:                 // keep gcc happy
-            break;
-      }
-   } while (key && 'q' != key && kbd_ESC != key);
- #undef unSCRL
- #undef swapEM
- #undef spewFI
-} // end: fields_utility
-
-
-        /*
-         * This routine exists just to consolidate all the messin' around
-         * with Fieldstab '.head' and '.fmts' members -- until we devise
-         * a more elegant soultion. */
-static void zap_fieldstab (void) {
-   static char fmts_pid[8];
-   static char fmts_cpu[8];
-   static int once;
-   unsigned digits;
-   char buf[8];
-
-   if (once) goto always;
-
-   Fieldstab[P_PID].head = "  PID ";
-   Fieldstab[P_PID].fmts = "%5d ";
-   Fieldstab[P_PPD].head = " PPID ";
-   Fieldstab[P_PPD].fmts = "%5d ";
-   Fieldstab[P_PGD].head = " PGRP ";
-   Fieldstab[P_PGD].fmts = "%5d ";
-   Fieldstab[P_SID].head = "  SID ";
-   Fieldstab[P_SID].fmts = "%5d ";
-   Fieldstab[P_TGD].head = " TGID ";
-   Fieldstab[P_TGD].fmts = "%5d ";
-   Fieldstab[P_TPG].head = "TPGID ";
-   Fieldstab[P_TPG].fmts = "%5d ";
-   if (5 < (digits = get_pid_digits())) {
-      if (10 < digits) error_exit("failed pid size test");
-      snprintf(fmts_pid, sizeof(fmts_pid), "%%%uu ", digits);
-      Fieldstab[P_PID].head = "       PID " + 10 - digits;
-      Fieldstab[P_PID].fmts = fmts_pid;
-      Fieldstab[P_PPD].head = "      PPID " + 10 - digits;
-      Fieldstab[P_PPD].fmts = fmts_pid;
-      Fieldstab[P_PGD].head = "      PGRP " + 10 - digits;
-      Fieldstab[P_PGD].fmts = fmts_pid;
-      Fieldstab[P_SID].head = "       SID " + 10 - digits;
-      Fieldstab[P_SID].fmts = fmts_pid;
-      Fieldstab[P_TGD].head = "      TGID " + 10 - digits;
-      Fieldstab[P_TGD].fmts = fmts_pid;
-      Fieldstab[P_TPG].head = "     TPGID " + 10 - digits;
-      Fieldstab[P_TPG].fmts = fmts_pid;
-   }
-   once = 1;
-
-   /*** hotplug_acclimated ***/
-always:
-   Fieldstab[P_CPN].head = "P ";
-   Fieldstab[P_CPN].fmts = "%1d ";
-   if (1 < (digits = (unsigned)snprintf(buf, sizeof(buf), "%u", (unsigned)Cpu_tot))) {
-      if (5 < digits) error_exit("failed num cpus test");
-      snprintf(fmts_cpu, sizeof(fmts_cpu), "%%%ud ", digits);
-      Fieldstab[P_CPN].head = "    P " + 5 - digits;
-      Fieldstab[P_CPN].fmts = fmts_cpu;
-   }
-
-   Cpu_pmax = 99.9;
-   Fieldstab[P_CPU].fmts = " %#4.1f ";
-   if (Rc.mode_irixps && Cpu_tot > 1 && !Thread_mode) {
-      Cpu_pmax = 100.0 * Cpu_tot;
-      if (Cpu_tot > 10) {
-         if (Cpu_pmax > 99999.0) Cpu_pmax = 99999.0;
-         Fieldstab[P_CPU].fmts = "%5.0f ";
-      } else {
-         if (Cpu_pmax > 999.9) Cpu_pmax = 999.9;
-         Fieldstab[P_CPU].fmts = "%#5.1f ";
-      }
-   }
-
-   // lastly, ensure we've got proper column headers...
-   calibrate_fields();
-} // end: zap_fieldstab
-
-/*######  Library Interface  #############################################*/
-
-        /*
-         * This guy's modeled on libproc's 'five_cpu_numbers' function except
-         * we preserve all cpu data in our CPU_t array which is organized
-         * as follows:
-         *    cpus[0] thru cpus[n] == tics for each separate cpu
-         *    cpus[Cpu_tot]        == tics from the 1st /proc/stat line */
-static CPU_t *cpus_refresh (CPU_t *cpus) {
-   static const char err_read[] = "failed /proc/stat read";
-   static FILE *fp = NULL;
-   static int sav_cpus = -1;
-   char buf[MEDBUFSIZ]; // enough for /proc/stat CPU line (not the intr line)
-   int i;
-
-   /*** hotplug_acclimated ***/
-   if (sav_cpus != smp_num_cpus) {
-      Cpu_tot = sav_cpus = smp_num_cpus;
-      zap_fieldstab();
-      if (fp) { fclose(fp); fp = NULL; }
-      if (cpus) { free(cpus); cpus = NULL; }
-   }
-
-   /* by opening this file once, we'll avoid the hit on minor page faults
-      (sorry Linux, but you'll have to close it for us) */
-   if (!fp) {
-      if (!(fp = fopen("/proc/stat", "r")))
-         error_exit(fmtmk("failed /proc/stat open: %s", strerror(errno)));
-      /* note: we allocate one more CPU_t than Cpu_tot so that the last slot
-               can hold tics representing the /proc/stat cpu summary (the first
-               line read) -- that slot supports our View_CPUSUM toggle */
-      cpus = alloc_c((1 + Cpu_tot) * sizeof(CPU_t));
-   }
-   rewind(fp);
-   fflush(fp);
-
-   // first value the last slot with the cpu summary line
-   cpus[Cpu_tot].x = cpus[Cpu_tot].y = cpus[Cpu_tot].z = 0;
-   // FIXME: can't tell above by kernel version number
-   if (!fgets(buf, sizeof(buf), fp)) error_exit(err_read);
-   if (4 > sscanf(buf, "cpu %Lu %Lu %Lu %Lu %Lu %Lu %Lu %Lu"
-      , &cpus[Cpu_tot].u, &cpus[Cpu_tot].n, &cpus[Cpu_tot].s, &cpus[Cpu_tot].i
-      , &cpus[Cpu_tot].w, &cpus[Cpu_tot].x, &cpus[Cpu_tot].y, &cpus[Cpu_tot].z))
-         error_exit(err_read);
-   // and just in case we're 2.2.xx compiled without SMP support...
-   if (1 == Cpu_tot)
-      memcpy(cpus, &cpus[1], sizeof(CPU_t));
-   // now value each separate cpu's tics
-   for (i = 0; i < Cpu_tot; i++) {
-#ifdef PRETEND4CPUS
-      rewind(fp);
-      fgets(buf, sizeof(buf), fp);
-#endif
-      if (!fgets(buf, sizeof(buf), fp)) error_exit(err_read);
-      cpus[i].x = cpus[i].y = cpus[i].z = 0;
-      // FIXME: can't tell above by kernel version number
-      if (4 > sscanf(buf, "cpu%u %Lu %Lu %Lu %Lu %Lu %Lu %Lu %Lu", &cpus[i].id
-         , &cpus[i].u, &cpus[i].n, &cpus[i].s, &cpus[i].i
-         , &cpus[i].w, &cpus[i].x, &cpus[i].y, &cpus[i].z)) {
-            error_exit(err_read);
-      }
-#ifdef PRETEND4CPUS
-      cpus[i].id = i;
-#endif
-   }
-   return cpus;
-} // end: cpus_refresh
-
-
-#ifdef OFF_HST_HASH
-        /*
-         * Binary Search for HST_t's put/get support */
-
-static inline HST_t *hstbsrch (HST_t *hst, int max, int pid) {
-   int mid, min = 0;
-
-   while (min <= max) {
-      mid = (min + max) / 2;
-      if (pid < hst[mid].pid) max = mid - 1;
-      else if (pid > hst[mid].pid) min = mid + 1;
-      else return &hst[mid];
-   }
-   return NULL;
-} // end: hstbsrch
-
-#else
-        /*
-         * Hashing functions for HST_t's put/get support
-         * (not your normal 'chaining', those damn HST_t's might move!) */
-
-#define _HASH_(K) (K & (HHASH_SIZ - 1))
-
-static inline HST_t *hstget (int pid) {
-   int V = PHash_sav[_HASH_(pid)];
-
-   while (-1 < V) {
-      if (PHist_sav[V].pid == pid) return &PHist_sav[V];
-      V = PHist_sav[V].lnk; }
-   return NULL;
-} // end: hstget
-
-
-static inline void hstput (unsigned idx) {
-   int V = _HASH_(PHist_new[idx].pid);
-
-   PHist_new[idx].lnk = PHash_new[V];
-   PHash_new[V] = idx;
-} // end: hstput
-
-#undef _HASH_
-#endif
-
-        /*
-         * Refresh procs *Helper* function to eliminate yet one more need
-         * to loop through our darn proc_t table.  He's responsible for:
-         *    1) calculating the elapsed time since the previous frame
-         *    2) counting the number of tasks in each state (run, sleep, etc)
-         *    3) maintaining the HST_t's and priming the proc_t pcpu field
-         *    4) establishing the total number tasks for this frame */
-static void prochlp (proc_t *this) {
-#ifdef OFF_HST_HASH
-   static unsigned maxt_sav = 0;        // prior frame's max tasks
-#endif
-   TIC_t tics;
-   HST_t *h;
-
-   if (!this) {
-      static struct timeval oldtimev;
-      struct timeval timev;
-      struct timezone timez;
-      float et;
-      void *v;
-
-      gettimeofday(&timev, &timez);
-      et = (timev.tv_sec - oldtimev.tv_sec)
-         + (float)(timev.tv_usec - oldtimev.tv_usec) / 1000000.0;
-      oldtimev.tv_sec = timev.tv_sec;
-      oldtimev.tv_usec = timev.tv_usec;
-
-      // if in Solaris mode, adjust our scaling for all cpus
-      Frame_etscale = 100.0f / ((float)Hertz * (float)et * (Rc.mode_irixps ? 1 : Cpu_tot));
-#ifdef OFF_HST_HASH
-      maxt_sav = Frame_maxtask;
-#endif
-      Frame_maxtask = Frame_running = Frame_sleepin = Frame_stopped = Frame_zombied = 0;
-
-      // prep for saving this frame's HST_t's (and reuse mem each time around)
-      v = PHist_sav;
-      PHist_sav = PHist_new;
-      PHist_new = v;
-#ifdef OFF_HST_HASH
-      // prep for binary search by sorting the last frame's HST_t's
-      qsort(PHist_sav, maxt_sav, sizeof(HST_t), (QFP_t)sort_HST_t);
-#else
-      v = PHash_sav;
-      PHash_sav = PHash_new;
-      PHash_new = v;
-      memcpy(PHash_new, HHash_nul, sizeof(HHash_nul));
-#endif
-      return;
-   }
-
-   switch (this->state) {
-      case 'R':
-         Frame_running++;
-         break;
-      case 'S':
-      case 'D':
-         Frame_sleepin++;
-         break;
-      case 'T':
-         Frame_stopped++;
-         break;
-      case 'Z':
-         Frame_zombied++;
-         break;
-      default:                    // keep gcc happy
-         break;
-   }
-
-   if (Frame_maxtask+1 >= HHist_siz) {
-      HHist_siz = HHist_siz * 5 / 4 + 100;
-      PHist_sav = alloc_r(PHist_sav, sizeof(HST_t) * HHist_siz);
-      PHist_new = alloc_r(PHist_new, sizeof(HST_t) * HHist_siz);
-   }
-
-   /* calculate time in this process; the sum of user time (utime) and
-      system time (stime) -- but PLEASE dont waste time and effort on
-      calcs and saves that go unused, like the old top! */
-   PHist_new[Frame_maxtask].pid  = this->tid;
-   PHist_new[Frame_maxtask].tics = tics = (this->utime + this->stime);
-
-#ifdef OFF_HST_HASH
-   // find matching entry from previous frame and make ticks elapsed
-   if ((h = hstbsrch(PHist_sav, maxt_sav - 1, this->tid))) tics -= h->tics;
-#else
-   // hash & save for the next frame
-   hstput(Frame_maxtask);
-   // find matching entry from previous frame and make ticks elapsed
-   if ((h = hstget(this->tid))) tics -= h->tics;
-#endif
-
-   /* we're just saving elapsed tics, to be converted into %cpu if
-      this task wins it's displayable screen row lottery... */
-   this->pcpu = tics;
-
-   // shout this to the world with the final call (or us the next time in)
-   Frame_maxtask++;
-} // end: prochlp
-
-
-        /*
-         * This guy's modeled on libproc's 'readproctab' function except
-         * we reuse and extend any prior proc_t's.  He's been customized
-         * for our specific needs and to avoid the use of <stdarg.h> */
-static void procs_refresh (void) {
-   static proc_t **private_ppt;        // our base proc_t pointer table
-   static unsigned savmax = 0;         // first time, Bypass: (i)
-   proc_t *ptask = (proc_t*)-1;        // first time, Force: (ii)
-   unsigned curmax = 0;                // every time  (jeeze)
-   PROCTAB* PT;
-   int i;
-   proc_t*(*read_something)(PROCTAB*, proc_t*);
-
-   prochlp(NULL);                      // prep for a new frame
-   if (NULL == (PT = openproc(Frames_libflags, Monpids)))
-      error_exit(fmtmk("failed openproc: %s", strerror(errno)));
-   read_something = Thread_mode ? readeither : readproc;
-
-   // i) Allocated Chunks:  *Existing* table;  refresh + reuse
-   while (curmax < savmax) {
-      if (!(ptask = read_something(PT, private_ppt[curmax]))) break;
-      prochlp(ptask);                  // tally & complete this proc_t
-      ++curmax;
-   }
-
-   // ii) Unallocated Chunks:  *New* or *Existing* table;  extend + fill
-   while (ptask) {
-      // realloc as we go, keeping 'ppt' ahead of 'currmax++'
-      private_ppt = alloc_r(private_ppt, (curmax + 1) * sizeof(proc_t*));
-      // here, the library will allocate the underlying proc_t stg
-      if ((ptask = read_something(PT, NULL))) {
-         prochlp(ptask);               // tally & complete this proc_t
-         private_ppt[curmax++] = ptask;
-      }
-   }
-
-   closeproc(PT);
-
-   // iii) Chunkless:  End frame, but not necessarily end of allocated space
-   if (savmax < curmax) savmax = curmax;
-
-   // lastly, refresh each window's proc pointers table...
-   for (i = 0; i < GROUPSMAX; i++) {
-      Winstk[i].ppt = alloc_r(Winstk[i].ppt, savmax * sizeof(proc_t*));
-      memcpy(Winstk[i].ppt, private_ppt, Frame_maxtask * sizeof(proc_t*));
-   }
-} // end: procs_refresh
-
-
-        /*
-         * This serves as our interface to the memory & cpu count (sysinfo)
-         * portion of libproc.  In support of those hotpluggable resources,
-         * the sampling frequencies are reduced so as to minimize overhead.
-         * We'll strive to verify the number of cpus every 5 minutes and the
-         * memory availability/usage every 3 seconds. */
-static void sysinfo_refresh (int forced) {
-   static time_t mem_secs, cpu_secs;
-   time_t cur_secs;
-
-   if (forced)
-      mem_secs = cpu_secs = 0;
-   time(&cur_secs);
-
-   /*** hotplug_acclimated ***/
-   if (3 <= cur_secs - mem_secs) {
-      meminfo();
-      mem_secs = cur_secs;
-   }
-#ifndef PRETEND4CPUS
-   /*** hotplug_acclimated ***/
-   if (300 <= cur_secs - cpu_secs) {
-      cpuinfo();
-      cpu_secs = cur_secs;
-   }
-#endif
-} // end: sysinfo_refresh
-
-/*######  Startup routines  ##############################################*/
-
-        /*
-         * No matter what *they* say, we handle the really really BIG and
-         * IMPORTANT stuff upon which all those lessor functions depend! */
-static void before (char *me) {
-   struct sigaction sa;
-   int i;
-
-   // setup our program name -- big!
-   Myname = strrchr(me, '/');
-   if (Myname) ++Myname; else Myname = me;
-
-   // establish cpu particulars -- even bigger!
-#ifdef PRETEND4CPUS
-   smp_num_cpus = 4;
-#endif
-   Cpu_tot = smp_num_cpus;
-   if (linux_version_code > LINUX_VERSION(2, 5, 41))
-      Cpu_States_fmts = STATES_line2x5;
-   if (linux_version_code >= LINUX_VERSION(2, 6, 0))
-      Cpu_States_fmts = STATES_line2x6;
-   if (linux_version_code >= LINUX_VERSION(2, 6, 11))
-      Cpu_States_fmts = STATES_line2x7;
-
-   // get virtual page stuff -- nearing huge!
-   Page_size = getpagesize();
-   i = Page_size;
-   while(i > 1024) { i >>= 1; Pg2K_shft++; }
-
-#ifndef OFF_HST_HASH
-   // prep for HST_t's put/get hashing optimizations
-   for (i = 0; i < HHASH_SIZ; i++) HHash_nul[i] = -1;
-   memcpy(HHash_one, HHash_nul, sizeof(HHash_nul));
-   memcpy(HHash_two, HHash_nul, sizeof(HHash_nul));
-#endif
-
-   // lastly, establish a robust signals environment
-   sigemptyset(&sa.sa_mask);
-   sa.sa_flags = SA_RESTART;
-   for (i = SIGRTMAX; i; i--) {
-      switch (i) {
-         case SIGALRM: case SIGHUP:  case SIGINT:
-         case SIGPIPE: case SIGQUIT: case SIGTERM:
-            sa.sa_handler = sig_endpgm;
-            break;
-         case SIGTSTP: case SIGTTIN: case SIGTTOU:
-            sa.sa_handler = sig_paused;
-            break;
-         case SIGCONT: case SIGWINCH:
-            sa.sa_handler = sig_resize;
-            break;
-         default:
-            sa.sa_handler = sig_abexit;
-            break;
-      }
-      sigaction(i, &sa, NULL);
-   }
-} // end: before
-
-
-        /*
-         * Build the local RC file name then try to read both of 'em.
-         * 'SYS_RCFILESPEC' contains two lines consisting of the secure
-         *   mode switch and an update interval.  It's presence limits what
-         *   ordinary users are allowed to do.
-         * 'Rc_name' contains multiple lines - 2 global + 3 per window.
-         *   line 1: an eyecatcher and creating program/alias name
-         *   line 2: an id, Mode_altcsr, Mode_irixps, Delay_time and Curwin.
-         *           If running in secure mode via the /etc/rcfile,
-         *           the 'delay time' will be ignored except for root.
-         * For each of the 4 windows:
-         *   line a: contains w->winname, fieldscur
-         *   line b: contains w->winflags, sortindx, maxtasks
-         *   line c: contains w->summclr, msgsclr, headclr, taskclr */
-static void configs_read (void) {
-#ifndef RCFILE_NOERR
-   static const char err_rcid[] = "incompatible rcfile, you should delete '%s'";
-   static const char err_flds[] = "window entry #%d corrupt, please delete '%s'";
-#else
-   RCF_t rcdef = DEF_RCFILE;
-#endif
-   float tmp_delay = DEF_DELAY;
-   char fbuf[LRGBUFSIZ];
-   FILE *fp;
-   int i, x;
-   char id;
-
-   if (!getenv("HOME")) snprintf(Rc_name, sizeof(Rc_name), ".%src", Myname);
-   else snprintf(Rc_name, sizeof(Rc_name), "%s/.%src", getenv("HOME"), Myname);
-
-   fp = fopen(SYS_RCFILESPEC, "r");
-   if (fp) {
-      fbuf[0] = '\0';
-      fgets(fbuf, sizeof(fbuf), fp);             // sys rc file, line 1
-      if (strchr(fbuf, 's')) Secure_mode = 1;
-      fbuf[0] = '\0';
-      fgets(fbuf, sizeof(fbuf), fp);             // sys rc file, line 2
-      sscanf(fbuf, "%f", &Rc.delay_time);
-      fclose(fp);
-   }
-
-   fp = fopen(Rc_name, "r");
-   if (fp) {
-      fbuf[0] = '\0';
-      fgets(fbuf, sizeof(fbuf), fp);             // ignore eyecatcher
-      if (5 != (fscanf(fp, "Id:%c, "
-         "Mode_altscr=%d, Mode_irixps=%d, Delay_time=%f, Curwin=%d\n"
-         , &id, &Rc.mode_altscr, &Rc.mode_irixps, &tmp_delay, &i))
-      || RCF_VERSION_ID != id)
-#ifndef RCFILE_NOERR
-         error_exit(fmtmk(err_rcid, Rc_name));
-#else
-         goto just_default_em;
-#endif
-      // you saw that, right?  (fscanf stickin' it to 'i')
-      Curwin = &Winstk[i];
-
-      for (i = 0 ; i < GROUPSMAX; i++) {
-         // note: "fieldscur=%__s" on next line should equal PFLAGSSIZ !
-         fscanf(fp, "%3s\tfieldscur=%64s\n"
-            , Winstk[i].rc.winname, Winstk[i].rc.fieldscur);
-#if PFLAGSSIZ > 64
- // too bad fscanf is not as flexible with his format string as snprintf
- # error Hey, fix the above fscanf 'PFLAGSSIZ' dependency !
-#endif
-         if (strlen(Winstk[i].rc.fieldscur) != sizeof(DEF_FIELDS) - 1)
-#ifndef RCFILE_NOERR
-            error_exit(fmtmk(err_flds, i+1, Rc_name));
-#else
-            goto just_default_em;
-#endif
-         for (x = 0; x < P_MAXPFLGS; ++x) {
-            int f = FLDget(&Winstk[i], x);
-            if (P_MAXPFLGS <= f)
-#ifndef RCFILE_NOERR
-               error_exit(fmtmk(err_flds, i+1, Rc_name));
-#else
-               goto just_default_em;
-#endif
-         }
-         fscanf(fp, "\twinflags=%d, sortindx=%d, maxtasks=%d\n"
-            , &Winstk[i].rc.winflags, (int*)&Winstk[i].rc.sortindx, &Winstk[i].rc.maxtasks);
-         fscanf(fp, "\tsummclr=%d, msgsclr=%d, headclr=%d, taskclr=%d\n"
-            , &Winstk[i].rc.summclr, &Winstk[i].rc.msgsclr
-            , &Winstk[i].rc.headclr, &Winstk[i].rc.taskclr);
-      }
-      fclose(fp);
-   }
-
-   // lastly, establish the true runtime secure mode and delay time
-   if (!getuid()) Secure_mode = 0;
-   if (!Secure_mode) Rc.delay_time = tmp_delay;
-   return;
-
-#ifdef RCFILE_NOERR
-just_default_em:
-   fclose(fp);
-   Rc = rcdef;
-   for (i = 0 ; i < GROUPSMAX; i++)
-      Winstk[i].rc  = Rc.win[i];
-#endif
-} // end: configs_read
-
-
-        /*
-         * Parse command line arguments.
-         * Note: it's assumed that the rc file(s) have already been read
-         *       and our job is to see if any of those options are to be
-         *       overridden -- we'll force some on and negate others in our
-         *       best effort to honor the loser's (oops, user's) wishes... */
-static void parse_args (char **args) {
-   /* differences between us and the former top:
-      -C (separate CPU states for SMP) is left to an rcfile
-      -u (user monitoring) added to compliment interactive 'u'
-      -p (pid monitoring) allows a comma delimited list
-      -q (zero delay) eliminated as redundant, incomplete and inappropriate
-            use: "nice -n-10 top -d0" to achieve what was only claimed
-      .  most switches act as toggles (not 'on' sw) for more user flexibility
-      .  no deprecated/illegal use of 'breakargv:' with goto
-      .  bunched args are actually handled properly and none are ignored
-      .  we tolerate NO whitespace and NO switches -- maybe too tolerant? */
-   static const char usage_str[] =
-      " -hv | -bcHiSs -d delay -n limit -u|U user | -p pid[,pid] -w [cols]";
-   static const char sel_error[] = "conflicting process selections (U/p/u)";
-   static const char numbs_str[] = "+,-.0123456789";
-   float tmp_delay = MAXFLOAT;
-   char *p;
-
-   while (*args) {
-      const char *cp = *(args++);
-
-      while (*cp) {
-         char ch;
-         switch ((ch = *cp)) {
-            case '\0':
-               break;
-            case '-':
-               if (cp[1]) ++cp;
-               else if (*args) cp = *args++;
-               if (strspn(cp, numbs_str))
-                  error_exit(fmtmk("inappropriate '%s'\nusage:\t%s%s", cp, Myname, usage_str));
-               continue;
-            case 'b':
-               Batch = 1;
-               break;
-            case 'c':
-               TOGw(Curwin, Show_CMDLIN);
-               break;
-            case 'd':
-               if (cp[1]) ++cp;
-               else if (*args) cp = *args++;
-               else error_exit("-d requires argument");
-                  /* a negative delay will be dealt with shortly... */
-               if (1 != sscanf(cp, "%f", &tmp_delay))
-                  error_exit(fmtmk("bad delay '%s'", cp));
-               break;
-            case 'H':
-               Thread_mode = 1;
-               break;
-            case 'h':
-            case 'v': case 'V':
-               fprintf(stdout, "\t%s\nusage:\t%s%s", procps_version, Myname, usage_str);
-               bye_bye(NULL);
-            case 'i':
-               TOGw(Curwin, Show_IDLEPS);
-               Curwin->rc.maxtasks = 0;
-               break;
-            case 'n':
-               if (cp[1]) cp++;
-               else if (*args) cp = *args++;
-               else error_exit("-n requires argument");
-               if (1 != sscanf(cp, "%d", &Loops) || 1 > Loops)
-                  error_exit(fmtmk("bad iterations arg '%s'", cp));
-               break;
-            case 'p':
-               if (Curwin->usrseltyp) error_exit(sel_error);
-               do {
-                  if (cp[1]) cp++;
-                  else if (*args) cp = *args++;
-                  else error_exit("-p argument missing");
-                  if (Monpidsidx >= MONPIDMAX)
-                     error_exit(fmtmk("pid limit (%d) exceeded", MONPIDMAX));
-                  if (1 != sscanf(cp, "%d", &Monpids[Monpidsidx])
-                  || 0 > Monpids[Monpidsidx])
-                     error_exit(fmtmk("bad pid '%s'", cp));
-                  if (!Monpids[Monpidsidx])
-                     Monpids[Monpidsidx] = getpid();
-                  Monpidsidx++;
-                  if (!(p = strchr(cp, ',')))
-                     break;
-                  cp = p;
-               } while (*cp);
-               break;
-            case 's':
-               Secure_mode = 1;
-               break;
-            case 'S':
-               TOGw(Curwin, Show_CTIMES);
-               break;
-            case 'u':
-            case 'U':
-            {  const char *errmsg;
-               if (Monpidsidx || Curwin->usrseltyp) error_exit(sel_error);
-               if (cp[1]) cp++;
-               else if (*args) cp = *args++;
-               else error_exit(fmtmk("-%c missing name", ch));
-               if ((errmsg = user_certify(Curwin, cp, ch))) error_exit(errmsg);
-               cp += strlen(cp);
-               break;
-            }
-            case 'w':
-            {  const char *pn = NULL;
-               int ai = 0, ci = 0;
-               Width_mode = -1;
-               if (cp[1]) pn = &cp[1];
-               else if (*args) { pn = *args; ai = 1; }
-               if (pn && !(ci = strspn(pn, "0123456789"))) { ai = 0; pn = NULL; }
-               if (pn && (1 != sscanf(pn, "%d", &Width_mode)
-               || Width_mode < W_MIN_COL))
-                  error_exit(fmtmk("bad width arg '%s', must > %d", pn, W_MIN_COL-1));
-               cp++;
-               args += ai;
-               if (pn) cp = pn + ci;
-               continue;
-            }
-            default :
-               error_exit(fmtmk("unknown option '%c'\nusage:\t%s%s", *cp, Myname, usage_str));
-
-         } // end: switch (*cp)
-
-         // advance cp and jump over any numerical args used above
-         if (*cp) cp += strspn(&cp[1], numbs_str) + 1;
-
-      } // end: while (*cp)
-   } // end: while (*args)
-
-   // fixup delay time, maybe...
-   if (MAXFLOAT > tmp_delay) {
-      if (Secure_mode)
-         error_exit("-d disallowed in \"secure\" mode");
-      if (0 > tmp_delay)
-         error_exit("-d requires positive argument");
-      Rc.delay_time = tmp_delay;
-   }
-} // end: parse_args
-
-
-        /*
-         * Set up the terminal attributes */
-static void whack_terminal (void) {
-   static char dummy[] = "dumb";
-   struct termios tmptty;
-
-   // the curses part...
-   if (Batch) {
-      setupterm(dummy, STDOUT_FILENO, NULL);
-      return;
-   }
-#ifdef PRETENDNOCAP
-   setupterm(dummy, STDOUT_FILENO, NULL);
-#else
-   setupterm(NULL, STDOUT_FILENO, NULL);
-#endif
-   // our part...
-   if (-1 == tcgetattr(STDIN_FILENO, &Tty_original))
-      error_exit("failed tty get");
-   // ok, haven't really changed anything but we do have our snapshot
-   Ttychanged = 1;
-
-   // first, a consistent canonical mode for interactive line input
-   tmptty = Tty_original;
-   tmptty.c_lflag |= (ECHO | ECHOCTL | ECHOE | ICANON | ISIG);
-   tmptty.c_lflag &= ~NOFLSH;
-   tmptty.c_oflag &= ~TAB3;
-   tmptty.c_iflag |= BRKINT;
-   tmptty.c_iflag &= ~IGNBRK;
-   if (key_backspace && 1 == strlen(key_backspace))
-      tmptty.c_cc[VERASE] = *key_backspace;
-#ifdef TERMIOS_ONLY
-   if (-1 == tcsetattr(STDIN_FILENO, TCSAFLUSH, &tmptty))
-      error_exit(fmtmk("failed Tty_tweaked set: %s", strerror(errno)));
-   tcgetattr(STDIN_FILENO, &Tty_tweaked);
-#endif
-   // lastly, a nearly raw mode for unsolicited single keystrokes
-   tmptty.c_lflag &= ~(ECHO | ECHOCTL | ECHOE | ICANON);
-   tmptty.c_cc[VMIN] = 1;
-   tmptty.c_cc[VTIME] = 0;
-   if (-1 == tcsetattr(STDIN_FILENO, TCSAFLUSH, &tmptty))
-      error_exit(fmtmk("failed Tty_raw set: %s", strerror(errno)));
-   tcgetattr(STDIN_FILENO, &Tty_raw);
-
-#ifndef OFF_STDIOLBF
-   // thanks anyway stdio, but we'll manage buffering at the frame level...
-   setbuffer(stdout, Stdout_buf, sizeof(Stdout_buf));
-#endif
-
-   // and don't forget to ask keyin to initialize his tinfo_tab
-   keyin(1);
-} // end: whack_terminal
-
-/*######  Windows/Field Groups support  #################################*/
-
-        /*
-         * Value a window's name and make the associated group name. */
-static void win_names (WIN_t *q, const char *name) {
-   /* note: sprintf/snprintf results are "undefined" when src==dst,
-            according to C99 & POSIX.1-2001 (thanks adc) */
-   if (q->rc.winname != name)
-      snprintf(q->rc.winname, sizeof(q->rc.winname), "%s", name);
-   snprintf(q->grpname, sizeof(q->grpname), "%d:%s", q->winnum, name);
-} // end: win_names
-
-
-        /*
-         * Display a window/field group (ie. make it "current"). */
-static WIN_t *win_select (char ch) {
-   static const char prompt[] = "Choose field group (1 - 4)";
-   WIN_t *w = Curwin;             // avoid gcc bloat with a local copy
-
-   /* if there's no ch, it means we're supporting the external interface,
-      so we must try to get our own darn ch by begging the user... */
-   if (!ch) {
-      show_pmt(prompt);
-      if (1 > chin(0, (char *)&ch, 1)) return Curwin;
-   }
-   switch (ch) {
-      case 'a':                         // we don't carry 'a' / 'w' in our
-         w = w->next;                   // pmt - they're here for a good
-         break;                         // friend of ours -- wins_colors.
-      case 'w':                         // (however those letters work via
-         w = w->prev;                   // the pmt too but gee, end-loser
-         break;                         // should just press the darn key)
-      case '1' ... '4':
-         w = &Winstk[ch - '1'];
-         break;
-      default:                    // keep gcc happy
-         break;
-   }
-   return Curwin = w;
-} // end: win_select
-
-
-        /*
-         * Just warn the user when a command can't be honored. */
-static int win_warn (int what) {
-   switch (what) {
-      case Warn_ALT:
-         show_msg("Command disabled, 'A' mode required");
-         break;
-      case Warn_VIZ:
-         show_msg(fmtmk("Command disabled, activate %s with '-' or '_'"
-            , Curwin->grpname));
-         break;
-      default:                    // keep gcc happy
-         break;
-   }
-   /* we gotta' return false 'cause we're somewhat well known within
-      macro society, by way of that sassy little tertiary operator... */
-   return 0;
-} // end: win_warn
-
-
-        /*
-         * Change colors *Helper* function to save/restore settings;
-         * ensure colors will show; and rebuild the terminfo strings. */
-static void winsclrhlp (WIN_t *q, int save) {
-   static int flgssav, summsav, msgssav, headsav, tasksav;
-
-   if (save) {
-      flgssav = q->rc.winflags; summsav = q->rc.summclr;
-      msgssav = q->rc.msgsclr;  headsav = q->rc.headclr; tasksav = q->rc.taskclr;
-      SETw(q, Show_COLORS);
-   } else {
-      q->rc.winflags = flgssav; q->rc.summclr = summsav;
-      q->rc.msgsclr = msgssav;  q->rc.headclr = headsav; q->rc.taskclr = tasksav;
-   }
-   capsmk(q);
-} // end: winsclrhlp
-
-
-        /*
-         * Change colors used in display */
-static void wins_colors (void) {
- #define kbdABORT  'q'
- #define kbdAPPLY  kbd_ENTER
-   WIN_t *w = Curwin;             // avoid gcc bloat with a local copy
-   int clr = w->rc.taskclr, *pclr = &w->rc.taskclr;
-   char ch, tgt = 'T';
-
-   if (0 >= max_colors) {
-      show_msg("No colors to map!");
-      return;
-   }
-   winsclrhlp(w, 1);
-   putp(Cap_clr_scr);
-   putp(Cap_curs_huge);
-
-   do {
-      putp(Cap_home);
-      // this string is well above ISO C89's minimum requirements!
-      show_special(1, fmtmk(COLOR_help
-         , procps_version, w->grpname
-         , CHKw(w, View_NOBOLD) ? "On" : "Off"
-         , CHKw(w, Show_COLORS) ? "On" : "Off"
-         , CHKw(w, Show_HIBOLD) ? "On" : "Off"
-         , tgt, clr, w->grpname));
-      if (1 > chin(0, &ch, 1)) break;
-      switch (ch) {
-         case 'S':
-            pclr = &w->rc.summclr;
-            clr = *pclr;
-            tgt = ch;
-            break;
-         case 'M':
-            pclr = &w->rc.msgsclr;
-            clr = *pclr;
-            tgt = ch;
-            break;
-         case 'H':
-            pclr = &w->rc.headclr;
-            clr = *pclr;
-            tgt = ch;
-            break;
-         case 'T':
-            pclr = &w->rc.taskclr;
-            clr = *pclr;
-            tgt = ch;
-            break;
-         case '0' ... '7':
-            clr = ch - '0';
-            *pclr = clr;
-            break;
-         case 'B':
-            TOGw(w, View_NOBOLD);
-            break;
-         case 'b':
-            TOGw(w, Show_HIBOLD);
-            break;
-         case 'z':
-            TOGw(w, Show_COLORS);
-            break;
-         case 'a':
-         case 'w':
-            winsclrhlp((w = win_select(ch)), 1);
-            clr = w->rc.taskclr, pclr = &w->rc.taskclr;
-            tgt = 'T';
-            break;
-         default:                 // keep gcc happy
-            break;
-      }
-      capsmk(w);
-   } while (kbdAPPLY != ch && kbdABORT != ch);
-
-   if (kbdABORT == ch) winsclrhlp(w, 0);
-   putp(Cap_curs_norm);
- #undef kbdABORT
- #undef kbdAPPLY
-} // end: wins_colors
-
-
-        /*
-         * Manipulate flag(s) for all our windows. */
-static void wins_reflag (int what, int flg) {
-   WIN_t *w = Curwin;             // avoid gcc bloat with a local copy
-
-   do {
-      switch (what) {
-         case Flags_TOG:
-            TOGw(w, flg);
-            break;
-         case Flags_SET:          // Ummmm, i can't find anybody
-            SETw(w, flg);         // who uses Flags_set ...
-            break;
-         case Flags_OFF:
-            OFFw(w, flg);
-            break;
-         default:                 // keep gcc happy
-            break;
-      }
-         /* a flag with special significance -- user wants to rebalance
-            display so we gotta' off some stuff then force on two flags... */
-      if (EQUWINS_xxx == flg) {
-         w->rc.maxtasks = w->usrseltyp = w->begpflg = w->begtask = 0;
-         Monpidsidx = 0;
-         SETw(w, Show_IDLEPS | Show_TASKON);
-      }
-      w = w->next;
-   } while (w != Curwin);
-} // end: wins_reflag
-
-
-        /*
-         * Set up the raw/incomplete field group windows --
-         * they'll be finished off after startup completes.
-         * [ and very likely that will override most/all of our efforts ]
-         * [               --- life-is-NOT-fair ---                     ] */
-static void wins_stage_1 (void) {
-   WIN_t *w;
-   int i;
-
-   for (i = 0; i < GROUPSMAX; i++) {
-      w = &Winstk[i];
-      w->winnum = i + 1;
-      w->rc = Rc.win[i];
-      w->captab[0] = Cap_norm;
-      w->captab[1] = Cap_norm;
-      w->captab[2] = w->cap_bold;
-      w->captab[3] = w->capclr_sum;
-      w->captab[4] = w->capclr_msg;
-      w->captab[5] = w->capclr_pmt;
-      w->captab[6] = w->capclr_hdr;
-      w->captab[7] = w->capclr_rowhigh;
-      w->captab[8] = w->capclr_rownorm;
-      w->next = w + 1;
-      w->prev = w - 1;
-   }
-
-   // fixup the circular chains...
-   Winstk[GROUPSMAX - 1].next = &Winstk[0];
-   Winstk[0].prev = &Winstk[GROUPSMAX - 1];
-   Curwin = Winstk;
-} // end: wins_stage_1
-
-
-        /*
-         * This guy just completes the field group windows after the
-         * rcfiles have been read and command line arguments parsed */
-static void wins_stage_2 (void) {
-   int i;
-
-   for (i = 0; i < GROUPSMAX; i++) {
-      win_names(&Winstk[i], Winstk[i].rc.winname);
-      capsmk(&Winstk[i]);
-   }
-   if (Batch)
-      OFFw(Curwin, View_SCROLL);
-
-   // fill in missing Fieldstab members and build each window's columnhdr
-   zap_fieldstab();
-} // end: wins_stage_2
-
-/*######  Interactive Input support (do_key helpers)  ####################*/
-
-        /*
-         * These routines exist just to keep the do_key() function
-         * a reasonably modest size.  */
-
-static void file_writerc (void) {
-   FILE *fp;
-   int i;
-
-   if (!(fp = fopen(Rc_name, "w"))) {
-      show_msg(fmtmk("Failed '%s' open: %s", Rc_name, strerror(errno)));
-      return;
-   }
-   fprintf(fp, "%s's " RCF_EYECATCHER, Myname);
-   fprintf(fp, "Id:%c, Mode_altscr=%d, Mode_irixps=%d, Delay_time=%.3f, Curwin=%d\n"
-      , RCF_VERSION_ID
-      , Rc.mode_altscr, Rc.mode_irixps, Rc.delay_time, (int)(Curwin - Winstk));
-
-   for (i = 0 ; i < GROUPSMAX; i++) {
-      fprintf(fp, "%s\tfieldscur=%s\n"
-         , Winstk[i].rc.winname, Winstk[i].rc.fieldscur);
-      fprintf(fp, "\twinflags=%d, sortindx=%d, maxtasks=%d\n"
-         , Winstk[i].rc.winflags, (int)Winstk[i].rc.sortindx
-         , Winstk[i].rc.maxtasks);
-      fprintf(fp, "\tsummclr=%d, msgsclr=%d, headclr=%d, taskclr=%d\n"
-         , Winstk[i].rc.summclr, Winstk[i].rc.msgsclr
-         , Winstk[i].rc.headclr, Winstk[i].rc.taskclr);
-   }
-   fclose(fp);
-   show_msg(fmtmk("Wrote configuration to '%s'", Rc_name));
-} // end: file_writerc
-
-
-static void help_view (void) {
-   WIN_t *w = Curwin;             // avoid gcc bloat with a local copy
-   char ch;
-
-   putp(Cap_clr_scr);
-   putp(Cap_curs_huge);
-
-   // this string is well above ISO C89's minimum requirements!
-   show_special(1, fmtmk(KEYS_help
-      , procps_version
-      , w->grpname
-      , CHKw(w, Show_CTIMES) ? "On" : "Off"
-      , Rc.delay_time
-      , Secure_mode ? "On" : "Off"
-      , Secure_mode ? "" : KEYS_help_unsecured));
-
-   if (0 < chin(0, &ch, 1)
-   && ('?' == ch || 'h' == ch || 'H' == ch)) {
-      do {
-         putp(Cap_clr_scr);
-         show_special(1, fmtmk(WINDOWS_help
-            , w->grpname
-            , Winstk[0].rc.winname, Winstk[1].rc.winname
-            , Winstk[2].rc.winname, Winstk[3].rc.winname));
-         if (1 > chin(0, &ch, 1)) break;
-         w = win_select(ch);
-      } while (kbd_ENTER != ch);
-   }
-
-   putp(Cap_curs_norm);
-} // end: help_view
-
-
-static void keys_global (int ch) {
-   // standardized error message(s)
-   static const char err_secure[] = "Unavailable in secure mode";
-   static const char err_notsmp[] = "Only 1 cpu detected";
-   WIN_t *w = Curwin;             // avoid gcc bloat with a local copy
-
-   switch (ch) {
-      case 'B':
-         TOGw(w, View_NOBOLD);
-         capsmk(w);
-         break;
-      case 'd':
-      case 's':
-         if (Secure_mode)
-            show_msg(err_secure);
-         else {
-            float tmp =
-               get_float(fmtmk("Change delay from %.1f to", Rc.delay_time));
-            if (-1 < tmp) Rc.delay_time = tmp;
-         }
-         break;
-      case 'F':
-      case 'f':
-         fields_utility();
-         break;
-      case 'g':
-         win_select(0);
-         break;
-      case 'H':
-         Thread_mode = !Thread_mode;
-         if (!CHKw(w, View_STATES))
-            show_msg(fmtmk("Show threads %s", Thread_mode ? "On" : "Off"));
-         break;
-      case 'I':
-         if (Cpu_tot > 1) {
-            Rc.mode_irixps = !Rc.mode_irixps;
-            show_msg(fmtmk("Irix mode %s", Rc.mode_irixps ? "On" : "Off"));
-         } else
-            show_msg(err_notsmp);
-         break;
-      case 'k':
-         if (Secure_mode) {
-            show_msg(err_secure);
-         } else {
-            int pid, sig = SIGTERM;
-            char *str;
-            if (-1 < (pid = get_int("pid to signal/kill"))) {
-               str = linein(fmtmk("Send pid %d signal [%d/sigterm]", pid, SIGTERM));
-               if (*str) sig = signal_name_to_number(str);
-               if (0 < sig && kill(pid, sig))
-                  show_msg(fmtmk("Failed signal pid '%d' with '%d': %s"
-                     , pid, sig, strerror(errno)));
-               else if (0 > sig) show_msg("Invalid signal");
-            }
-         }
-         break;
-      case 'r':
-         if (Secure_mode)
-            show_msg(err_secure);
-         else {
-            int val, pid;
-            if (-1 < (pid = get_int("PID to renice"))
-            && INT_MIN < (val = get_int(fmtmk("Renice PID %d to value", pid))))
-               if (setpriority(PRIO_PROCESS, (unsigned)pid, val))
-                  show_msg(fmtmk("Failed renice of PID %d to %d: %s"
-                     , pid, val, strerror(errno)));
-         }
-         break;
-      case 'Z':
-         wins_colors();
-         break;
-      default:                    // keep gcc happy
-         break;
-   }
-} // end: keys_global
-
-
-static void keys_summary (int ch) {
-   WIN_t *w = Curwin;             // avoid gcc bloat with a local copy
-
-   switch (ch) {
-      case '1':
-         TOGw(w, View_CPUSUM);
-         break;
-      case 'C':
-         VIZTOGw(w, View_SCROLL);
-         break;
-      case 'l':
-         TOGw(w, View_LOADAV);
-         break;
-      case 'm':
-         TOGw(w, View_MEMORY);
-         break;
-      case 't':
-         TOGw(w, View_STATES);
-         break;
-      default:                    // keep gcc happy
-         break;
-   }
-} // end: keys_summary
-
-
-static void keys_task (int ch) {
-   WIN_t *w = Curwin;             // avoid gcc bloat with a local copy
-
-   switch (ch) {
-      case '#':
-      case 'n':
-         if (VIZCHKw(w)) {
-            int num = get_int(fmtmk("Maximum tasks = %d, change to (0 is unlimited)", w->rc.maxtasks));
-            if (INT_MIN < num) {
-               if (-1 < num ) w->rc.maxtasks = num;
-               else show_msg("Invalid maximum");
-            }
-         }
-         break;
-      case '<':
-#ifdef TREE_NORESET
-         if (CHKw(w, Show_FOREST)) break;
-#endif
-         if (VIZCHKw(w)) {
-            FLG_t *p = w->procflgs + w->maxpflgs - 1;
-            while (p > w->procflgs && *p != w->rc.sortindx) --p;
-            if (*p == w->rc.sortindx) {
-               --p;
-#ifndef USE_X_COLHDR
-               if (P_MAXPFLGS < *p) --p;
-#endif
-               if (p >= w->procflgs) {
-                  w->rc.sortindx = *p;
-#ifndef TREE_NORESET
-                  OFFw(w, Show_FOREST);
-#endif
-               }
-            }
-         }
-         break;
-      case '>':
-#ifdef TREE_NORESET
-         if (CHKw(w, Show_FOREST)) break;
-#endif
-         if (VIZCHKw(w)) {
-            FLG_t *p = w->procflgs + w->maxpflgs - 1;
-            while (p > w->procflgs && *p != w->rc.sortindx) --p;
-            if (*p == w->rc.sortindx) {
-               ++p;
-#ifndef USE_X_COLHDR
-               if (P_MAXPFLGS < *p) ++p;
-#endif
-               if (p < w->procflgs + w->maxpflgs) {
-                  w->rc.sortindx = *p;
-#ifndef TREE_NORESET
-                  OFFw(w, Show_FOREST);
-#endif
-               }
-            }
-         }
-         break;
-      case 'b':
-         if (VIZCHKw(w)) {
-#ifdef USE_X_COLHDR
-            if (!CHKw(w, Show_HIROWS))
-#else
-            if (!CHKw(w, Show_HICOLS | Show_HIROWS))
-#endif
-               show_msg("Nothing to highlight!");
-            else {
-               TOGw(w, Show_HIBOLD);
-               capsmk(w);
-            }
-         }
-         break;
-      case 'c':
-         VIZTOGw(w, Show_CMDLIN);
-         break;
-      case 'i':
-         VIZTOGw(w, Show_IDLEPS);
-         break;
-      case 'R':
-#ifdef TREE_NORESET
-         if (!CHKw(w, Show_FOREST)) VIZTOGw(w, Qsrt_NORMAL);
-#else
-         if (VIZCHKw(w)) {
-            TOGw(w, Qsrt_NORMAL);
-            OFFw(w, Show_FOREST);
-         }
-#endif
-         break;
-      case 'S':
-         if (VIZCHKw(w)) {
-            TOGw(w, Show_CTIMES);
-            show_msg(fmtmk("Cumulative time %s", CHKw(w, Show_CTIMES) ? "On" : "Off"));
-         }
-         break;
-      case 'U':
-      case 'u':
-         if (VIZCHKw(w)) {
-            const char *errmsg;
-            if ((errmsg = user_certify(w, linein("Which user (blank for all)"), ch)))
-               show_msg(errmsg);
-         }
-         break;
-      case 'V':
-         if (VIZCHKw(w)) {
-            TOGw(w, Show_FOREST);
-            if (!ENUviz(w, P_CMD))
-               show_msg(fmtmk("Forest mode %s", CHKw(w, Show_FOREST) ? "On" : "Off"));
-         }
-         break;
-      case 'x':
-         if (VIZCHKw(w)) {
-            TOGw(w, Show_HICOLS);
-            capsmk(w);
-#ifndef USE_X_COLHDR
-            if (ENUpos(w, w->rc.sortindx) < w->begpflg) {
-               if (CHKw(w, Show_HICOLS)) w->begpflg += 2;
-               else w->begpflg -= 2;
-               if (0 > w->begpflg) w->begpflg = 0;
-            }
-#endif
-         }
-         break;
-      case 'y':
-         if (VIZCHKw(w)) {
-            TOGw(w, Show_HIROWS);
-            capsmk(w);
-         }
-         break;
-      case 'z':
-         if (VIZCHKw(w)) {
-            TOGw(w, Show_COLORS);
-            capsmk(w);
-         }
-         break;
-      default:                    // keep gcc happy
-         break;
-   }
-} // end: keys_task
-
-
-static void keys_window (int ch) {
-   WIN_t *w = Curwin;             // avoid gcc bloat with a local copy
-
-   switch (ch) {
-      case '+':
-         if (ALTCHKw) wins_reflag(Flags_OFF, EQUWINS_xxx);
-         break;
-      case '-':
-         if (ALTCHKw) TOGw(w, Show_TASKON);
-         break;
-      case '=':
-         SETw(w, Show_IDLEPS | Show_TASKON);
-         w->rc.maxtasks = w->usrseltyp = w->begpflg = w->begtask = 0;
-         Monpidsidx = 0;
-         break;
-      case '_':
-         if (ALTCHKw) wins_reflag(Flags_TOG, Show_TASKON);
-         break;
-      case 'A':
-         Rc.mode_altscr = !Rc.mode_altscr;
-         break;
-      case 'a':
-      case 'w':
-         if (ALTCHKw) win_select(ch);
-         break;
-      case 'G':
-         if (ALTCHKw) {
-            char tmp[SMLBUFSIZ];
-            STRLCPY(tmp, linein(fmtmk("Rename window '%s' to (1-3 chars)", w->rc.winname)))
-            if (tmp[0]) win_names(w, tmp);
-         }
-         break;
-      case kbd_UP:
-         if (VIZCHKw(w)) if (0 < w->begtask) w->begtask -= 1;
-         break;
-      case kbd_DOWN:
-         if (VIZCHKw(w)) if (w->begtask < Frame_maxtask - 1) w->begtask += 1;
-         break;
-#ifdef USE_X_COLHDR
-      case kbd_LEFT:
-         if (VIZCHKw(w)) if (0 < w->begpflg) w->begpflg -= 1;
-         break;
-      case kbd_RIGHT:
-         if (VIZCHKw(w)) if (w->begpflg + 1 < w->totpflgs) w->begpflg += 1;
-         break;
-#else
-      case kbd_LEFT:
-         if (VIZCHKw(w)) if (0 < w->begpflg) {
-            w->begpflg -= 1;
-            if (P_MAXPFLGS < w->pflgsall[w->begpflg]) w->begpflg -= 2;
-         }
-         break;
-      case kbd_RIGHT:
-         if (VIZCHKw(w)) if (w->begpflg + 1 < w->totpflgs) {
-            if (P_MAXPFLGS < w->pflgsall[w->begpflg])
-               w->begpflg += (w->begpflg + 3 < w->totpflgs) ? 3 : 0;
-            else w->begpflg += 1;
-         }
-         break;
-#endif
-      case kbd_PGUP:
-         if (VIZCHKw(w)) if (0 < w->begtask) {
-               w->begtask -= (w->winlines - 1);
-               if (0 > w->begtask) w->begtask = 0;
-            }
-         break;
-      case kbd_PGDN:
-         if (VIZCHKw(w)) if (w->begtask < Frame_maxtask - 1) {
-               w->begtask += (w->winlines - 1);
-               if (w->begtask > Frame_maxtask - 1) w->begtask = Frame_maxtask - 1;
-               if (0 > w->begtask) w->begtask = 0;
-             }
-         break;
-      case kbd_HOME:
-         if (VIZCHKw(w)) w->begtask = w->begpflg = 0;
-         break;
-      case kbd_END:
-         if (VIZCHKw(w)) {
-            w->begtask = (Frame_maxtask - w->winlines) + 1;
-            if (0 > w->begtask) w->begtask = 0;
-            w->begpflg = w->endpflg;
-         }
-         break;
-      default:                    // keep gcc happy
-         break;
-   }
-} // end: keys_window
-
-
-static void keys_xtra (int ch) {
-// const char *xmsg;
-   WIN_t *w = Curwin;             // avoid gcc bloat with a local copy
-
-#ifdef TREE_NORESET
-   if (CHKw(w, Show_FOREST)) return;
-#else
-   OFFw(w, Show_FOREST);
-#endif
-   /* these keys represent old-top compatability --
-      they're grouped here so that if users could ever be weaned,
-      we would just whack do_key's key_tab entry and this function... */
-   switch (ch) {
-      case 'M':
-         w->rc.sortindx = P_MEM;
-//       xmsg = "Memory";
-         break;
-      case 'N':
-         w->rc.sortindx = P_PID;
-//       xmsg = "Numerical";
-         break;
-      case 'P':
-         w->rc.sortindx = P_CPU;
-//       xmsg = "CPU";
-         break;
-      case 'T':
-         w->rc.sortindx = P_TM2;
-//       xmsg = "Time";
-         break;
-      default:                    // keep gcc happy
-         break;
-   }
-// some have objected to this message, so we'll just keep silent...
-// show_msg(fmtmk("%s sort compatibility key honored", xtab[i].xmsg));
-} // end: keys_xtra
-
-/*######  Forest View support  ###########################################*/
-
-        /*
-         * We try to keep most existing code unaware of our activities. */
-static proc_t **Seed_ppt;                   // temporary window ppt ptr
-static proc_t **Tree_ppt;                   // resized by forest_create
-static int      Tree_idx;                   // frame_make initializes
-
-        /*
-         * This little recursive guy is the real forest view workhorse.
-         * He fills in the Tree_ppt array and also sets the child indent
-         * level which is stored in an unused proc_t padding byte. */
-static void forest_add (const int self, const int level) {
-   int i;
-
-   Tree_ppt[Tree_idx] = Seed_ppt[self];     // add this as root or child
-   Tree_ppt[Tree_idx++]->pad_3 = level;     // borrow 1 byte, 127 levels
-   for (i = self + 1; i < Frame_maxtask; i++) {
-      if (Seed_ppt[self]->tid == Seed_ppt[i]->tgid
-      || (Seed_ppt[self]->tid == Seed_ppt[i]->ppid && Seed_ppt[i]->tid == Seed_ppt[i]->tgid))
-         forest_add(i, level + 1);          // got one child any others?
-   }
-} // end: forest_add
-
-
-        /*
-         * This routine is responsible for preparing the proc_t's for
-         * a forest display in the designated window.  Upon completion,
-         * he'll replace the original window ppt with our specially
-         * ordered forest version. */
-static void forest_create (WIN_t *q) {
-   static int hwmsav;
-
-   Seed_ppt = q->ppt;                       // avoid passing WIN_t ptrs
-   if (!Tree_idx) {                         // do just once per frame
-      int i = 0;
-      Frame_srtflg = -1;                    // put in ascending ppid order
-      qsort(Seed_ppt, Frame_maxtask, sizeof(proc_t*), Fieldstab[P_PPD].sort);
-      if (hwmsav < Frame_maxtask) {         // grow, but never shrink
-         hwmsav = Frame_maxtask;
-         Tree_ppt = alloc_r(Tree_ppt, sizeof(proc_t*) * hwmsav);
-      }
-      while (0 == Seed_ppt[i]->ppid)        // identify trees (expect 2)
-         forest_add(i++, 0);                // add parent plus children
-   }
-   memcpy(Seed_ppt, Tree_ppt, sizeof(proc_t*) * Frame_maxtask);
-} // end: forest_create
-
-
-        /*
-         * This guy adds the artwork to either p->cmd or p->cmdline
-         * when in forest view mode, otherwise he just returns 'em. */
-static inline const char *forest_display (const WIN_t *q, const proc_t *p) {
-   static char buf[ROWMINSIZ];
-   const char *which = (CHKw(q, Show_CMDLIN)) ? *p->cmdline : p->cmd;
-
-   if (!CHKw(q, Show_FOREST) || !p->pad_3) return which;
-   snprintf(buf, sizeof(buf), "%*s%s", 4 * p->pad_3, " `- ", which);
-   return buf;
-} // end: forest_display
-
-/*######  Main Screen routines  ##########################################*/
-
-        /*
-         * Process keyboard input during the main loop */
-static void do_key (int ch) {
-   static struct {
-      void (*func)(int ch);
-      char keys[SMLBUFSIZ];
-   } key_tab[] = {
-      { keys_global,
-         { 'B', 'd', 'F', 'f', 'g', 'H', 'I', 'k', 'r', 's', 'Z' } },
-      { keys_summary,
-         { '1', 'C', 'l', 'm', 't' } },
-      { keys_task,
-         { '#', '<', '>', 'b', 'c', 'i', 'n', 'R', 'S'
-         , 'U', 'u', 'V', 'x', 'y', 'z' } },
-      { keys_window,
-         { '+', '-', '=', '_', 'A', 'a', 'G', 'w'
-         , kbd_UP, kbd_DOWN, kbd_LEFT, kbd_RIGHT, kbd_PGUP, kbd_PGDN
-         , kbd_HOME, kbd_END } },
-      { keys_xtra,
-         { 'M', 'N', 'P', 'T' } }
-   };
-   int i;
-
-   switch (ch) {
-      case 0:                // ignored (always)
-      case kbd_ESC:          // ignored (sometimes)
-         return;
-      case 'q':              // no return from this guy
-         bye_bye(NULL);
-      case 'W':              // no need for rebuilds
-         file_writerc();
-         return;
-      case '?':              // might need rebuilds,
-      case 'h':              // if curwin is changed
-         help_view();
-         break;
-      case kbd_ENTER:        // these two will have the effect of waking us
-      case kbd_SPACE:        // from 'select()', updating hotplugged resources
-         sysinfo_refresh(1); // and then refreshing the display
-         break;
-      default:               // and now, the real work...
-         for (i = 0; i < MAXTBL(key_tab); ++i)
-            if (strchr(key_tab[i].keys, ch)) {
-               key_tab[i].func(ch);
-               break;
-            }
-
-         if (!(i < MAXTBL(key_tab))) {
-            show_msg("Unknown command - try 'h' for help");
-            return;
-         }
-   };
-
-   /* The following assignment will force a rebuild of all column headers and
-      the PROC_FILLxxx flags.  It's NOT simply lazy programming.  Here are
-      some keys that COULD require new column headers and/or libproc flags:
-         'A' - likely
-         'c' - likely when !Mode_altscr, maybe when Mode_altscr
-         'F' - likely
-         'f' - likely
-         'g' - likely
-         'H' - likely (%CPU .fmts)
-         'I' - likely (%CPU .fmts)
-         'Z' - likely, if 'Curwin' changed when !Mode_altscr
-         '-' - likely (restricted to Mode_altscr)
-         '_' - likely (restricted to Mode_altscr)
-         '=' - maybe, but only when Mode_altscr
-         '+' - likely (restricted to Mode_altscr)
-         PLUS, likely for FOUR of the EIGHT cursor motion keys (scrolled)
-      ( At this point we have a human being involved and so have all the time )
-      ( in the world.  We can afford a few extra cpu cycles every now & then! )
-    */
-   Frames_resize = 1;
-} // end: do_key
-
-
-        /*
-         * State display *Helper* function to calc and display the state
-         * percentages for a single cpu.  In this way, we can support
-         * the following environments without the usual code bloat.
-         *    1) single cpu machines
-         *    2) modest smp boxes with room for each cpu's percentages
-         *    3) massive smp guys leaving little or no room for process
-         *       display and thus requiring the cpu summary toggle */
-static void summaryhlp (CPU_t *cpu, const char *pfx) {
-   /* we'll trim to zero if we get negative time ticks,
-      which has happened with some SMP kernels (pre-2.4?) */
- #define TRIMz(x)  ((tz = (SIC_t)(x)) < 0 ? 0 : tz)
-   SIC_t u_frme, s_frme, n_frme, i_frme, w_frme, x_frme, y_frme, z_frme, tot_frme, tz;
-   float scale;
-
-   u_frme = cpu->u - cpu->u_sav;
-   s_frme = cpu->s - cpu->s_sav;
-   n_frme = cpu->n - cpu->n_sav;
-   i_frme = TRIMz(cpu->i - cpu->i_sav);
-   if ((u_frme == 0) && (i_frme == 0)) i_frme = 100;
-   w_frme = cpu->w - cpu->w_sav;
-   x_frme = cpu->x - cpu->x_sav;
-   y_frme = cpu->y - cpu->y_sav;
-   z_frme = cpu->z - cpu->z_sav;
-   tot_frme = u_frme + s_frme + n_frme + i_frme + w_frme + x_frme + y_frme + z_frme;
-   if (1 > tot_frme) tot_frme = 1;
-   scale = 100.0 / (float)tot_frme;
-
-   /* display some kinda' cpu state percentages
-      (who or what is explained by the passed prefix) */
-   show_special(0, fmtmk(Cpu_States_fmts, pfx
-      , (float)u_frme * scale, (float)s_frme * scale
-      , (float)n_frme * scale, (float)i_frme * scale
-      , (float)w_frme * scale, (float)x_frme * scale
-      , (float)y_frme * scale, (float)z_frme * scale));
-
-   // remember for next time around
-   cpu->u_sav = cpu->u;
-   cpu->s_sav = cpu->s;
-   cpu->n_sav = cpu->n;
-   cpu->i_sav = cpu->i;
-   cpu->w_sav = cpu->w;
-   cpu->x_sav = cpu->x;
-   cpu->y_sav = cpu->y;
-   cpu->z_sav = cpu->z;
- #undef TRIMz
-} // end: summaryhlp
-
-
-        /*
-         * In support of a new frame:
-         *    1) Display uptime and load average (maybe)
-         *    2) Display task/cpu states (maybe)
-         *    3) Display memory & swap usage (maybe) */
-static void summary_show (void) {
- #define isROOM(f,n) (CHKw(w, f) && Msg_row + (n) < Screen_rows - 1)
- #define anyFLG 0xffffff
-   static CPU_t *smpcpu = NULL;
-   WIN_t *w = Curwin;             // avoid gcc bloat with a local copy
-
-   // Display Uptime and Loadavg
-   if (isROOM(View_LOADAV, 1)) {
-      if (!Rc.mode_altscr)
-         show_special(0, fmtmk(LOADAV_line, Myname, sprint_uptime()));
-      else
-         show_special(0, fmtmk(CHKw(w, Show_TASKON)? LOADAV_line_alt : LOADAV_line
-            , w->grpname, sprint_uptime()));
-      Msg_row += 1;
-   }
-
-   // Display Task and Cpu(s) States
-   if (isROOM(View_STATES, 2)) {
-      show_special(0, fmtmk(STATES_line1
-         , Thread_mode ? "Threads" : "Tasks"
-         , Frame_maxtask, Frame_running, Frame_sleepin
-         , Frame_stopped, Frame_zombied));
-      Msg_row += 1;
-
-      smpcpu = cpus_refresh(smpcpu);
-
-      if (CHKw(w, View_CPUSUM)) {
-         // display just the 1st /proc/stat line
-         summaryhlp(&smpcpu[Cpu_tot], "Cpu(s):");
-         Msg_row += 1;
-      } else {
-         int i;
-         char tmp[MEDBUFSIZ];
-         // display each cpu's states separately, screen height permitting...
-         for (i = 0; i < Cpu_tot; i++) {
-            snprintf(tmp, sizeof(tmp), "Cpu%-3d:", smpcpu[i].id);
-            summaryhlp(&smpcpu[i], tmp);
-            Msg_row += 1;
-            if (!isROOM(anyFLG, 1)) break;
-         }
-      }
-   }
-
-   // Display Memory and Swap stats
-   if (isROOM(View_MEMORY, 2)) {
-    #define mkM(x) (unsigned long)(kb_main_ ## x >> shift)
-    #define mkS(x) (unsigned long)(kb_swap_ ## x >> shift)
-      const char *which = "Kb";
-      int shift = 0;
-
-      /*** hotplug_acclimated ***/
-      if (kb_main_total > 9999999)       { which = "Mb"; shift = 10; }
-      if (kb_main_total > 9999999999ull) { which = "Gb"; shift = 20; }
-
-      show_special(0, fmtmk(MEMORY_twolines
-         , which, mkM(total), mkM(used), mkM(free),  mkM(buffers)
-         , which, mkS(total), mkS(used), mkS(free),  mkM(cached)));
-      Msg_row += 2;
-    #undef mkM
-    #undef mkS
-   }
-
- #undef isROOM
- #undef anyFLG
-} // end: summary_show
-
-
-        /*
-         * Display information for a single task row. */
-static void task_show (const WIN_t *q, const proc_t *p) {
- #define makeCOL(va...)  snprintf(cbuf, sizeof(cbuf), f, ## va)
- #define makeVAR(v)  { f = VARCOL_fmts; makeCOL(q->varcolsz, q->varcolsz, v); }
- #define pages2K(n)  (unsigned long)( (n) << Pg2K_shft )
-   char rbuf[ROWMINSIZ], *rp;
-   int j, x;
-
-   // we must begin a row with a possible window number in mind...
-   *(rp = rbuf) = '\0';
-   if (Rc.mode_altscr) rp = scat(rp, " ");
-
-   for (x = 0; x < q->maxpflgs; x++) {
-      char        cbuf[SCREENMAX];
-      FLG_t       i = q->procflgs[x];           // support for our field/column
-      const char *f = Fieldstab[i].fmts;        // macro AND sometimes the fmt
-      int         s = Fieldstab[i].scale;       // string must be altered !
-      int         w = Fieldstab[i].width;
-
-      switch (i) {
-#ifndef USE_X_COLHDR
-         // these 2 aren't real procflgs, they're used in column highlighting!
-         case X_XON:
-         case X_XOF:
-            /* treat running tasks specially - entire row may get highlighted
-               so we needn't turn it on and we MUST NOT turn it off */
-            if (!('R' == p->state && CHKw(q, Show_HIROWS)))
-               rp = scat(rp, X_XON == i ? q->capclr_rowhigh : q->capclr_rownorm);
-            continue;
-#endif
-         case P_CGR:
-            // our kernel may not support cgroups
-            makeVAR(p->cgroup ? *p->cgroup : "n/a");
-            break;
-         case P_CMD:
-            makeVAR(forest_display(q, p));
-            break;
-         case P_COD:
-            makeCOL(scale_num(pages2K(p->trs), w, s));
-            break;
-         case P_CPN:
-            makeCOL(p->processor);
-            break;
-         case P_CPU:
-         {  float u = (float)p->pcpu * Frame_etscale;
-            if (u > Cpu_pmax) u = Cpu_pmax;
-            makeCOL(u);
-         }
-            break;
-         case P_DAT:
-            makeCOL(scale_num(pages2K(p->drs), w, s));
-            break;
-         case P_DRT:
-            makeCOL(scale_num((unsigned long)p->dt, w, s));
-            break;
-         case P_FLG:
-         {  char tmp[SMLBUFSIZ];
-            snprintf(tmp, sizeof(tmp), f, (long)p->flags);
-            for (j = 0; tmp[j]; j++) if ('0' == tmp[j]) tmp[j] = '.';
-            f = tmp;
-            makeCOL("");
-         }
-            break;
-         case P_FL1:
-            makeCOL(scale_num(p->maj_flt, w, s));
-            break;
-         case P_FL2:
-            makeCOL(scale_num(p->min_flt, w, s));
-            break;
-         case P_GID:
-            makeCOL(p->egid);
-            break;
-         case P_GRP:
-            makeCOL(p->egroup);
-            break;
-         case P_MEM:
-            makeCOL((float)pages2K(p->resident) * 100 / kb_main_total);
-            break;
-         case P_NCE:
-            makeCOL((int)p->nice);
-            break;
-#ifdef OOMEM_ENABLE
-         case P_OOA:
-            makeCOL((int)p->oom_adj);
-            break;
-         case P_OOM:
-            makeCOL((long)p->oom_score);
-            break;
-#endif
-         case P_PGD:
-            makeCOL(p->pgrp);
-            break;
-         case P_PID:
-            makeCOL(p->tid);
-            break;
-         case P_PPD:
-            makeCOL(p->ppid);
-            break;
-         case P_PRI:
-            if (-99 > p->priority || 999 < p->priority) {
-               f = " rt ";
-               makeCOL("");
-            } else
-               makeCOL((int)p->priority);
-            break;
-         case P_RES:
-            makeCOL(scale_num(pages2K(p->resident), w, s));
-            break;
-         case P_SGD:
-            makeVAR(p->supgid ? p->supgid : "n/a");
-            break;
-         case P_SGN:
-            makeVAR(p->supgrp ? p->supgrp : "n/a");
-            break;
-         case P_SHR:
-            makeCOL(scale_num(pages2K(p->share), w, s));
-            break;
-         case P_SID:
-            makeCOL(p->session);
-            break;
-         case P_STA:
-            makeCOL(p->state);
-            break;
-         case P_SWP:
-            makeCOL(scale_num(p->vm_swap, w, s));
-            break;
-         case P_TGD:
-            makeCOL(p->tgid);
-            break;
-         case P_THD:
-            makeCOL(p->nlwp);
-            break;
-         case P_TME:
-         case P_TM2:
-         {  TIC_t t = p->utime + p->stime;
-            if (CHKw(q, Show_CTIMES)) t += (p->cutime + p->cstime);
-            makeCOL(scale_tics(t, w));
-         }
-            break;
-         case P_TPG:
-            makeCOL(p->tpgid);
-            break;
-         case P_TTY:
-         {  char tmp[SMLBUFSIZ];
-            dev_to_tty(tmp, w, p->tty, p->tid, ABBREV_DEV);
-            makeCOL(tmp);
-         }
-            break;
-         case P_UED:
-            makeCOL(p->euid);
-            break;
-         case P_UEN:
-            makeCOL(p->euser);
-            break;
-         case P_URD:
-            makeCOL(p->ruid);
-            break;
-         case P_URN:
-            makeCOL(p->ruser);
-            break;
-         case P_USD:
-            makeCOL(p->suid);
-            break;
-         case P_USN:
-            makeCOL(p->suser);
-            break;
-         case P_VRT:
-            makeCOL(scale_num(pages2K(p->size), w, s));
-            break;
-         case P_WCH:
-            if (No_ksyms) {
-#ifdef CASEUP_HEXES
-               makeVAR(fmtmk("%08" KLF "X", p->wchan))
-#else
-               makeVAR(fmtmk("%08" KLF "x", p->wchan))
-#endif
-            } else
-               makeVAR(lookup_wchan(p->wchan, p->tid))
-            break;
-         default:                 // keep gcc happy
-            break;
-
-        } // end: switch 'procflag'
-
-        rp = scat(rp, cbuf);
-   } // end: for 'maxpflgs'
-
-   PUFF("\n%s%s%s", (CHKw(q, Show_HIROWS) && 'R' == p->state)
-      ? q->capclr_rowhigh : q->capclr_rownorm
-      , rbuf
-      , q->eolcap);
- #undef makeCOL
- #undef makeVAR
- #undef pages2K
-} // end: task_show
-
-
-        /*
-         * Squeeze as many tasks as we can into a single window,
-         * after sorting the passed proc table. */
-static int window_show (WIN_t *q, int wmax) {
- /* the isBUSY macro determines if a task is 'active' --
-    it returns true if some cpu was used since the last sample.
-    ( actual 'running' tasks will be a subset of those selected ) */
- #define isBUSY(x)   (0 < x->pcpu)
- #define winMIN(a,b) ((a < b) ? a : b)
-   int i, lwin;
-
-   // Display Column Headings -- and distract 'em while we sort (maybe)
-   PUFF("\n%s%s%s", q->capclr_hdr, q->columnhdr, q->eolcap);
-
-   if (CHKw(q, Show_FOREST))
-      forest_create(q);
-   else {
-      if (CHKw(q, Qsrt_NORMAL)) Frame_srtflg = 1;   // this is always needed!
-      else Frame_srtflg = -1;
-      Frame_ctimes = CHKw(q, Show_CTIMES);          // this & next, only maybe
-      Frame_cmdlin = CHKw(q, Show_CMDLIN);
-      qsort(q->ppt, Frame_maxtask, sizeof(proc_t*), Fieldstab[q->rc.sortindx].sort);
-   }
-
-   i = q->begtask;
-   if (i >= Frame_maxtask) i = q->begtask = Frame_maxtask - 1;
-   lwin = 1;                                        // 1 for the column header
-   wmax = winMIN(wmax, q->winlines + 1);            // ditto for winlines, too
-
-   /* the least likely scenario is also the most costly, so we'll try to avoid
-      checking some stuff with each iteration and check it just once... */
-   if (CHKw(q, Show_IDLEPS) && !q->usrseltyp)
-      while (i < Frame_maxtask && lwin < wmax) {
-         task_show(q, q->ppt[i++]);
-         ++lwin;
-      }
-   else
-      while (i < Frame_maxtask && lwin < wmax) {
-         if ((CHKw(q, Show_IDLEPS) || isBUSY(q->ppt[i]))
-         && user_matched(q, q->ppt[i])) {
-            task_show(q, q->ppt[i]);
-            ++lwin;
-         }
-         ++i;
-      }
-
-   return lwin;
- #undef winMIN
- #undef isBUSY
-} // end: window_show
-
-/*######  Entry point plus two  ##########################################*/
-
-        /*
-         * This guy's just a *Helper* function who apportions the
-         * remaining amount of screen real estate under multiple windows */
-static void framehlp (int wix, int max) {
-   int i, size, wins;
-
-   // calc remaining number of visible windows
-   for (i = wix, wins = 0; i < GROUPSMAX; i++)
-      if (CHKw(&Winstk[i], Show_TASKON))
-         ++wins;
-
-   if (!wins) wins = 1;
-   // deduct 1 line/window for the columns heading
-   size = (max - wins) / wins;
-
-   /* for subject window, set WIN_t winlines to either the user's
-      maxtask (1st choice) or our 'foxized' size calculation
-      (foxized  adj. -  'fair and balanced') */
-   Winstk[wix].winlines =
-      Winstk[wix].rc.maxtasks ? Winstk[wix].rc.maxtasks : size;
-} // end: framehlp
-
-
-        /*
-         * Initiate the Frame Display Update cycle at someone's whim!
-         * This routine doesn't do much, mostly he just calls others.
-         *
-         * (Whoa, wait a minute, we DO caretake those row guys, plus)
-         * (we CALCULATE that IMPORTANT Max_lines thingy so that the)
-         * (*subordinate* functions invoked know WHEN the user's had)
-         * (ENOUGH already.  And at Frame End, it SHOULD be apparent)
-         * (WE am d'MAN -- clearing UNUSED screen LINES and ensuring)
-         * (the CURSOR is STUCK in just the RIGHT place, know what I)
-         * (mean?  Huh, "doesn't DO MUCH"!  Never, EVER think or say)
-         * (THAT about THIS function again, Ok?  Good that's better.)
-         *
-         * (ps. we ARE the UNEQUALED justification KING of COMMENTS!)
-         * (No, I don't mean significance/relevance, only alignment.)
-         */
-static void frame_make (void) {
-   WIN_t *w = Curwin;             // avoid gcc bloat with a local copy
-   int i, scrlins;
-
-   // deal with potential signals since the last time around...
-   if (Frames_paused) pause_pgm();
-   if (Frames_resize) zap_fieldstab();
-
-   // whoa first time, gotta' prime the pump...
-   if (-1 == Pseudo_row) {
-      procs_refresh();
-      putp(Cap_clr_scr);
-      usleep(LIB_USLEEP);
-   } else
-      putp(Batch ? "\n\n" : Cap_home);
-
-   putp(Cap_curs_hide);
-   procs_refresh();
-   sysinfo_refresh(0);
-
-   Tree_idx = Pseudo_row = Msg_row = scrlins = 0;
-   summary_show();
-   Max_lines = (Screen_rows - Msg_row) - 1;
-
-   if (!Rc.mode_altscr) {
-      // only 1 window to show so, piece o' cake
-      w->winlines = w->rc.maxtasks ? w->rc.maxtasks : Max_lines;
-      scrlins = window_show(w, Max_lines);
-   } else {
-      // maybe NO window is visible but assume, pieces o' cakes
-      for (i = 0 ; i < GROUPSMAX; i++) {
-         if (CHKw(&Winstk[i], Show_TASKON)) {
-            framehlp(i, Max_lines - scrlins);
-            scrlins += window_show(&Winstk[i], Max_lines - scrlins);
-         }
-         if (Max_lines <= scrlins) break;
-      }
-   }
-
-   /* clear to end-of-screen (critical if last window is 'idleps off'),
-      then put the cursor in-its-place, and rid us of any prior frame's msg
-      (main loop must iterate such that we're always called before sleep) */
-   if (scrlins < Max_lines) {
-      putp(Cap_nl_clreos);
-      PSU_CLREOS(Pseudo_row);
-   }
-   if (VIZISw(w) && CHKw(w, View_SCROLL)) show_scroll();
-   else PUTT("%s%s", tg2(0, Msg_row), Cap_clr_eol);
-   putp(Cap_curs_norm);
-   fflush(stdout);
-
-   /* we'll deem any terminal not supporting tgoto as dumb and disable
-      the normal non-interactive output optimization... */
-   if (!Cap_can_goto) PSU_CLREOS(0);
-} // end: frame_make
-
-
-        /*
-         * duh... */
-int main (int dont_care_argc, char **argv) {
-   (void)dont_care_argc;
-   before(*argv);
-                                        //                 +-------------+
-   wins_stage_1();                      //                 top (sic) slice
-   configs_read();                      //                 > spread etc, <
-   parse_args(&argv[1]);                //                 > lean stuff, <
-   whack_terminal();                    //                 > onions etc. <
-   wins_stage_2();                      //                 as bottom slice
-                                        //                 +-------------+
-
-   for (;;) {
-      struct timeval tv;
-
-      frame_make();
-
-      if (Msg_awaiting) show_msg(Msg_delayed);
-      if (0 < Loops) --Loops;
-      if (!Loops) bye_bye(NULL);
-
-      tv.tv_sec = Rc.delay_time;
-      tv.tv_usec = (Rc.delay_time - (int)Rc.delay_time) * 1000000;
-
-      if (Batch)
-         select(0, NULL, NULL, NULL, &tv);
-      else {
-         fd_set fs;
-
-         FD_ZERO(&fs);
-         FD_SET(STDIN_FILENO, &fs);
-         if (0 < select(STDIN_FILENO + 1, &fs, NULL, NULL, &tv))
-            do_key(keyin(0));
-         /* note:  above select might have been interrupted by some signal
-                   in which case the return code would have been -1 and an
-                   integer (volatile) switch set.  that in turn will cause
-                   frame_make() to deal with it if we survived the handler
-         */
-      }
-   }
-   return 0;
-} // end: main
diff --git a/top.h b/top.h
deleted file mode 100644
index a409c61a..00000000
--- a/top.h
+++ /dev/null
@@ -1,707 +0,0 @@
-/* top.h - Header file:         show Linux processes */
-/*
- * Copyright (c) 2002-2011, by: James C. Warner
- *    All rights reserved.      8921 Hilloway Road
- *                              Eden Prairie, Minnesota 55347 USA
- *
- * This file may be used subject to the terms and conditions of the
- * GNU Library General Public License Version 2, or any later version
- * at your option, as published by the Free Software Foundation.
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Library General Public License for more details.
- */
-/* For contributions to this program, the author wishes to thank:
- *    Craig Small, <csmall@small.dropbear.id.au>
- *    Albert D. Cahalan, <albert@users.sf.net>
- */
-#ifndef _Itop
-#define _Itop
-
-#include "proc/readproc.h"
-
-        /* Development/Debugging defines ----------------------------------- */
-//#define ATEOJ_RPTHSH            /* report on hash specifics, at end-of-job */
-//#define ATEOJ_RPTSTD            /* report on misc stuff, at end-of-job     */
-//#define CASEUP_HEXES            /* show any hex values in upper case       */
-//#define CASEUP_SUFIX            /* show time/mem/cnts suffix in upper case */
-//#define EQUCOLHDRYES            /* yes, do equalize column header lengths  */
-//#define OFF_HST_HASH            /* use BOTH qsort+bsrch vs. hashing scheme */
-//#define OFF_STDIOLBF            /* disable our own stdout _IOFBF override  */
-//#define OOMEM_ENABLE            /* enable the SuSE out-of-memory additions */
-//#define PRETEND2_5_X            /* pretend we're linux 2.5.x (for IO-wait) */
-//#define PRETEND4CPUS            /* pretend we're smp with 4 ticsers (sic)  */
-//#define PRETENDNOCAP            /* use a terminal without essential caps   */
-//#define RCFILE_NOERR            /* rcfile errs silently default, vs. fatal */
-//#define RMAN_IGNORED            /* don't consider auto right margin glitch */
-//#define STRCMPNOCASE            /* use strcasecmp vs. strcmp when sorting  */
-//#define TERMIOS_ONLY            /* just limp along with native input only  */
-//#define TREE_NORESET            /* sort keys do NOT force forest view OFF  */
-//#define USE_X_COLHDR            /* emphasize header vs. whole col, for 'x' */
-
-
-/*######  Notes, etc.  ###################################################*/
-
-        /* The following convention is used to identify those areas where
-           adaptations for hotplugging are to be found ...
-              *** hotplug_acclimated ***
-           ( hopefully libproc will also be supportive of our efforts ) */
-
-        /* And there are still some of these lurking here and there...
-              FIXME - blah, blah... */
-
-        /* For introducing inaugural cgroup support, thanks to:
-              Jan Gorig <jgorig@redhat.com> - April, 2011 */
-
-
-#ifdef PRETEND2_5_X
-#define linux_version_code LINUX_VERSION(2,5,43)
-#endif
-
-#ifdef STRCMPNOCASE
-#define STRSORTCMP  strcasecmp
-#else
-#define STRSORTCMP  strcmp
-#endif
-
-
-/*######  Some Miscellaneous constants  ##################################*/
-
-        /* The default delay twix updates */
-#define DEF_DELAY  3.0
-
-        /* Length of time a message is displayed and the duration
-           of a 'priming' wait during library startup (in microseconds) */
-#define MSG_USLEEP  (useconds_t)1250000
-#define LIB_USLEEP  (useconds_t)150000
-
-        /* Specific process id monitoring support (command line only) */
-#define MONPIDMAX  20
-
-        /* Output override minimums (the -w switch and/or env vars) */
-#define W_MIN_COL  3
-#define W_MIN_ROW  3
-
-        /* Miscellaneous buffers with liberal values and some other defines
-           -- mostly just to pinpoint source code usage/dependancies */
-#define SCREENMAX   512
-   /* the above might seem pretty stingy, until you consider that with every
-      one of top's fields displayed it's less than 200 bytes of column header
-      -- so SCREENMAX provides for all fields plus a 300+ byte command line */
-#define CAPBUFSIZ    32
-#define CLRBUFSIZ    64
-#define PFLAGSSIZ    64
-#define SMLBUFSIZ   128
-#define MEDBUFSIZ   256
-#define LRGBUFSIZ   512
-#define OURPATHSZ  1024
-#define BIGBUFSIZ  2048
-   /* in addition to the actual display data, our row might have to accomodate
-      many termcap/color transitions - these definitions ensure we have room */
-#define ROWMINSIZ  ( SCREENMAX +  4 * (CAPBUFSIZ + CLRBUFSIZ) )
-#define ROWMAXSIZ  ( SCREENMAX + 16 * (CAPBUFSIZ + CLRBUFSIZ) )
-
-   // support for keyboard stuff (cursor motion keystrokes, mostly)
-#define kbd_ENTER  '\n'
-#define kbd_ESC    '\033'
-#define kbd_SPACE  ' '
-#define kbd_UP     '\x81'
-#define kbd_DOWN   '\x82'
-#define kbd_RIGHT  '\x83'
-#define kbd_LEFT   '\x84'
-#define kbd_PGUP   '\x85'
-#define kbd_PGDN   '\x86'
-#define kbd_END    '\x87'
-#define kbd_HOME   '\x88'
-#define kbd_BKSP   '\x89'
-#define kbd_INS    '\x8a'
-#define kbd_DEL    '\x8b'
-
-
-/* #####  Enum's and Typedef's  ############################################ */
-
-        /* Flags for each possible field (and then some) --
-           these MUST be kept in sync with the FLD_t Fieldstab[] array !! */
-enum pflag {
-   P_PID = 0, P_PPD,
-   P_UED, P_UEN, P_URD, P_URN, P_USD, P_USN,
-   P_GID, P_GRP, P_PGD, P_TTY, P_TPG, P_SID,
-   P_PRI, P_NCE, P_THD,
-   P_CPN, P_CPU, P_TME, P_TM2,
-   P_MEM, P_VRT, P_SWP, P_RES, P_COD, P_DAT, P_SHR,
-   P_FL1, P_FL2, P_DRT,
-   P_STA, P_CMD, P_WCH, P_FLG, P_CGR,
-   P_SGD, P_SGN, P_TGD,
-#ifdef OOMEM_ENABLE
-   P_OOA, P_OOM,
-#endif
-#ifdef USE_X_COLHDR
-   // not really pflags, used with tbl indexing
-   P_MAXPFLGS
-#else
-   // not really pflags, used with tbl indexing & col highlighting
-   P_MAXPFLGS, X_XON, X_XOF
-#endif
-};
-
-        /* The scaling 'type' used with scale_num() -- this is how
-           the passed number is interpreted should scaling be necessary */
-enum scale_num {
-   SK_no, SK_Kb, SK_Mb, SK_Gb, SK_Tb
-};
-
-        /* This typedef just ensures consistent 'process flags' handling */
-typedef unsigned char FLG_t;
-
-        /* These typedefs attempt to ensure consistent 'ticks' handling */
-typedef unsigned long long TIC_t;
-typedef          long long SIC_t;
-
-        /* Sort support, callback function signature */
-typedef int (*QFP_t)(const void *, const void *);
-
-        /* This structure consolidates the information that's used
-           in a variety of display roles. */
-typedef struct FLD_t {
-   const char   *head;          // name for col heads + toggle/reorder fields
-   const char   *fmts;          // snprintf format string for field display
-   const int     width;         // field width, if applicable
-   const int     scale;         // scale_num type, if applicable
-   const QFP_t   sort;          // sort function
-   const int     lflg;          // PROC_FILLxxx flag(s) needed by this field
-   const char   *desc;          // description for fields management
-} FLD_t;
-
-#ifdef OFF_HST_HASH
-        /* This structure supports 'history' processing and ultimately records
-           one piece of critical information from one frame to the next --
-           we don't calc and save data that goes unused like the old top. */
-typedef struct HST_t {
-   TIC_t tics;                  // last frame's tics count
-   int   pid;                   // record 'key'
-} HST_t;
-#else
-        /* This structure supports 'history' processing and ultimately records
-           one piece of critical information from one frame to the next --
-           we don't calc and save data that goes unused like the old top nor
-           do we incure the overhead of sorting to support a binary search
-           (or worse, a friggin' for loop) when retrieval is necessary! */
-typedef struct HST_t {
-   TIC_t tics;                  // last frame's tics count
-   int   pid;                   // record 'key'
-   int   lnk;                   // next on hash chain
-} HST_t;
-#endif
-
-        /* This structure stores a frame's cpu tics used in history
-           calculations.  It exists primarily for SMP support but serves
-           all environments. */
-typedef struct CPU_t {
-   /* other kernels: u == user/us, n == nice/ni, s == system/sy, i == idle/id
-      2.5.41 kernel: w == IO-wait/wa (io wait time)
-      2.6.0  kernel: x == hi (hardware irq time), y == si (software irq time)
-      2.6.11 kernel: z == st (virtual steal time) */
-   TIC_t u, n, s, i, w, x, y, z; // as represented in /proc/stat
-   TIC_t u_sav, s_sav, n_sav, i_sav, w_sav, x_sav, y_sav, z_sav; // in the order of our display
-   unsigned id;  // the CPU ID number
-} CPU_t;
-
-
-        /* /////////////////////////////////////////////////////////////// */
-        /* Special Section: multiple windows/field groups  --------------- */
-        /* ( kind of a header within a header: constants, types & macros ) */
-
-#define CAPTABMAX  9             /* max entries in each win's caps table   */
-#define GROUPSMAX  4             /* the max number of simultaneous windows */
-#define WINNAMSIZ  4             /* size of RCW_t winname buf (incl '\0')  */
-#define GRPNAMSIZ  WINNAMSIZ+2   /* window's name + number as in: '#:...'  */
-
-        /* The Persistent 'Mode' flags!
-           These are preserved in the rc file, as a single integer and the
-           letter shown is the corresponding 'command' toggle */
-        // 'View_' flags affect the summary (minimum), taken from 'Curwin'
-#define View_CPUSUM  0x008000     // '1' - show combined cpu stats (vs. each)
-#define View_LOADAV  0x004000     // 'l' - display load avg and uptime summary
-#define View_STATES  0x002000     // 't' - display task/cpu(s) states summary
-#define View_MEMORY  0x001000     // 'm' - display memory summary
-#define View_NOBOLD  0x000008     // 'B' - disable 'bold' attribute globally
-#define View_SCROLL  0x080000     // 'C' - enable coordinates msg w/ scrolling
-        // 'Show_' & 'Qsrt_' flags are for task display in a visible window
-#define Show_COLORS  0x000800     // 'z' - show in color (vs. mono)
-#define Show_HIBOLD  0x000400     // 'b' - rows and/or cols bold (vs. reverse)
-#define Show_HICOLS  0x000200     // 'x' - show sort column emphasized
-#define Show_HIROWS  0x000100     // 'y' - show running tasks highlighted
-#define Show_CMDLIN  0x000080     // 'c' - show cmdline vs. name
-#define Show_CTIMES  0x000040     // 'S' - show times as cumulative
-#define Show_IDLEPS  0x000020     // 'i' - show idle processes (all tasks)
-#define Show_TASKON  0x000010     // '-' - tasks showable when Mode_altscr
-#define Show_FOREST  0x000002     // 'V' - show cmd/cmdlines with ascii art
-#define Qsrt_NORMAL  0x000004     // 'R' - reversed column sort (high to low)
-        // these flag(s) have no command as such - they're for internal use
-#define EQUWINS_xxx  0x000001     // rebalance all wins & tasks (off 'i'/ 'n')
-
-        // Default flags if there's no rcfile to provide user customizations
-#define DEF_WINFLGS ( View_LOADAV | View_STATES | View_CPUSUM | View_MEMORY \
-   | Show_HIBOLD | Show_HIROWS | Show_IDLEPS | Show_TASKON | Qsrt_NORMAL )
-
-        /* These are used to direct wins_reflag */
-enum reflag_enum {
-   Flags_TOG, Flags_SET, Flags_OFF
-};
-
-        /* These are used to direct win_warn */
-enum warn_enum {
-   Warn_ALT, Warn_VIZ
-};
-
-        /* This type helps support both a window AND the rcfile */
-typedef struct RCW_t {  // the 'window' portion of an rcfile
-   FLG_t  sortindx;             // sort field, represented as a procflag
-   int    winflags,             // 'view', 'show' and 'sort' mode flags
-          maxtasks,             // user requested maximum, 0 equals all
-          summclr,                      // color num used in summ info
-          msgsclr,                      //        "       in msgs/pmts
-          headclr,                      //        "       in cols head
-          taskclr;                      //        "       in task rows
-   char   winname [WINNAMSIZ],          // window name, user changeable
-          fieldscur [PFLAGSSIZ];        // fields displayed and ordered
-} RCW_t;
-
-        /* This represents the complete rcfile */
-typedef struct RCF_t {
-   int    mode_altscr;          // 'A' - Alt display mode (multi task windows)
-   int    mode_irixps;          // 'I' - Irix vs. Solaris mode (SMP-only)
-   float  delay_time;           // 'd'/'s' - How long to sleep twixt updates
-   int    win_index;            // Curwin, as index
-   RCW_t  win [GROUPSMAX];      // a 'WIN_t.rc' for each window
-} RCF_t;
-
-        /* This structure stores configurable information for each window.
-           By expending a little effort in its creation and user requested
-           maintainence, the only real additional per frame cost of having
-           windows is an extra sort -- but that's just on pointers! */
-typedef struct WIN_t {
-   FLG_t  pflgsall [PFLAGSSIZ],        // all 'active/on' fieldscur, as enum
-          procflgs [PFLAGSSIZ];        // fieldscur subset, as enum
-   RCW_t  rc;                          // stuff that gets saved in the rcfile
-   int    winnum,          // a window's number (array pos + 1)
-          winlines,        // current task window's rows (volatile)
-          maxpflgs,        // number of displayed procflgs ("on" in fieldscur)
-          totpflgs,        // total of displayable procflgs in pflgsall array
-          begpflg,         // scrolled beginning pos into pflgsall array
-          endpflg,         // scrolled ending pos into pflgsall array
-          begtask,         // scrolled beginning pos into Frame_maxtask
-          varcolsz,        // max length of variable width column(s)
-          usrseluid,       // validated uid for 'u/U' user selection
-          usrseltyp,       // the basis for matching above uid
-          hdrcaplen;       // column header xtra caps len, if any
-   char   capclr_sum [CLRBUFSIZ],      // terminfo strings built from
-          capclr_msg [CLRBUFSIZ],      //   RCW_t colors (& rebuilt too),
-          capclr_pmt [CLRBUFSIZ],      //   but NO recurring costs !
-          capclr_hdr [CLRBUFSIZ],      //   note: sum, msg and pmt strs
-          capclr_rowhigh [CLRBUFSIZ],  //         are only used when this
-          capclr_rownorm [CLRBUFSIZ],  //         window is the 'Curwin'!
-          cap_bold [CAPBUFSIZ],        // support for View_NOBOLD toggle
-          grpname [GRPNAMSIZ],         // window number:name, printable
-#ifdef USE_X_COLHDR
-          columnhdr [ROWMINSIZ],       // column headings for procflgs
-#else
-          columnhdr [SCREENMAX],       // column headings for procflgs
-#endif
-         *eolcap,                      // window specific eol termcap
-         *captab [CAPTABMAX];          // captab needed by show_special()
-   proc_t **ppt;                       // this window's proc_t ptr array
-   struct WIN_t *next,                 // next window in window stack
-                *prev;                 // prior window in window stack
-} WIN_t;
-
-        // Used to test/manipulate the window flags
-#define CHKw(q,f)    (int)((q)->rc.winflags & (f))
-#define TOGw(q,f)    (q)->rc.winflags ^=  (f)
-#define SETw(q,f)    (q)->rc.winflags |=  (f)
-#define OFFw(q,f)    (q)->rc.winflags &= ~(f)
-#define ALTCHKw      (Rc.mode_altscr ? 1 : win_warn(Warn_ALT))
-#define VIZISw(q)    (!Rc.mode_altscr || CHKw(q,Show_TASKON))
-#define VIZCHKw(q)   (VIZISw(q)) ? 1 : win_warn(Warn_VIZ)
-#define VIZTOGw(q,f) (VIZISw(q)) ? TOGw(q,(f)) : win_warn(Warn_VIZ)
-
-        // Used to test/manipulte fieldscur values
-#define FLDget(q,i)  ((FLG_t)((q)->rc.fieldscur[i] & 0x7f) - FLD_OFFSET)
-#define FLDtog(q,i)  ((q)->rc.fieldscur[i] ^= 0x80)
-#define FLDviz(q,i)  ((q)->rc.fieldscur[i] &  0x80)
-#define ENUchk(w,E)  (NULL != strchr((w)->rc.fieldscur, (E + FLD_OFFSET) | 0x80))
-#define ENUset(w,E)  do { char *t; \
-      if ((t = strchr((w)->rc.fieldscur, E + FLD_OFFSET))) \
-         *t = (E + FLD_OFFSET) | 0x80; \
-   /* else fieldscur char already has high bit on! */ \
-   } while (0)
-#define ENUviz(w,E)  (NULL != memchr((w)->procflgs, E, (w)->maxpflgs))
-#define ENUpos(w,E)  ((int)((FLG_t*)memchr((w)->pflgsall, E, (w)->totpflgs) - (w)->pflgsall))
-
-
-        /* Special Section: end ------------------------------------------ */
-        /* /////////////////////////////////////////////////////////////// */
-
-
-/*######  Some Miscellaneous Macro definitions  ##########################*/
-
-        /* Yield table size as 'int' */
-#define MAXTBL(t)  (int)(sizeof(t) / sizeof(t[0]))
-
-        /* A null-terminating strncpy, assuming strlcpy is not available.
-           ( and assuming callers don't need the string length returned ) */
-#define STRLCPY(dst,src) { strncpy(dst, src, sizeof(dst)); dst[sizeof(dst) - 1] = '\0'; }
-
-        /* Used to clear all or part of our Pseudo_screen */
-#define PSU_CLREOS(y) memset(&Pseudo_screen[ROWMAXSIZ*y], '\0', Pseudo_size-(ROWMAXSIZ*y))
-
-        /* Used as return arguments in *some* of the sort callbacks */
-#define SORT_lt  ( Frame_srtflg > 0 ?  1 : -1 )
-#define SORT_gt  ( Frame_srtflg > 0 ? -1 :  1 )
-#define SORT_eq  0
-
-        /* Used to create *most* of the sort callback functions
-           note: some of the callbacks are NOT your father's callbacks, they're
-                 highly optimized to save them ol' precious cycles! */
-#define SCB_NAME(f) sort_P_ ## f
-#define SCB_NUM1(f,n) \
-   static int SCB_NAME(f) (const proc_t **P, const proc_t **Q) { \
-      if ( (*P)->n < (*Q)->n ) return SORT_lt; \
-      if ( (*P)->n > (*Q)->n ) return SORT_gt; \
-      return SORT_eq; }
-#define SCB_NUMx(f,n) \
-   static int SCB_NAME(f) (const proc_t **P, const proc_t **Q) { \
-      return Frame_srtflg * ( (*Q)->n - (*P)->n ); }
-#define SCB_STRS(f,s) \
-   static int SCB_NAME(f) (const proc_t **P, const proc_t **Q) { \
-      return Frame_srtflg * STRSORTCMP((*Q)->s, (*P)->s); }
-#define SCB_STRV(f,b,v,s) \
-   static int SCB_NAME(f) (const proc_t **P, const proc_t **Q) { \
-      if (b) { \
-         if (!(*P)->v || !(*Q)->v) return SORT_eq; \
-         return Frame_srtflg * STRSORTCMP((*Q)->v[0], (*P)->v[0]); } \
-      return Frame_srtflg * STRSORTCMP((*Q)->s, (*P)->s); }
-#define SCB_STRX(f,s) \
-   int strverscmp(const char *s1, const char *s2); \
-   static int SCB_NAME(f) (const proc_t **P, const proc_t **Q) { \
-      return Frame_srtflg * strverscmp((*Q)->s, (*P)->s); }
-
-/*
- * The following two macros are used to 'inline' those portions of the
- * display process requiring formatting, while protecting against any
- * potential embedded 'millesecond delay' escape sequences.
- */
-        /**  PUTT - Put to Tty (used in many places)
-               . for temporary, possibly interactive, 'replacement' output
-               . may contain ANY valid terminfo escape sequences
-               . need NOT represent an entire screen row */
-#define PUTT(fmt,arg...) do { \
-      char _str[ROWMAXSIZ]; \
-      snprintf(_str, sizeof(_str), fmt, ## arg); \
-      putp(_str); \
-   } while (0)
-
-        /**  PUFF - Put for Frame (used in only 3 places)
-               . for more permanent frame-oriented 'update' output
-               . may NOT contain cursor motion terminfo escapes
-               . assumed to represent a complete screen ROW
-               . subject to optimization, thus MAY be discarded */
-#define PUFF(fmt,arg...) do { \
-      char _str[ROWMAXSIZ], *_eol; \
-      _eol = _str + snprintf(_str, sizeof(_str), fmt, ## arg); \
-      if (Batch) { \
-         while (*(--_eol) == ' '); *(++_eol) = '\0'; putp(_str); } \
-      else { \
-         char *_ptr = &Pseudo_screen[Pseudo_row * ROWMAXSIZ]; \
-         if (Pseudo_row + 1 < Screen_rows) ++Pseudo_row; \
-         if (!strcmp(_ptr, _str)) putp("\n"); \
-         else { \
-            strcpy(_ptr, _str); \
-            putp(_ptr); } } \
-   } while (0)
-
-        /* Orderly end, with any sort of message - see fmtmk */
-#define debug_END(s) { \
-           static void error_exit (const char *); \
-           fputs(Cap_clr_scr, stdout); \
-           error_exit(s); \
-        }
-
-        /* A poor man's breakpoint, if he's too lazy to learn gdb */
-#define its_YOUR_fault { *((char *)0) = '!'; }
-
-
-/*######  Display Support *Data*  ########################################*/
-
-        /* Configuration files support */
-#define SYS_RCFILESPEC  "/etc/toprc"
-#define RCF_EYECATCHER  "Config File (Linux processes with windows)\n"
-#define RCF_VERSION_ID  'f'
-
-        /* The default fields displayed and their order, if nothing is
-           specified by the loser, oops user.
-           note: any *contiguous* ascii sequence can serve as fieldscur
-                 characters as long as the initial value is coordinated
-                 with that specified for FLD_OFFSET
-           ( we're providing for up to 55 fields initially, )
-           ( with values chosen to avoid the need to escape ) */
-#define FLD_OFFSET  '%'
-   //   seq_fields  "%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ["
-#define DEF_FIELDS  "&')*+,-./012568<>?ABCFGHIJKLMNOPQRSTUVWXYZ["
-        /* Pre-configured windows/field groups */
-#define JOB_FIELDS  "()*+,-./012568>?@ABCFGHIJKLMNOPQRSTUVWXYZ["
-#define MEM_FIELDS  "&'()*+,-./0125689BFGHIJKLMNOPQRSTUVWXYZ["
-#define USR_FIELDS  ")+,-./1234568;<=>?@ABCFGHIJKLMNOPQRSTUVWXYZ["
-
-        /* The default values for the local config file */
-#define DEF_RCFILE { \
-   0, 1, DEF_DELAY, 0, { \
-   { P_CPU, DEF_WINFLGS, 0, \
-      COLOR_RED, COLOR_RED, COLOR_YELLOW, COLOR_RED, \
-      "Def", DEF_FIELDS }, \
-   { P_PID, DEF_WINFLGS, 0, \
-      COLOR_CYAN, COLOR_CYAN, COLOR_WHITE, COLOR_CYAN, \
-      "Job", JOB_FIELDS }, \
-   { P_MEM, DEF_WINFLGS, 0, \
-      COLOR_MAGENTA, COLOR_MAGENTA, COLOR_BLUE, COLOR_MAGENTA, \
-      "Mem", MEM_FIELDS }, \
-   { P_UEN, DEF_WINFLGS, 0, \
-      COLOR_YELLOW, COLOR_YELLOW, COLOR_GREEN, COLOR_YELLOW, \
-      "Usr", USR_FIELDS } \
-   } }
-
-        /* The format string used with variable width columns --
-           see 'calibrate_fields' for supporting logic. */
-#define VARCOL_fmts  "%-*.*s "
-
-        /* Summary Lines specially formatted string(s) --
-           see 'show_special' for syntax details + other cautions. */
-#define LOADAV_line  "%s -%s\n"
-#define LOADAV_line_alt  "%s~6 -%s\n"
-#define STATES_line1  "%s:~3" \
-   " %3u ~2total,~3 %3u ~2running,~3 %3u ~2sleeping,~3 %3u ~2stopped,~3 %3u ~2zombie~3\n"
-#define STATES_line2x4  "%%%s~3" \
-   " %#5.1f  ~2user,~3 %#5.1f  ~2system,~3 %#5.1f  ~2nice,~3 %#5.1f  ~2idle~3\n"
-        /* These are the STATES_line evolutions
-              lnx 2.5.x, procps-3.0.5  : IO-wait = i/o wait time
-              lnx 2.6.x, procps-3.1.12 : IO-wait now wa, hi = hard irq, si = soft irq
-              lnx 2.7.x, procps-3.2.7  : st = steal time */
-#define STATES_line2x5  "%%%s~3" \
-   " %#5.1f  ~2user,~3 %#5.1f  ~2system,~3 %#5.1f  ~2nice,~3 %#5.1f  ~2idle,~3 %#5.1f  ~2IO-wait~3\n"
-#define STATES_line2x6  "%%%s~3" \
-   " %#5.1f ~2us,~3 %#5.1f ~2sy,~3 %#5.1f ~2ni,~3 %#5.1f ~2id,~3 %#5.1f ~2wa,~3 %#5.1f ~2hi,~3 %#5.1f ~2si~3\n"
-#define STATES_line2x7  "%%%s~3" \
-   "%#5.1f ~2us,~3%#5.1f ~2sy,~3%#5.1f ~2ni,~3%#5.1f ~2id,~3%#5.1f ~2wa,~3%#5.1f ~2hi,~3%#5.1f ~2si,~3%#5.1f ~2st~3\n"
-#define MEMORY_twolines  \
-   "%s Mem: ~3 %8lu ~2total,~3 %8lu ~2used,~3 %8lu ~2free,~3 %8lu ~2buffers~3\n" \
-   "%s Swap:~3 %8lu ~2total,~3 %8lu ~2used,~3 %8lu ~2free,~3 %8lu ~2cached~3\n"
-
-        /* Keyboard Help specially formatted string(s) --
-           see 'show_special' for syntax details + other cautions. */
-#define KEYS_help \
-   "Help for Interactive Commands~2 - %s\n" \
-   "Window ~1%s~6: ~1Cumulative mode ~3%s~2.  ~1System~6: ~1Delay ~3%.1f secs~2; ~1Secure mode ~3%s~2.\n" \
-   "\n" \
-   "  Z~5,~1B~5       Global: '~1Z~2' change color mappings; '~1B~2' disable/enable bold\n" \
-   "  l,t,m     Toggle Summaries: '~1l~2' load avg; '~1t~2' task/cpu stats; '~1m~2' mem info\n" \
-   "  1,I       Toggle SMP view: '~11~2' single/separate states; '~1I~2' Irix/Solaris mode\n" \
-   "  f,F       Manage Fields: add/remove; change order; select sort field\n" \
-   "\n" \
-   "  <,>     . Move sort field: '~1<~2' next col left; '~1>~2' next col right\n" \
-   "  R,H,V   . Toggle: '~1R~2' norm/rev sort; '~1H~2' show threads; '~1V~2' forest view\n" \
-   "  c,i,S   . Toggle: '~1c~2' cmd name/line; '~1i~2' idle tasks; '~1S~2' cumulative time\n" \
-   "  x~5,~1y~5     . Toggle highlights: '~1x~2' sort field; '~1y~2' running tasks\n" \
-   "  z~5,~1b~5     . Toggle: '~1z~2' color/mono; '~1b~2' bold/reverse (only if 'x' or 'y')\n" \
-   "  u,U     . Show: '~1u~2' effective user; '~1U~2' real, saved, file or effective user\n" \
-   "  n or #  . Set maximum tasks displayed\n" \
-   "  C,...   . Toggle scroll coordinates msg for: ~1up~2,~1down~2,~1left~2,right~2,~1home~2,~1end~2\n" \
-   "\n" \
-   "%s" \
-   "  W         Write configuration file\n" \
-   "  q         Quit\n" \
-   "          ( commands shown with '.' require a ~1visible~2 task display ~1window~2 ) \n" \
-   "Press '~1h~2' or '~1?~2' for help with ~1Windows~2,\n" \
-   "any other key to continue " \
-   ""
-
-        /* This guy goes into the help text (maybe) */
-#define KEYS_help_unsecured \
-   "  k,r       Manipulate tasks: '~1k~2' kill; '~1r~2' renice\n" \
-   "  d or s    Set update interval\n" \
-   ""
-
-        /* Fields Management specially formatted string(s) --
-           see 'show_special' for syntax details + other cautions */
-#define FIELDS_heading \
-   "Fields Management~2 for window ~1%s~6, whose current sort field is ~1%s~2\n" \
-   "   Navigate with Up/Dn, Right selects for move then <Enter> or Left commits,\n" \
-   "   'd' or <Space> toggles display, 's' sets sort.  Use 'q' or <Esc> to end! " \
-   ""
-
-        /* Colors Help specially formatted string(s) --
-           see 'show_special' for syntax details + other cautions. */
-#define COLOR_help \
-   "Help for color mapping~2 - %s\n" \
-   "current window: ~1%s~6\n" \
-   "\n" \
-   "   color - 04:25:44 up 8 days, 50 min,  7 users,  load average:\n" \
-   "   Tasks:~3  64 ~2total,~3   2 ~3running,~3  62 ~2sleeping,~3   0 ~2stopped,~3\n" \
-   "   %%Cpu(s):~3  76.5 ~2user,~3  11.2 ~2system,~3   0.0 ~2nice,~3  12.3 ~2idle~3\n" \
-   "   ~1 Nasty Message! ~4  -or-  ~1Input Prompt~5\n" \
-   "   ~1  PID TTY     PR  NI %%CPU    TIME+   VIRT SWAP S COMMAND    ~6\n" \
-   "   17284 ~8pts/2  ~7  8   0  0.0   0:00.75  1380    0 S /bin/bash   ~8\n" \
-   "   ~1 8601 pts/1    7 -10  0.4   0:00.03   916    0 R color -b -z~7\n" \
-   "   11005 ~8?      ~7  9   0  0.0   0:02.50  2852 1008 S amor -sessi~8\n" \
-   "   available toggles: ~1B~2 =disable bold globally (~1%s~2),\n" \
-   "       ~1z~2 =color/mono (~1%s~2), ~1b~2 =tasks \"bold\"/reverse (~1%s~2)\n" \
-   "\n" \
-   "Select ~1target~2 as upper case letter:\n" \
-   "   S~2 = Summary Data,~1  M~2 = Messages/Prompts,\n" \
-   "   H~2 = Column Heads,~1  T~2 = Task Information\n" \
-   "Select ~1color~2 as number:\n" \
-   "   0~2 = black,~1  1~2 = red,    ~1  2~2 = green,~1  3~2 = yellow,\n" \
-   "   4~2 = blue, ~1  5~2 = magenta,~1  6~2 = cyan, ~1  7~2 = white\n" \
-   "\n" \
-   "Selected: ~1target~2 ~1 %c ~4; ~1color~2 ~1 %d ~4\n" \
-   "   press 'q' to abort changes to window '~1%s~2'\n" \
-   "   press 'a' or 'w' to commit & change another, <Enter> to commit and end " \
-   ""
-
-        /* Windows/Field Group Help specially formatted string(s) --
-           see 'show_special' for syntax details + other cautions. */
-#define WINDOWS_help \
-   "Help for Windows / Field Groups~2 - \"Current Window\" = ~1 %s ~6\n" \
-   "\n" \
-   ". Use multiple ~1windows~2, each with separate config opts (color,fields,sort,etc)\n" \
-   ". The 'current' window controls the ~1Summary Area~2 and responds to your ~1Commands~2\n" \
-   "  . that window's ~1task display~2 can be turned ~1Off~2 & ~1On~2, growing/shrinking others\n" \
-   "  . with ~1NO~2 task display, some commands will be ~1disabled~2 ('i','R','n','c', etc)\n" \
-   "    until a ~1different window~2 has been activated, making it the 'current' window\n" \
-   ". You ~1change~2 the 'current' window by: ~1 1~2) cycling forward/backward;~1 2~2) choosing\n" \
-   "  a specific field group; or~1 3~2) exiting the color mapping or fields screens\n" \
-   ". Commands ~1available anytime   -------------~2\n" \
-   "    A       . Alternate display mode toggle, show ~1Single~2 / ~1Multiple~2 windows\n" \
-   "    g       . Choose another field group and make it 'current', or change now\n" \
-   "              by selecting a number from: ~1 1~2 =%s;~1 2~2 =%s;~1 3~2 =%s; or~1 4~2 =%s\n" \
-   ". Commands ~1requiring~2 '~1A~2' mode~1  -------------~2\n" \
-   "    G       . Change the ~1Name~5 of the 'current' window/field group\n" \
-   " ~1*~4  a , w   . Cycle through all four windows:  '~1a~5' Forward; '~1w~5' Backward\n" \
-   " ~1*~4  - , _   . Show/Hide:  '~1-~5' ~1Current~2 window; '~1_~5' all ~1Visible~2/~1Invisible~2\n" \
-   "  The screen will be divided evenly between task displays.  But you can make\n" \
-   "  some ~1larger~2 or ~1smaller~2, using '~1n~2' and '~1i~2' commands.  Then later you could:\n" \
-   " ~1*~4  = , +   . Rebalance tasks:  '~1=~5' ~1Current~2 window; '~1+~5' ~1Every~2 window\n" \
-   "              (this also forces the ~1current~2 or ~1every~2 window to become visible)\n" \
-   "\n" \
-   "In '~1A~2' mode, '~1*~4' keys are your ~1essential~2 commands.  Please try the '~1a~2' and '~1w~2'\n" \
-   "commands plus the 'g' sub-commands NOW.  Press <Enter> to make 'Current' " \
-   ""
-
-
-/*######  For Piece of mind  #############################################*/
-
-        /* just sanity check(s)... */
-#if defined(ATEOJ_RPTHSH) && defined(OFF_HST_HASH)
-# error 'ATEOJ_RPTHSH' conflicts with 'OFF_HST_HASH'
-#endif
-#if (LRGBUFSIZ < SCREENMAX)
-# error 'LRGBUFSIZ' must NOT be less than 'SCREENMAX'
-#endif
-
-
-/*######  Some Prototypes (ha!)  #########################################*/
-
-   /* These 'prototypes' are here solely for documentation purposes */
-/*------  Sort callbacks  ------------------------------------------------*/
-/*        for each possible field, in the form of:                        */
-/*atic int           sort_P_XXX (const proc_t **P, const proc_t **Q);     */
-/*------  Tiny useful routine(s)  ----------------------------------------*/
-//atic const char   *fmtmk (const char *fmts, ...);
-//atic inline char  *scat (char *dst, const char *src);
-//atic char         *strim (char *str);
-//atic const char   *tg2 (int x, int y);
-/*------  Exit/Interrput routines  ---------------------------------------*/
-//atic void          bye_bye (const char *str);
-//atic void          error_exit (const char *str);
-//atic void          pause_pgm (void);
-//atic void          sig_abexit (int sig);
-//atic void          sig_endpgm (int dont_care_sig);
-//atic void          sig_paused (int dont_care_sig);
-//atic void          sig_resize (int dont_care_sig);
-/*------  Misc Color/Display support  ------------------------------------*/
-//atic void          capsmk (WIN_t *q);
-//atic void          msg_save (const char *fmts, ...);
-//atic void          show_msg (const char *str);
-//atic int           show_pmt (const char *str);
-//atic inline void   show_scroll (void);
-//atic void          show_special (int interact, const char *glob);
-/*------  Low Level Memory/Keyboard support  -----------------------------*/
-//atic void         *alloc_c (size_t num);
-//atic void         *alloc_r (void *ptr, size_t num);
-//atic int           chin (int ech, char *buf, unsigned cnt);
-//atic int           keyin (int init);
-//atic char         *linein (const char *prompt);
-/*------  Small Utility routines  ----------------------------------------*/
-//atic float         get_float (const char *prompt);
-//atic int           get_int (const char *prompt);
-//atic const char   *scale_num (unsigned long num, const int width, const int type);
-//atic const char   *scale_tics (TIC_t tics, const int width);
-//atic const char   *user_certify (WIN_t *q, const char *str, char typ);
-//atic inline int    user_matched (WIN_t *q, const proc_t *p);
-/*------  Fields Management support  -------------------------------------*/
-/*atic FLD_t         Fieldstab[] = { ... }                                */
-//atic void          adj_geometry (void);
-//atic void          calibrate_fields (void);
-//atic void          display_fields (int focus, int extend);
-//atic void          fields_utility (void);
-//atic void          zap_fieldstab (void);
-/*------  Library Interface  ---------------------------------------------*/
-//atic CPU_t        *cpus_refresh (CPU_t *cpus);
-#ifdef OFF_HST_HASH
-//atic inline HST_t *hstbsrch (HST_t *hst, int max, int pid);
-#else
-//atic inline HST_t *hstget (int pid);
-//atic inline void   hstput (unsigned idx);
-#endif
-//atic void          prochlp (proc_t *p);
-//atic void          procs_refresh (void);
-//atic void          sysinfo_refresh (int forced);
-/*------  Startup routines  ----------------------------------------------*/
-//atic void          before (char *me);
-//atic void          configs_read (void);
-//atic void          parse_args (char **args);
-//atic void          whack_terminal (void);
-/*------  Windows/Field Groups support  ----------------------------------*/
-//atic void          win_names (WIN_t *q, const char *name);
-//atic WIN_t        *win_select (char ch);
-//atic int           win_warn (int what);
-//atic void          winsclrhlp (WIN_t *q, int save);
-//atic void          wins_colors (void);
-//atic void          wins_reflag (int what, int flg);
-//atic void          wins_stage_1 (void);
-//atic void          wins_stage_2 (void);
-/*------  Interactive Input support (do_key helpers)  --------------------*/
-//atic void          file_writerc (void);
-//atic void          help_view (void);
-//atic void          keys_global (int ch);
-//atic void          keys_summary (int ch);
-//atic void          keys_task (int ch);
-//atic void          keys_window (int ch);
-//atic void          keys_xtra (int ch);
-/*------  Forest View support  -------------------------------------------*/
-//atic void          forest_add (const int self, const int level);
-//atic void          forest_create (WIN_t *q);
-//atic inline const char *forest_display (const WIN_t *q, const proc_t *p);
-/*------  Main Screen routines  ------------------------------------------*/
-//atic void          do_key (int ch);
-//atic void          summaryhlp (CPU_t *cpu, const char *pfx);
-//atic void          summary_show (void);
-//atic void          task_show (const WIN_t *q, const proc_t *p);
-//atic int           window_show (WIN_t *q, int wmax);
-/*------  Entry point plus two  ------------------------------------------*/
-//atic void          framehlp (int wix, int max);
-//atic void          frame_make (void);
-//     int           main (int dont_care_argc, char **argv);
-
-#endif /* _Itop */
-
diff --git a/uptime.1 b/uptime.1
deleted file mode 100644
index c635f950..00000000
--- a/uptime.1
+++ /dev/null
@@ -1,47 +0,0 @@
-.\"             -*-Nroff-*-
-.\"
-.TH UPTIME 1 "26 Jan 1993" "Cohesive Systems" "Linux User's Manual"
-.SH NAME
-uptime \- Tell how long the system has been running.
-.SH SYNOPSIS
-.B uptime
-.br
-.B uptime
-.RB [ \-V ]
-.SH DESCRIPTION
-.B uptime
-gives a one line display of the following information.
-The current time,
-how long the system has been running,
-how many users are currently logged on,
-and the system load averages for the past 1, 5, and 15 minutes.
-
-This is the same information contained in the header line displayed by 
-.BR w (1).
-.sp
-System load averages is the average number of processes that are either
-in a runnable or uninterruptable state.  A process in a runnable state is
-either using the CPU or waiting to use the CPU. A process in
-uninterruptable state is waiting for some I/O access, eg waiting for
-disk.  The averages are taken over the three time intervals.
-Load averages are not normalized for the number of CPUs in a system, so
-a load average of 1 means a single CPU system is loaded all the time
-while on a 4 CPU system it means it was idle 75% of the time.
-.SH FILES
-.TP
-.I /var/run/utmp
-information about who is currently logged on
-.TP
-.I /proc
-process information
-.SH AUTHORS
-.B uptime
-was written by Larry Greenfield <greenfie@gauss.rutgers.edu> and
-Michael K. Johnson <johnsonm@sunsite.unc.edu>.
-
-Please send bug reports to <procps@freelists.org>
-.SH "SEE ALSO"
-.BR ps (1),
-.BR top (1),
-.BR utmp (5),
-.BR w (1)
diff --git a/uptime.c b/uptime.c
deleted file mode 100644
index 6a4d8bd8..00000000
--- a/uptime.c
+++ /dev/null
@@ -1,17 +0,0 @@
-#include <stdio.h>
-#include <string.h>
-#include "proc/whattime.h"
-#include "proc/version.h"
-
-int main(int argc, char *argv[]) {
-    if(argc == 1) {
-        print_uptime();
-        return 0;
-    }
-    if((argc == 2) && (!strcmp(argv[1], "-V"))) {
-        display_version();
-        return 0;
-    }
-    fprintf(stderr, "usage: uptime [-V]\n    -V    display version\n");
-    return 1;
-}
diff --git a/proc/version.c b/version.c
similarity index 66%
rename from proc/version.c
rename to version.c
index e7139cc4..d0eb0712 100644
--- a/proc/version.c
+++ b/version.c
@@ -1,4 +1,4 @@
-/* Suite version information for procps-ng utilities
+/* Suite version information for procps utilities
  * Copyright (c) 1995 Martin Schulze <joey@infodrom.north.de>
  * Ammended by cblake to only export the function symbol.
  *
@@ -7,18 +7,21 @@
  * Redistributable under the terms of the
  * GNU Library General Public License; see COPYING
  */
-
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
 #include <stdio.h>
 #include <stdlib.h>
 #include "version.h"
 
-const char procps_version[] = PACKAGE_NAME " version " PACKAGE_VERSION;
+
+const char procps_version[] = "procps version 2.8.3";
 
 void display_version(void) {
     fprintf(stdout, "%s\n", procps_version);
 }
 
-/* Linux kernel version information for procps-ng utilities
+/* Linux kernel version information for procps utilities
  * Copyright (c) 1996 Charles Blake <cblake@bbn.com>
  */
 #include <sys/utsname.h>
@@ -27,18 +30,14 @@ void display_version(void) {
 
 int linux_version_code;
 
-void init_Linux_version(void) {
+static void init_Linux_version(void) __attribute__((constructor(102)));
+static void init_Linux_version(void) {
     static struct utsname uts;
     int x = 0, y = 0, z = 0;	/* cleared in case sscanf() < 3 */
-    int version_string_depth;
-    
+
     if (uname(&uts) == -1)	/* failure implies impending death */
 	exit(1);
-
-    version_string_depth = sscanf(uts.release, "%d.%d.%d", &x, &y, &z);
-	
-    if ((version_string_depth < 2) ||		 /* Non-standard for all known kernels */
-       ((version_string_depth < 3) && (x < 3))) /* Non-standard for 2.x.x kernels */
+    if (sscanf(uts.release, "%d.%d.%d", &x, &y, &z) < 3)
 	fprintf(stderr,		/* *very* unlikely to happen by accident */
 		"Non-standard uts for running kernel:\n"
 		"release %s=%d.%d.%d gives version code %d\n",
diff --git a/proc/version.h b/version.h
similarity index 83%
rename from proc/version.h
rename to version.h
index e7baa971..3769b847 100644
--- a/proc/version.h
+++ b/version.h
@@ -3,9 +3,9 @@
 
 #include "procps.h"
 
-/* Suite version information for procps-ng utilities
+/* Suite version information for procps utilities
  * Copyright (c) 1995 Martin Schulze <joey@infodrom.north.de>
- * Linux kernel version information for procps-ng utilities
+ * Linux kernel version information for procps utilities
  * Copyright (c) 1996 Charles Blake <cblake@bbn.com>
  * Distributable under the terms of the GNU Library General Public License
  *
@@ -14,7 +14,6 @@
 
 EXTERN_C_BEGIN
 
-void init_Linux_version(void);    /* Get Linux version */
 extern void display_version(void);	/* display suite version */
 extern const char procps_version[];		/* global buf for suite version */
 
diff --git a/vmstat.8 b/vmstat.8
deleted file mode 100644
index 127704da..00000000
--- a/vmstat.8
+++ /dev/null
@@ -1,206 +0,0 @@
-.\"  This page Copyright (C) 1994 Henry Ware <al172@yfn.ysu.edu>
-.\"  Distributed under the GPL, Copyleft 1994.
-.TH VMSTAT 8 "2009 Jan 9" "Throatwobbler Ginkgo Labs" "Linux Administrator's Manual"
-.SH NAME
-vmstat \- Report virtual memory statistics
-.SH SYNOPSIS
-.ft B
-.B vmstat
-.RB [ "\-a" ]
-.RB [ "\-n" ]
-.RI [ delay " [ " count ]]
-.br
-.B vmstat
-.RB [ "\-f" ]
-.RB [ "\-s" ]
-.RB [ "\-m" ]
-.br
-.B vmstat
-.RB [ "\-S unit"]
-.br
-.B vmstat
-.RB [ "\-d"]
-.br
-.B vmstat
-.RB [ "\-D"]
-.br
-.B vmstat
-.RB [ "\-p disk partition"]
-.br
-.B vmstat
-.RB [ "\-V" ]
-.SH DESCRIPTION
-\fBvmstat\fP reports information about processes, memory, paging,
-block IO, traps, disks and cpu activity.
-
-The first report produced gives averages since the last reboot.  Additional
-reports give information on a sampling period of length \fIdelay\fP.
-The process and memory reports are instantaneous in either case.
-
-.SS Options
-The \fB\-a\fP switch displays active/inactive memory, given a 2.5.41 kernel or better.
-.PP
-The \fB\-f\fP switch displays the number of forks since boot.
-This includes the fork, vfork, and clone system calls, and is
-equivalent to the total number of tasks created. Each process
-is represented by one or more tasks, depending on thread usage.
-This display does not repeat.
-.PP
-The \fB\-m\fP displays slabinfo.
-.PP
-The \fB\-n\fP switch causes the header to be displayed only once rather than periodically.
-.PP
-The \fB\-s\fP switch displays a table of various event counters
-and memory statistics. This display does not repeat.
-.PP
-.I delay
-is the delay between updates in seconds.  If no delay is specified,
-only one report is printed with the average values since boot.
-.PP
-.I count
-is the number of updates.  If no count is specified and delay is
-defined, \fIcount\fP defaults to infinity.
-.PP
-The \fB\-d\fP reports disk statistics (2.5.70 or above required)
-.PP
-The \fB-D\fP reports some summary statistics about disk activity.
-.PP
-The \fB\-p\fP followed by some partition name for detailed statistics (2.5.70 or above required)
-.PP
-The \fB\-S\fP followed by k or K or m or M switches outputs between 1000, 1024, 1000000, or 1048576 bytes
-.PP
-The \fB\-V\fP switch results in displaying version information.
-.PP
-.SH FIELD DESCRIPTION FOR VM MODE
-.SS
-.B "Procs"
-.nf
-r: The number of processes waiting for run time.  
-b: The number of processes in uninterruptible sleep.
-.fi
-.PP
-.SS
-.B "Memory"
-.nf
-swpd: the amount of virtual memory used.
-free: the amount of idle memory.
-buff: the amount of memory used as buffers.
-cache: the amount of memory used as cache.
-inact: the amount of inactive memory. (\-a option)
-active: the amount of active memory. (\-a option)
-.fi
-.PP
-.SS
-.B "Swap"
-.nf
-si: Amount of memory swapped in from disk (/s).
-so: Amount of memory swapped to disk (/s).
-.fi
-.PP
-.SS
-.B "IO"
-.nf
-bi: Blocks received from a block device (blocks/s).
-bo: Blocks sent to a block device (blocks/s).
-.fi
-.PP
-.SS
-.B "System"
-.nf
-in: The number of interrupts per second, including the clock.
-cs: The number of context switches per second.
-.fi
-.PP
-.SS
-.B "CPU "
-These are percentages of total CPU time.
-.nf
-us: Time spent running non\-kernel code. (user time, including nice time)
-sy: Time spent running kernel code. (system time)
-id: Time spent idle. Prior to Linux 2.5.41, this includes IO\-wait time.
-wa: Time spent waiting for IO. Prior to Linux 2.5.41, included in idle.
-st: Time stolen from a virtual machine. Prior to Linux 2.6.11, unknown.
-.fi
-.PP
-.SH FIELD DESCRIPTION FOR DISK MODE 
-.SS
-.B "Reads"
-.nf
-total: Total reads completed successfully 
-merged: grouped reads (resulting in one I/O)
-sectors: Sectors read successfully
-ms: milliseconds spent reading
-.fi
-.PP
-.SS
-.B "Writes"
-.nf
-total: Total writes completed successfully
-merged: grouped writes (resulting in one I/O)
-sectors: Sectors written successfully
-ms: milliseconds spent writing
-.fi
-.PP
-.SS
-.B "IO"
-.nf
-cur: I/O in progress
-s: seconds spent for I/O
-.fi
-
-.PP
-.SH FIELD DESCRIPTION FOR DISK PARTITION MODE
-.nf
-reads: Total number of reads issued to this partition
-read sectors: Total read sectors for partition
-writes : Total number of writes issued to this partition
-requested writes: Total number of write requests made for partition
-
-.fi
-
-.PP
-.SH FIELD DESCRIPTION FOR SLAB MODE 
-.nf
-cache: Cache name
-num: Number of currently active objects
-total: Total number of available objects
-size: Size of each object
-pages: Number of pages with at least one active object
-.fi
-
-.SH NOTES
-.B "vmstat "
-does not require special permissions.
-.PP
-These reports are intended to help identify system bottlenecks.  Linux
-.B "vmstat "
-does not count itself as a running process.
-.PP
-All linux blocks are currently 1024 bytes. Old kernels may report
-blocks as 512 bytes, 2048 bytes, or 4096 bytes.
-.PP
-Since procps 3.1.9, vmstat lets you choose units (k, K, m, M) default is K (1024 bytes) in the default mode
-.PP
-vmstat uses slabinfo 1.1    FIXME
-.SH FILES
-.ta
-.nf
-/proc/meminfo
-/proc/stat
-/proc/*/stat
-.fi
-
-.SH "SEE ALSO"
-.BR iostat (1),
-.BR sar (1),
-.BR mpstat (1),
-.BR ps (1),
-.BR top (1),
-.BR free (1)
-.PP
-.SH BUGS
-Does not tabulate the block io per device or count the number of system calls.
-.SH AUTHORS
-.nf
-Written by Henry Ware <al172@yfn.ysu.edu>. 
-Fabian Fr\('ed\('erick <ffrederick@users.sourceforge.net> (diskstat, slab, partitions...)
diff --git a/vmstat.c b/vmstat.c
deleted file mode 100644
index 756ec4f9..00000000
--- a/vmstat.c
+++ /dev/null
@@ -1,682 +0,0 @@
-// old: "Copyright 1994 by Henry Ware <al172@yfn.ysu.edu>. Copyleft same year."
-// most code copyright 2002 Albert Cahalan
-// 
-// 27/05/2003 (Fabian Frederick) : Add unit conversion + interface
-//               	 Export proc/stat access to libproc
-//			 Adapt vmstat helpfile
-// 31/05/2003 (Fabian) : Add diskstat support (/libproc)
-// June 2003 (Fabian) : -S <x> -s & -s -S <x> patch
-// June 2003 (Fabian) : -Adding diskstat against 3.1.9, slabinfo
-//			 -patching 'header' in disk & slab
-// July 2003 (Fabian) : -Adding disk partition output
-//			-Adding disk table
-//			-Syncing help / usage
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <ctype.h>
-#include <string.h>
-#include <assert.h>
-#include <fcntl.h>
-#include <limits.h>
-#include <termios.h>
-#include <unistd.h>
-#include <sys/types.h>
-#include <sys/ioctl.h>
-#include <sys/dir.h>
-#include <dirent.h>
-
-#include "proc/sysinfo.h"
-#include "proc/version.h"
-
-#define UNIT_B        1
-#define UNIT_k        1000
-#define UNIT_K        1024
-#define UNIT_m        1000000
-#define UNIT_M        1048576
-
-static unsigned long dataUnit=UNIT_K;
-static char szDataUnit[3] = "K";
-
-#define VMSTAT        0
-#define DISKSTAT      0x00000001
-#define VMSUMSTAT     0x00000002
-#define SLABSTAT      0x00000004
-#define PARTITIONSTAT 0x00000008
-#define DISKSUMSTAT   0x00000010
-
-static int statMode=VMSTAT;
-
-#define FALSE 0
-#define TRUE 1
-
-static int a_option; /* "-a" means "show active/inactive" */
-
-static unsigned sleep_time = 1;
-static unsigned long num_updates;
-
-static unsigned int height;   // window height
-static unsigned int moreheaders=TRUE;
-
-
-/////////////////////////////////////////////////////////////////////////
-
-static void usage(void) NORETURN;
-static void usage(void) {
-  fprintf(stderr,"usage: vmstat [-V] [-n] [delay [count]]\n");
-  fprintf(stderr,"              -V prints version.\n");
-  fprintf(stderr,"              -n causes the headers not to be reprinted regularly.\n");
-  fprintf(stderr,"              -a print inactive/active page stats.\n");
-  fprintf(stderr,"              -d prints disk statistics\n");
-  fprintf(stderr,"              -D prints disk table\n");
-  fprintf(stderr,"              -p prints disk partition statistics\n");
-  fprintf(stderr,"              -s prints vm table\n");
-  fprintf(stderr,"              -m prints slabinfo\n");
-  fprintf(stderr,"              -S unit size\n");
-  fprintf(stderr,"              delay is the delay between updates in seconds. \n");
-  fprintf(stderr,"              unit size k:1000 K:1024 m:1000000 M:1048576 (default is K)\n");
-  fprintf(stderr,"              count is the number of updates.\n");
-  exit(EXIT_FAILURE);
-}
-
-/////////////////////////////////////////////////////////////////////////////
-
-#if 0
-// produce:  "  6  ", "123  ", "123k ", etc.
-static int format_1024(unsigned long long val64, char *restrict dst){
-  unsigned oldval;
-  const char suffix[] = " kmgtpe";
-  unsigned level = 0;
-  unsigned val32;
-
-  if(val64 < 1000){   // special case to avoid "6.0  " when plain "  6  " would do
-    val32 = val64;
-    return sprintf(dst,"%3u  ",val32);
-  }
-
-  while(val64 > 0xffffffffull){
-    level++;
-    val64 /= 1024;
-  }
-
-  val32 = val64;
-
-  while(val32 > 999){
-    level++;
-    oldval = val32;
-    val32 /= 1024;
-  }
-
-  if(val32 < 10){
-    unsigned fract = (oldval % 1024) * 10 / 1024;
-    return sprintf(dst, "%u.%u%c ", val32, fract, suffix[level]);
-  }
-  return sprintf(dst, "%3u%c ", val32, suffix[level]);
-}
-
-
-// produce:  "  6  ", "123  ", "123k ", etc.
-static int format_1000(unsigned long long val64, char *restrict dst){
-  unsigned oldval;
-  const char suffix[] = " kmgtpe";
-  unsigned level = 0;
-  unsigned val32;
-
-  if(val64 < 1000){   // special case to avoid "6.0  " when plain "  6  " would do
-    val32 = val64;
-    return sprintf(dst,"%3u  ",val32);
-  }
-
-  while(val64 > 0xffffffffull){
-    level++;
-    val64 /= 1000;
-  }
-
-  val32 = val64;
-
-  while(val32 > 999){
-    level++;
-    oldval = val32;
-    val32 /= 1000;
-  }
-
-  if(val32 < 10){
-    unsigned fract = (oldval % 1000) / 100;
-    return sprintf(dst, "%u.%u%c ", val32, fract, suffix[level]);
-  }
-  return sprintf(dst, "%3u%c ", val32, suffix[level]);
-}
-#endif
-
-////////////////////////////////////////////////////////////////////////////
-
-static void new_header(void){
-  printf("procs -----------memory---------- ---swap-- -----io---- -system-- ----cpu----\n");
-  printf(
-    "%2s %2s %6s %6s %6s %6s %4s %4s %5s %5s %4s %4s %2s %2s %2s %2s\n",
-    "r","b",
-    "swpd", "free", a_option?"inact":"buff", a_option?"active":"cache",
-    "si","so",
-    "bi","bo",
-    "in","cs",
-    "us","sy","id","wa"
-  );
-}
-
-////////////////////////////////////////////////////////////////////////////
-
-static unsigned long unitConvert(unsigned int size){
- float cvSize;
- cvSize=(float)size/dataUnit*((statMode==SLABSTAT)?1:1024);
- return ((unsigned long) cvSize);
-}
-
-////////////////////////////////////////////////////////////////////////////
-
-static void new_format(void) {
-  const char format[]="%2u %2u %6lu %6lu %6lu %6lu %4u %4u %5u %5u %4u %4u %2u %2u %2u %2u\n";
-  unsigned int tog=0; /* toggle switch for cleaner code */
-  unsigned int i;
-  unsigned int hz = Hertz;
-  unsigned int running,blocked,dummy_1,dummy_2;
-  jiff cpu_use[2], cpu_nic[2], cpu_sys[2], cpu_idl[2], cpu_iow[2], cpu_xxx[2], cpu_yyy[2], cpu_zzz[2];
-  jiff duse, dsys, didl, diow, dstl, Div, divo2;
-  unsigned long pgpgin[2], pgpgout[2], pswpin[2], pswpout[2];
-  unsigned int intr[2], ctxt[2];
-  unsigned int sleep_half; 
-  unsigned long kb_per_page = sysconf(_SC_PAGESIZE) / 1024ul;
-  int debt = 0;  // handle idle ticks running backwards
-
-  sleep_half=(sleep_time/2);
-  new_header();
-  meminfo();
-
-  getstat(cpu_use,cpu_nic,cpu_sys,cpu_idl,cpu_iow,cpu_xxx,cpu_yyy,cpu_zzz,
-	  pgpgin,pgpgout,pswpin,pswpout,
-	  intr,ctxt,
-	  &running,&blocked,
-	  &dummy_1, &dummy_2);
-
-  duse= *cpu_use + *cpu_nic; 
-  dsys= *cpu_sys + *cpu_xxx + *cpu_yyy;
-  didl= *cpu_idl;
-  diow= *cpu_iow;
-  dstl= *cpu_zzz;
-  Div= duse+dsys+didl+diow+dstl;
-  divo2= Div/2UL;
-  printf(format,
-	 running, blocked,
-	 unitConvert(kb_swap_used), unitConvert(kb_main_free),
-	 unitConvert(a_option?kb_inactive:kb_main_buffers),
-	 unitConvert(a_option?kb_active:kb_main_cached),
-	 (unsigned)( (*pswpin  * unitConvert(kb_per_page) * hz + divo2) / Div ),
-	 (unsigned)( (*pswpout * unitConvert(kb_per_page) * hz + divo2) / Div ),
-	 (unsigned)( (*pgpgin                * hz + divo2) / Div ),
-	 (unsigned)( (*pgpgout               * hz + divo2) / Div ),
-	 (unsigned)( (*intr                  * hz + divo2) / Div ),
-	 (unsigned)( (*ctxt                  * hz + divo2) / Div ),
-	 (unsigned)( (100*duse                    + divo2) / Div ),
-	 (unsigned)( (100*dsys                    + divo2) / Div ),
-	 (unsigned)( (100*didl                    + divo2) / Div ),
-	 (unsigned)( (100*diow                    + divo2) / Div ) /* ,
-	 (unsigned)( (100*dstl                    + divo2) / Div ) */
-  );
-
-  for(i=1;i<num_updates;i++) { /* \\\\\\\\\\\\\\\\\\\\ main loop ////////////////// */
-    sleep(sleep_time);
-    if (moreheaders && ((i%height)==0)) new_header();
-    tog= !tog;
-
-    meminfo();
-
-    getstat(cpu_use+tog,cpu_nic+tog,cpu_sys+tog,cpu_idl+tog,cpu_iow+tog,cpu_xxx+tog,cpu_yyy+tog,cpu_zzz+tog,
-	  pgpgin+tog,pgpgout+tog,pswpin+tog,pswpout+tog,
-	  intr+tog,ctxt+tog,
-	  &running,&blocked,
-	  &dummy_1,&dummy_2);
-
-    duse= cpu_use[tog]-cpu_use[!tog] + cpu_nic[tog]-cpu_nic[!tog];
-    dsys= cpu_sys[tog]-cpu_sys[!tog] + cpu_xxx[tog]-cpu_xxx[!tog] + cpu_yyy[tog]-cpu_yyy[!tog];
-    didl= cpu_idl[tog]-cpu_idl[!tog];
-    diow= cpu_iow[tog]-cpu_iow[!tog];
-    dstl= cpu_zzz[tog]-cpu_zzz[!tog];
-
-    /* idle can run backwards for a moment -- kernel "feature" */
-    if(debt){
-      didl = (int)didl + debt;
-      debt = 0;
-    }
-    if( (int)didl < 0 ){
-      debt = (int)didl;
-      didl = 0;
-    }
-
-    Div= duse+dsys+didl+diow+dstl;
-    divo2= Div/2UL;
-    printf(format,
-           running, blocked,
-	   unitConvert(kb_swap_used),unitConvert(kb_main_free),
-	   unitConvert(a_option?kb_inactive:kb_main_buffers),
-	   unitConvert(a_option?kb_active:kb_main_cached),
-	   (unsigned)( ( (pswpin [tog] - pswpin [!tog])*unitConvert(kb_per_page)+sleep_half )/sleep_time ), /*si*/
-	   (unsigned)( ( (pswpout[tog] - pswpout[!tog])*unitConvert(kb_per_page)+sleep_half )/sleep_time ), /*so*/
-	   (unsigned)( (  pgpgin [tog] - pgpgin [!tog]             +sleep_half )/sleep_time ), /*bi*/
-	   (unsigned)( (  pgpgout[tog] - pgpgout[!tog]             +sleep_half )/sleep_time ), /*bo*/
-	   (unsigned)( (  intr   [tog] - intr   [!tog]             +sleep_half )/sleep_time ), /*in*/
-	   (unsigned)( (  ctxt   [tog] - ctxt   [!tog]             +sleep_half )/sleep_time ), /*cs*/
-	   (unsigned)( (100*duse+divo2)/Div ), /*us*/
-	   (unsigned)( (100*dsys+divo2)/Div ), /*sy*/
-	   (unsigned)( (100*didl+divo2)/Div ), /*id*/
-	   (unsigned)( (100*diow+divo2)/Div )/*, //wa
-	   (unsigned)( (100*dstl+divo2)/Div )  //st  */
-    );
-  }
-}
-
-////////////////////////////////////////////////////////////////////////////
-
-static void diskpartition_header(const char *partition_name){
-  printf("%-10s %10s %10s %10s %10s\n",partition_name, "reads  ", "read sectors", "writes   ", "requested writes");
-}
-
-////////////////////////////////////////////////////////////////////////////
-
-static int diskpartition_format(const char* partition_name){
-    FILE *fDiskstat;
-    struct disk_stat *disks;
-    struct partition_stat *partitions, *current_partition=NULL;
-    unsigned long ndisks, j, k, npartitions;
-    const char format[] = "%20u %10llu %10u %10u\n";
-
-    fDiskstat=fopen("/proc/diskstats","rb");
-    if(!fDiskstat){
-        fprintf(stderr, "Your kernel doesn't support diskstat. (2.5.70 or above required)\n"); 
-        exit(EXIT_FAILURE);
-    }
-
-    fclose(fDiskstat);
-    ndisks=getdiskstat(&disks,&partitions);
-    npartitions=getpartitions_num(disks, ndisks);
-    for(k=0; k<npartitions; k++){
-       if(!strcmp(partition_name, partitions[k].partition_name)){
-                current_partition=&(partitions[k]); 
-       }	
-    }
-    if(!current_partition){
-         free(disks);
-         free(partitions);
-         return -1;
-    }
-    diskpartition_header(partition_name);
-    printf (format,
-       current_partition->reads,current_partition->reads_sectors,current_partition->writes,current_partition->requested_writes);
-    fflush(stdout);
-    free(disks);
-    free(partitions);
-    for(j=1; j<num_updates; j++){ 
-        if (moreheaders && ((j%height)==0)) diskpartition_header(partition_name);
-        sleep(sleep_time);
-        ndisks=getdiskstat(&disks,&partitions);
-        npartitions=getpartitions_num(disks, ndisks);
-	current_partition=NULL;
-        for(k=0; k<npartitions; k++){
-          if(!strcmp(partition_name, partitions[k].partition_name)){
-                  current_partition=&(partitions[k]); 
-          }	
-        }
-        if(!current_partition){
-           free(disks);
-           free(partitions);
-           return -1;
-        }
-        printf (format,
-        current_partition->reads,current_partition->reads_sectors,current_partition->writes,current_partition->requested_writes);
-        fflush(stdout);
-        free(disks);
-        free(partitions);
-    }
-    return 0;
-}
-
-////////////////////////////////////////////////////////////////////////////
-
-static void diskheader(void){
-  printf("disk- ------------reads------------ ------------writes----------- -----IO------\n");
-
-  printf("%5s %6s %6s %7s %7s %6s %6s %7s %7s %6s %6s\n",
-         " ", "total", "merged","sectors","ms","total","merged","sectors","ms","cur","sec");
-
-}
-
-////////////////////////////////////////////////////////////////////////////
-
-static void diskformat(void){
-  FILE *fDiskstat;
-  struct disk_stat *disks;
-  struct partition_stat *partitions;
-  unsigned long ndisks,i,j,k;
-  const char format[]="%-5s %6u %6u %7llu %7u %6u %6u %7llu %7u %6u %6u\n";
-  if ((fDiskstat=fopen("/proc/diskstats", "rb"))){
-    fclose(fDiskstat);
-    ndisks=getdiskstat(&disks,&partitions);
-    if (!moreheaders) diskheader();
-    for(k=0; k<ndisks; k++){
-      if (moreheaders && ((k%height)==0)) diskheader();
-      printf(format,
-        disks[k].disk_name,
-        disks[k].reads,
-        disks[k].merged_reads,
-        disks[k].reads_sectors,
-        disks[k].milli_reading,
-        disks[k].writes,
-        disks[k].merged_writes,
-        disks[k].written_sectors,
-        disks[k].milli_writing,
-        disks[k].inprogress_IO?disks[k].inprogress_IO/1000:0,
-        disks[k].milli_spent_IO?disks[k].milli_spent_IO/1000:0/*,
-        disks[i].weighted_milli_spent_IO/1000*/
-      );
-      fflush(stdout);
-    }
-    free(disks);
-    free(partitions);
-    for(j=1; j<num_updates; j++){ 
-      sleep(sleep_time);
-      ndisks=getdiskstat(&disks,&partitions);
-      for(i=0; i<ndisks; i++,k++){
-        if (moreheaders && ((k%height)==0)) diskheader();
-        printf(format,
-          disks[i].disk_name,
-          disks[i].reads,
-          disks[i].merged_reads,
-          disks[i].reads_sectors,
-          disks[i].milli_reading,
-          disks[i].writes,
-          disks[i].merged_writes,
-          disks[i].written_sectors,
-          disks[i].milli_writing,
-          disks[i].inprogress_IO?disks[i].inprogress_IO/1000:0,
-          disks[i].milli_spent_IO?disks[i].milli_spent_IO/1000:0/*,
-          disks[i].weighted_milli_spent_IO/1000*/
-        );
-        fflush(stdout);
-      }
-      free(disks);
-      free(partitions);
-    }
-  }else{
-    fprintf(stderr, "Your kernel doesn't support diskstat (2.5.70 or above required)\n"); 
-    exit(EXIT_FAILURE);
-  } 
-}
-
-////////////////////////////////////////////////////////////////////////////
-
-static void slabheader(void){
-  printf("%-24s %6s %6s %6s %6s\n","Cache","Num", "Total", "Size", "Pages");
-}
-
-////////////////////////////////////////////////////////////////////////////
-
-static void slabformat (void){
-  FILE *fSlab;
-  struct slab_cache *slabs;
-  unsigned long nSlab,i,j,k;
-  const char format[]="%-24s %6u %6u %6u %6u\n";
-
-  fSlab=fopen("/proc/slabinfo", "rb");
-  if(!fSlab){
-    fprintf(stderr, "Your kernel doesn't support slabinfo or your permissions are insufficient.\n");
-    return;
-  }
-
-  if (!moreheaders) slabheader();
-  nSlab = getslabinfo(&slabs);
-  for(k=0; k<nSlab; k++){
-    if (moreheaders && ((k%height)==0)) slabheader();
-    printf(format,
-      slabs[k].name,
-      slabs[k].active_objs,
-      slabs[k].num_objs,
-      slabs[k].objsize,
-      slabs[k].objperslab
-    );
-  }
-  free(slabs);
-  for(j=1,k=1; j<num_updates; j++) { 
-    sleep(sleep_time);
-    nSlab = getslabinfo(&slabs);
-    for(i=0; i<nSlab; i++,k++){
-      if (moreheaders && ((k%height)==0)) slabheader();
-      printf(format,
-        slabs[i].name,
-        slabs[i].active_objs,
-        slabs[i].num_objs,
-        slabs[i].objsize,
-        slabs[i].objperslab
-      );
-    }
-    free(slabs);
-  }
-  free(fSlab);
-}
-
-////////////////////////////////////////////////////////////////////////////
-
-static void disksum_format(void) {
-
-  FILE *fDiskstat;
-  struct disk_stat *disks;
-  struct partition_stat *partitions;
-  int ndisks, i;
-  unsigned long reads, merged_reads, read_sectors, milli_reading, writes,
-                merged_writes, written_sectors, milli_writing, inprogress_IO,
-                milli_spent_IO, weighted_milli_spent_IO;
-
-  reads=merged_reads=read_sectors=milli_reading=writes=merged_writes= \
-  written_sectors=milli_writing=inprogress_IO=milli_spent_IO= \
-  weighted_milli_spent_IO=0;
-
-  if ((fDiskstat=fopen("/proc/diskstats", "rb"))){
-    fclose(fDiskstat);
-    ndisks=getdiskstat(&disks, &partitions);
-    printf("%13d disks \n", ndisks);
-    printf("%13d partitions \n", getpartitions_num(disks, ndisks));
-
-    for(i=0; i<ndisks; i++){
-         reads+=disks[i].reads;
-         merged_reads+=disks[i].merged_reads;
-         read_sectors+=disks[i].reads_sectors;
-         milli_reading+=disks[i].milli_reading;
-         writes+=disks[i].writes;
-         merged_writes+=disks[i].merged_writes;
-         written_sectors+=disks[i].written_sectors;
-         milli_writing+=disks[i].milli_writing;
-         inprogress_IO+=disks[i].inprogress_IO?disks[i].inprogress_IO/1000:0;
-         milli_spent_IO+=disks[i].milli_spent_IO?disks[i].milli_spent_IO/1000:0;
-      }
-
-    printf("%13lu total reads\n",reads);
-    printf("%13lu merged reads\n",merged_reads);
-    printf("%13lu read sectors\n",read_sectors);
-    printf("%13lu milli reading\n",milli_reading);
-    printf("%13lu writes\n",writes);
-    printf("%13lu merged writes\n",merged_writes);
-    printf("%13lu written sectors\n",written_sectors);
-    printf("%13lu milli writing\n",milli_writing);
-    printf("%13lu inprogress IO\n",inprogress_IO);
-    printf("%13lu milli spent IO\n",milli_spent_IO);
-
-    free(disks);
-    free(partitions);
-  }
-}
-
-////////////////////////////////////////////////////////////////////////////
-
-static void sum_format(void) {
-  unsigned int running, blocked, btime, processes;
-  jiff cpu_use, cpu_nic, cpu_sys, cpu_idl, cpu_iow, cpu_xxx, cpu_yyy, cpu_zzz;
-  unsigned long pgpgin, pgpgout, pswpin, pswpout;
-  unsigned int intr, ctxt;
-
-  meminfo();
-
-  getstat(&cpu_use, &cpu_nic, &cpu_sys, &cpu_idl,
-          &cpu_iow, &cpu_xxx, &cpu_yyy, &cpu_zzz,
-	  &pgpgin, &pgpgout, &pswpin, &pswpout,
-	  &intr, &ctxt,
-	  &running, &blocked,
-	  &btime, &processes);
-
-  printf("%13lu %s total memory\n", unitConvert(kb_main_total),szDataUnit);
-  printf("%13lu %s used memory\n", unitConvert(kb_main_used),szDataUnit);
-  printf("%13lu %s active memory\n", unitConvert(kb_active),szDataUnit);
-  printf("%13lu %s inactive memory\n", unitConvert(kb_inactive),szDataUnit);
-  printf("%13lu %s free memory\n", unitConvert(kb_main_free),szDataUnit);
-  printf("%13lu %s buffer memory\n", unitConvert(kb_main_buffers),szDataUnit);
-  printf("%13lu %s swap cache\n", unitConvert(kb_main_cached),szDataUnit);
-  printf("%13lu %s total swap\n", unitConvert(kb_swap_total),szDataUnit);
-  printf("%13lu %s used swap\n", unitConvert(kb_swap_used),szDataUnit);
-  printf("%13lu %s free swap\n", unitConvert(kb_swap_free),szDataUnit);
-  printf("%13Lu non-nice user cpu ticks\n", cpu_use);
-  printf("%13Lu nice user cpu ticks\n", cpu_nic);
-  printf("%13Lu system cpu ticks\n", cpu_sys);
-  printf("%13Lu idle cpu ticks\n", cpu_idl);
-  printf("%13Lu IO-wait cpu ticks\n", cpu_iow);
-  printf("%13Lu IRQ cpu ticks\n", cpu_xxx);
-  printf("%13Lu softirq cpu ticks\n", cpu_yyy);
-  printf("%13Lu stolen cpu ticks\n", cpu_zzz);
-  printf("%13lu pages paged in\n", pgpgin);
-  printf("%13lu pages paged out\n", pgpgout);
-  printf("%13lu pages swapped in\n", pswpin);
-  printf("%13lu pages swapped out\n", pswpout);
-  printf("%13u interrupts\n", intr);
-  printf("%13u CPU context switches\n", ctxt);
-  printf("%13u boot time\n", btime);
-  printf("%13u forks\n", processes);
-}
-
-////////////////////////////////////////////////////////////////////////////
-
-static void fork_format(void) {
-  unsigned int running, blocked, btime, processes;
-  jiff cpu_use, cpu_nic, cpu_sys, cpu_idl, cpu_iow, cpu_xxx, cpu_yyy, cpu_zzz;
-  unsigned long pgpgin, pgpgout, pswpin, pswpout;
-  unsigned int intr, ctxt;
-
-  getstat(&cpu_use, &cpu_nic, &cpu_sys, &cpu_idl,
-	  &cpu_iow, &cpu_xxx, &cpu_yyy, &cpu_zzz,
-	  &pgpgin, &pgpgout, &pswpin, &pswpout,
-	  &intr, &ctxt,
-	  &running, &blocked,
-	  &btime, &processes);
-
-  printf("%13u forks\n", processes);
-}
-
-////////////////////////////////////////////////////////////////////////////
-
-static int winhi(void) {
-    struct winsize win;
-    int rows = 24;
- 
-    if (ioctl(1, TIOCGWINSZ, &win) != -1 && win.ws_row > 0)
-      rows = win.ws_row;
- 
-    return rows;
-}
-
-////////////////////////////////////////////////////////////////////////////
-
-int main(int argc, char *argv[]) {
-  char *partition = NULL;
-  int c;
-
-  while((c = getopt(argc, argv, "VdafmDnp:S:s")) != EOF) switch(c) {
-      case 'V':
-	display_version();
-	exit(0);
-      case 'd':
-	statMode |= DISKSTAT;
-	break;
-      case 'a':
-	/* active/inactive mode */
-	a_option=1;
-        break;
-      case 'f':
-        // FIXME: check for conflicting args
-	fork_format();
-        exit(0);
-      case 'm':
-        statMode |= SLABSTAT;
-	break;
-      case 'D':
-        statMode |= DISKSUMSTAT; 	
-	break;
-      case 'n':
-	/* print only one header */
-	moreheaders=FALSE;
-        break;
-      case 'p':
-        statMode |= PARTITIONSTAT;
-	partition = optarg;
-	if (memcmp(partition, "/dev/", 5) == 0) partition += 5;
-        break;
-      case 'S':
-	switch(optarg[0]) {
-	case 'b': case 'B': dataUnit = UNIT_B; break;
-	case 'k': dataUnit = UNIT_k; break;
-	case 'K': dataUnit = UNIT_K; break;
-	case 'm': dataUnit = UNIT_m; break;
-	case 'M': dataUnit = UNIT_M; break;
-	default:
-	  fprintf(stderr, "-S requires k, K, m or M (default is kb)\n");
-	  exit(EXIT_FAILURE);
-	}
-	szDataUnit[0] = optarg[0];
-	break;
-      case 's':
-        statMode |= VMSUMSTAT;
-	break;
-      default:
-	/* no other aguments defined yet. */
-	usage();
-  }
-
-  if (optind < argc) {
-    if ((sleep_time = atoi(argv[optind++])) == 0)
-         usage();
-    num_updates = ULONG_MAX;
-  }
-  if (optind < argc)
-    num_updates = atol(argv[optind++]);
-  if (optind < argc)
-     usage();
-
-  if (moreheaders) {
-      int tmp=winhi()-3;
-      height=((tmp>0)?tmp:22);
-  }    
-  setlinebuf(stdout);
-  switch(statMode){
-	case(VMSTAT):        new_format();
-			     break;
-	case(VMSUMSTAT):     sum_format();
-			     break;
-	case(DISKSTAT):      diskformat();
-			     break;
-	case(PARTITIONSTAT): if(diskpartition_format(partition)==-1)
-                                  printf("Partition was not found\n");
-			     break;	
-	case(SLABSTAT):      slabformat();
-			     break;
-	case(DISKSUMSTAT):   disksum_format();  
-			     break;	
-	default:	     usage();
-			     break;
-  }
-  return 0;
-}
-
-
diff --git a/w.1 b/w.1
deleted file mode 100644
index d35be87c..00000000
--- a/w.1
+++ /dev/null
@@ -1,84 +0,0 @@
-.\"             -*-Nroff-*-
-.\"
-.TH W 1 "8 Dec 1993 " " " "Linux User's Manual"
-.SH NAME
-w \- Show who is logged on and what they are doing.
-.SH SYNOPSIS
-.B w
-.RB [ \-husfV ]
-.RI [ user ]
-.SH DESCRIPTION
-.B w
-displays information about the users currently on the machine,
-and their processes.
-The header shows, in this order,  the current time,
-how long the system has been running,
-how many users are currently logged on,
-and the system load averages for the past 1, 5, and 15 minutes.
-
-The following entries are displayed for each user:
-login name, the tty name, the remote host, login time, idle time, JCPU, PCPU,
-and the command line of their current process.
-
-The JCPU time is the time used by all processes attached to the tty.  It
-does not include past background jobs, but does include currently
-running background jobs.
-
-The PCPU time is the time used by the current process, named in the "what"
-field.
-
-.PP
-.SH "COMMAND\-LINE OPTIONS"
-.TP 0.5i
-.B "\-h "
-Don't print the header.
-.TP 0.5i
-.B "\-u "
-Ignores the username while figuring out the current process and cpu
-times.  To demonstrate this, do a "su" and do a "w" and a "w \-u".
-.TP 0.5i
-.B "\-s "
-Use the short format.
-Don't print the login time, JCPU or PCPU times.
-.TP 0.5i
-.B "\-f "
-Toggle printing the
-.B from
-(remote hostname) field.  The default as
-released is for the
-.B from
-field to not be printed, although your system administrator or
-distribution maintainer may have compiled a version in which the
-.B from
-field is shown by default.
-.TP 0.5i
-.B "\-V "
-Display version information.
-.TP 0.5i
-.B "user "
-Show information about the specified user only.
-
-.SH FILES
-.TP
-.I /var/run/utmp
-information about who is currently logged on
-.TP
-.I /proc
-process information
-.PP
-
-.SH "SEE ALSO"
-.BR free (1),
-.BR ps (1),
-.BR top (1),
-.BR uptime (1),
-.BR utmp (5),
-.BR who (1)
-
-.SH AUTHORS
-.B w
-was re-written almost entirely by Charles Blake, based on the version by Larry
-Greenfield <greenfie@gauss.rutgers.edu> and Michael K. Johnson
-<johnsonm@redhat.com>.
-
-Please send bug reports to <procps@freelists.org>
diff --git a/w.c b/w.c
deleted file mode 100644
index f479433c..00000000
--- a/w.c
+++ /dev/null
@@ -1,308 +0,0 @@
-/* w - show what logged in users are doing.  Almost entirely rewritten from
- * scratch by Charles Blake circa June 1996.  Some vestigal traces of the
- * original may exist.  That was done in 1993 by Larry Greenfield with some
- * fixes by Michael K. Johnson.
- *
- * Changes by Albert Cahalan, 2002.
- */
-#include "proc/version.h"
-#include "proc/whattime.h"
-#include "proc/readproc.h"
-#include "proc/devname.h"
-#include "proc/procps.h"
-#include "proc/sysinfo.h"
-#include "proc/escape.h"
-#include <ctype.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <signal.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sys/ioctl.h>
-#include <sys/mman.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-#include <pwd.h>
-#include <time.h>
-#include <unistd.h>
-#include <utmp.h>
-#include <locale.h>
-#include <termios.h>
-
-static int ignoreuser = 0;	/* for '-u' */
-static proc_t **procs;		/* our snapshot of the process table */
-
-typedef struct utmp utmp_t;
-
-#ifdef W_SHOWFROM
-#   define FROM_STRING "on"
-#else
-#   define FROM_STRING "off"
-#endif
-
-/* Uh... same thing as UT_NAMESIZE */
-#define USERSZ (sizeof u->ut_user)
-
-
-/* This routine is careful since some programs leave utmp strings
- * unprintable.  Always outputs at least 16 chars padded with spaces
- * on the right if necessary.
- */
-static void print_host(const char *restrict host, int len) {
-    const char *last;
-    int width = 0;
-
-    /* FIXME: there should really be a way to configure this... */
-    /* for now, we'll just limit it to the 16 that the libc5 version
-     * of utmp uses.
-     */
-    if (len > 16) len = 16;
-    last = host + len;
-    for ( ; host < last ; host++){
-        if (isprint(*host) && *host != ' ') {
-	    fputc(*host, stdout);
-	    ++width;
-	} else {
-	    break;
-	}
-    }
-    // space-fill, and a '-' too if needed to ensure the column exists
-    if(width < 16) fputs("-               "+width, stdout);
-}
-
-/***** compact 7 char format for time intervals (belongs in libproc?) */
-static void print_time_ival7(time_t t, int centi_sec, FILE* fout) {
-    if((long)t < (long)0){  /* system clock changed? */
-      printf("   ?   ");
-      return;
-    }
-    if (t >= 48*60*60)				/* > 2 days */
-	fprintf(fout, " %2ludays", t/(24*60*60));
-    else if (t >= 60*60)			/* > 1 hour */
-	fprintf(fout, " %2lu:%02um", t/(60*60), (unsigned) ((t/60)%60));
-    else if (t > 60)				/* > 1 minute */
-	fprintf(fout, " %2lu:%02u ", t/60, (unsigned) t%60);
-    else
-	fprintf(fout, " %2lu.%02us", t, centi_sec);
-}
-
-/**** stat the device file to get an idle time */
-static time_t idletime(const char *restrict const tty) {
-    struct stat sbuf;
-    if (stat(tty, &sbuf) != 0)
-	return 0;
-    return time(NULL) - sbuf.st_atime;
-}
-
-/***** 7 character formatted login time */
-static void print_logintime(time_t logt, FILE* fout) {
-    char weekday[][4] = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" },
-	 month  [][4] = { "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul",
-			"Aug", "Sep", "Oct", "Nov", "Dec" };
-    time_t curt;
-    struct tm *logtm, *curtm;
-    int today;
-
-    curt = time(NULL);
-    curtm = localtime(&curt);
-    /* localtime returns a pointer to static memory */
-    today = curtm->tm_yday;
-    logtm = localtime(&logt);
-    if (curt - logt > 12*60*60 && logtm->tm_yday != today) {
-	if (curt - logt > 6*24*60*60)
-	    fprintf(fout, " %02d%3s%02d", logtm->tm_mday, month[logtm->tm_mon],
-		    logtm->tm_year % 100);
-	else
-            fprintf(fout, " %3s%02d  ", weekday[logtm->tm_wday], logtm->tm_hour);
-    } else {
-        fprintf(fout, " %02d:%02d  ", logtm->tm_hour, logtm->tm_min);
-    }
-}
-
-
-/* This function scans the process table accumulating total cpu times for
- * any processes "associated" with this login session.  It also searches
- * for the "best" process to report as "(w)hat" the user for that login
- * session is doing currently.  This the essential core of 'w'.
- */
-static const proc_t *getproc(const utmp_t *restrict const u, const char *restrict const tty, unsigned long long *restrict const jcpu, int *restrict const found_utpid) {
-    int line;
-    proc_t **pptr = procs;
-    const proc_t *best = NULL;
-    const proc_t *secondbest = NULL;
-    unsigned uid = ~0U;
-
-    *found_utpid = 0;
-    if(!ignoreuser){
-	char buf[UT_NAMESIZE+1];
-	struct passwd *passwd_data;   /* pointer to static data */
-	strncpy(buf,u->ut_user,UT_NAMESIZE);
-	buf[UT_NAMESIZE] = '\0';
-	passwd_data = getpwnam(buf);
-	if(!passwd_data) return NULL;
-	uid = passwd_data->pw_uid;
-	/* OK to have passwd_data go out of scope here */
-    }
-    line = tty_to_dev(tty);
-    *jcpu = 0;
-    for(; *pptr; pptr++) {
-	const proc_t *restrict const tmp = *pptr;
-	if(unlikely(tmp->tgid == u->ut_pid)) {
-	    *found_utpid = 1;
-	    best = tmp;
-	}
-	if(tmp->tty != line) continue;
-	(*jcpu) += tmp->utime + tmp->stime;
-	secondbest = tmp;
-	/* same time-logic here as for "best" below */
-	if(!  (secondbest && tmp->start_time <= secondbest->start_time)  ){
-	    secondbest = tmp;
-	}
-	if(!ignoreuser && uid != tmp->euid && uid != tmp->ruid) continue;
-	if(tmp->pgrp != tmp->tpgid) continue;
-	if(best && tmp->start_time <= best->start_time) continue;
-    	best = tmp;
-    }
-    return best ? best : secondbest;
-}
-
-
-/***** showinfo */
-static void showinfo(utmp_t *u, int formtype, int maxcmd, int from) {
-    unsigned long long jcpu;
-    int ut_pid_found;
-    unsigned i;
-    char uname[USERSZ + 1] = "",
-	tty[5 + sizeof u->ut_line + 1] = "/dev/";
-    const proc_t *best;
-
-    for (i=0; i < sizeof(u->ut_line); i++)	/* clean up tty if garbled */
-	if (isalnum(u->ut_line[i]) || (u->ut_line[i]=='/'))
-	    tty[i+5] = u->ut_line[i];
-	else
-	    tty[i+5] = '\0';
-
-    best = getproc(u, tty + 5, &jcpu, &ut_pid_found);
-
-    /* just skip if stale utmp entry (i.e. login proc doesn't exist).  If there
-     * is a desire a cmdline flag could be added to optionally show it with a
-     * prefix of (stale) in front of cmd or something like that.
-     */
-    if (!ut_pid_found)
-	return;
-
-    strncpy(uname, u->ut_user, USERSZ);		/* force NUL term for printf */
-    if (formtype) {
-	printf("%-9.8s%-9.8s", uname, u->ut_line);
-	if (from)
-	    print_host(u->ut_host, sizeof u->ut_host);
-	print_logintime(u->ut_time, stdout);
-	if (*u->ut_line == ':')			/* idle unknown for xdm logins */
-	    printf(" ?xdm? ");
-	else
-	    print_time_ival7(idletime(tty), 0, stdout);
-	print_time_ival7(jcpu/Hertz, (jcpu%Hertz)*(100./Hertz), stdout);
-	if (best) {
-	    unsigned long long pcpu = best->utime + best->stime;
-	    print_time_ival7(pcpu/Hertz, (pcpu%Hertz)*(100./Hertz), stdout);
-	} else
-	    printf("   ?   ");
-    } else {
-	printf("%-9.8s%-9.8s", u->ut_user, u->ut_line);
-	if (from)
-	    print_host(u->ut_host, sizeof u->ut_host);
-	if (*u->ut_line == ':')			/* idle unknown for xdm logins */
-	    printf(" ?xdm? ");
-	else
-	    print_time_ival7(idletime(tty), 0, stdout);
-    }
-    fputs(" ", stdout);
-    if (likely(best)) {
-	char cmdbuf[512];
-	escape_command(cmdbuf, best, sizeof cmdbuf, &maxcmd, ESC_ARGS);
-	fputs(cmdbuf,stdout);
-    } else {
-	printf("-");
-    }
-    fputc('\n', stdout);
-}
-
-/***** main */
-int main(int argc, char **argv) {
-    char *user = NULL;
-    utmp_t *u;
-    struct winsize win;
-    int header=1, longform=1, from=1, args, maxcmd=80, ch;
-
-#ifndef W_SHOWFROM
-    from = 0;
-#endif
-
-    setlocale(LC_ALL, "");
-    for (args=0; (ch = getopt(argc, argv, "hlusfV")) != EOF; args++)
-	switch (ch) {
-	  case 'h': header = 0;		break;
-	  case 'l': longform = 1;	break;
-	  case 's': longform = 0;	break;
-	  case 'f': from = !from;	break;
-	  case 'V': display_version();	exit(0);
-	  case 'u': ignoreuser = 1;	break;
-	  default:
-	    printf("usage: w -hlsufV [user]\n"
-		   "    -h    skip header\n"
-		   "    -l    long listing (default)\n"
-		   "    -s    short listing\n"
-		   "    -u    ignore uid of processes\n"
-		   "    -f    toggle FROM field (default %s)\n"
-		   "    -V    display version\n", FROM_STRING);
-	    exit(1);
-	}
-
-    if ((argv[optind]))
-	user = (argv[optind]);
-
-    if (ioctl(1, TIOCGWINSZ, &win) != -1 && win.ws_col > 0)
-	maxcmd = win.ws_col;
-    if (maxcmd < 71) {
-	fprintf(stderr, "%d column window is too narrow\n", maxcmd);
-	exit(1);
-    }
-    maxcmd -= 29 + (from ? 16 : 0) + (longform ? 20 : 0);
-    if (maxcmd < 3)
-	fprintf(stderr, "warning: screen width %d suboptimal.\n", win.ws_col);
-
-    procs = readproctab(PROC_FILLCOM | PROC_FILLUSR | PROC_FILLSTAT);
-
-    if (header) {				/* print uptime and headers */
-	print_uptime();
-	printf("USER     TTY      ");
-	if (from)
-	    printf("FROM            ");
-	if (longform)
-	    printf("  LOGIN@   IDLE   JCPU   PCPU WHAT\n");
-	else
-	    printf("   IDLE WHAT\n");
-    }
-
-    utmpname(UTMP_FILE);
-    setutent();
-    if (user) {
-	for (;;) {
-	    u = getutent();
-	    if (unlikely(!u)) break;
-	    if (u->ut_type != USER_PROCESS) continue;
- 	    if (!strncmp(u->ut_user, user, USERSZ)) showinfo(u, longform, maxcmd, from);
-	}
-    } else {
-	for (;;) {
-	    u = getutent();
-	    if (unlikely(!u)) break;
-	    if (u->ut_type != USER_PROCESS) continue;
- 	    if (*u->ut_user) showinfo(u, longform, maxcmd, from);
-	}
-    }
-    endutent();
-
-    return 0;
-}
diff --git a/watch.1 b/watch.1
deleted file mode 100644
index 16167942..00000000
--- a/watch.1
+++ /dev/null
@@ -1,96 +0,0 @@
-.TH WATCH 1 "2009 May 11" " " "Linux User's Manual"
-.SH NAME
-watch \- execute a program periodically, showing output fullscreen
-.SH SYNOPSIS
-.na
-.B watch
-.RB [ \-dhvt ]
-.RB [ \-n
-.IR seconds ]
-.RB [ \-\-differences[=\fIcumulative\fP]]
-.RB [ \-\-help ]
-.RB [ \-\-interval=\fIseconds\fP]
-.RB [ \-\-no\-title ]
-.RB [ \-\-version ]
-.I command
-.SH DESCRIPTION
-.B watch
-runs
-.I command
-repeatedly, displaying its output (the first screenfull).  This allows you to
-watch the program output change over time.  By default, the program is run
-every 2 seconds; use 
-.B \-n
-or
-.B \-\-interval
-to specify a different interval.
-.PP
-The
-.B \-d
-or
-.B \-\-differences
-flag will highlight the differences between successive updates.  Using
-.B \-\-differences=\fIcumulative\fP
-makes highlighting "sticky", presenting a running display of all
-positions that have ever changed.  The
-.B \-t
-or
-.B \-\-no\-title
-option turns off the header showing the interval, command, and current
-time at the top of the display, as well as the following blank line.
-.PP
-.B watch
-will run until interrupted.
-.SH NOTE
-Note that
-.I command
-is given to "sh \-c"
-which means that you may need to use extra quoting to get the desired effect.
-.PP
-Note that POSIX option processing is used (i.e., option processing stops at
-the first non\-option argument).  This means that flags after
-.I command
-don't get interpreted by
-.BR watch
-itself.
-.SH EXAMPLES
-.PP
-To watch for mail, you might do
-.IP
-watch \-n 60 from
-.PP
-To watch the contents of a directory change, you could use
-.IP
-watch \-d ls \-l
-.PP
-If you're only interested in files owned by user joe, you might use 
-.IP
-watch \-d 'ls \-l | fgrep joe'
-.PP
-To see the effects of quoting, try these out
-.IP
-watch echo $$
-.br
-watch echo '$$'
-.br
-watch echo "'"'$$'"'"
-.PP
-You can watch for your administrator to install the latest kernel with
-.IP
-watch uname \-r
-.PP
-(Just kidding.)
-.SH BUGS
-Upon terminal resize, the screen will not be correctly repainted until the
-next scheduled update.  All
-.B \-\-differences
-highlighting is lost on that update as well.
-.PP
-Non-printing characters are stripped from program output.  Use "cat -v" as
-part of the command pipeline if you want to see them.
-.SH AUTHORS
-The original
-.B watch
-was written by Tony Rems <rembo@unisoft.com> in 1991, with mods and
-corrections by Francois Pinard.  It was reworked and new features added by
-Mike Coleman <mkc@acm.org> in 1999.
diff --git a/watch.c b/watch.c
deleted file mode 100644
index 1e050dc6..00000000
--- a/watch.c
+++ /dev/null
@@ -1,325 +0,0 @@
-/* watch -- execute a program repeatedly, displaying output fullscreen
- *
- * Based on the original 1991 'watch' by Tony Rems <rembo@unisoft.com>
- * (with mods and corrections by Francois Pinard).
- *
- * Substantially reworked, new features (differences option, SIGWINCH
- * handling, unlimited command length, long line handling) added Apr 1999 by
- * Mike Coleman <mkc@acm.org>.
- *
- * Changes by Albert Cahalan, 2002-2003.
- */
-
-#include <ctype.h>
-#include <getopt.h>
-#include <signal.h>
-#include <ncurses.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sys/ioctl.h>
-#include <time.h>
-#include <unistd.h>
-#include <termios.h>
-#include <locale.h>
-#include "proc/procps.h"
-#include "config.h"
-
-#ifdef FORCE_8BIT
-#undef isprint
-#define isprint(x) ( (x>=' '&&x<='~') || (x>=0xa0) )
-#endif
-
-static struct option longopts[] = {
-	{"differences", optional_argument, 0, 'd'},
-	{"help", no_argument, 0, 'h'},
-	{"interval", required_argument, 0, 'n'},
-	{"no-title", no_argument, 0, 't'},
-	{"version", no_argument, 0, 'v'},
-	{0, 0, 0, 0}
-};
-
-static char usage[] =
-    "Usage: %s [-dhntv] [--differences[=cumulative]] [--help] [--interval=<n>] [--no-title] [--version] <command>\n";
-
-static char *progname;
-
-static int curses_started = 0;
-static int height = 24, width = 80;
-static int screen_size_changed = 0;
-static int first_screen = 1;
-static int show_title = 2;  // number of lines used, 2 or 0
-
-#define min(x,y) ((x) > (y) ? (y) : (x))
-
-static void do_usage(void) NORETURN;
-static void do_usage(void)
-{
-	fprintf(stderr, usage, progname);
-	exit(1);
-}
-
-static void do_exit(int status) NORETURN;
-static void do_exit(int status)
-{
-	if (curses_started)
-		endwin();
-	exit(status);
-}
-
-/* signal handler */
-static void die(int notused) NORETURN;
-static void die(int notused)
-{
-	(void) notused;
-	do_exit(0);
-}
-
-static void
-winch_handler(int notused)
-{
-	(void) notused;
-	screen_size_changed = 1;
-}
-
-static char env_col_buf[24];
-static char env_row_buf[24];
-static int incoming_cols;
-static int incoming_rows;
-
-static void
-get_terminal_size(void)
-{
-	struct winsize w;
-	if(!incoming_cols){  // have we checked COLUMNS?
-		const char *s = getenv("COLUMNS");
-		incoming_cols = -1;
-		if(s && *s){
-			long t;
-			char *endptr;
-			t = strtol(s, &endptr, 0);
-			if(!*endptr && (t>0) && (t<(long)666)) incoming_cols = (int)t;
-			width = incoming_cols;
-			snprintf(env_col_buf, sizeof env_col_buf, "COLUMNS=%d", width);
-			putenv(env_col_buf);
-		}
-	}
-	if(!incoming_rows){  // have we checked LINES?
-		const char *s = getenv("LINES");
-		incoming_rows = -1;
-		if(s && *s){
-			long t;
-			char *endptr;
-			t = strtol(s, &endptr, 0);
-			if(!*endptr && (t>0) && (t<(long)666)) incoming_rows = (int)t;
-			height = incoming_rows;
-			snprintf(env_row_buf, sizeof env_row_buf, "LINES=%d", height);
-			putenv(env_row_buf);
-		}
-	}
-	if (incoming_cols<0 || incoming_rows<0){
-		if (ioctl(2, TIOCGWINSZ, &w) == 0) {
-			if (incoming_rows<0 && w.ws_row > 0){
-				height = w.ws_row;
-				snprintf(env_row_buf, sizeof env_row_buf, "LINES=%d", height);
-				putenv(env_row_buf);
-			}
-			if (incoming_cols<0 && w.ws_col > 0){
-				width = w.ws_col;
-				snprintf(env_col_buf, sizeof env_col_buf, "COLUMNS=%d", width);
-				putenv(env_col_buf);
-			}
-		}
-	}
-}
-
-int
-main(int argc, char *argv[])
-{
-	int optc;
-	int option_differences = 0,
-	    option_differences_cumulative = 0,
-	    option_help = 0, option_version = 0;
-	double interval = 2;
-	char *command;
-	int command_length = 0;	/* not including final \0 */
-
-	setlocale(LC_ALL, "");
-	progname = argv[0];
-
-	while ((optc = getopt_long(argc, argv, "+d::hn:vt", longopts, (int *) 0))
-	       != EOF) {
-		switch (optc) {
-		case 'd':
-			option_differences = 1;
-			if (optarg)
-				option_differences_cumulative = 1;
-			break;
-		case 'h':
-			option_help = 1;
-			break;
-		case 't':
-			show_title = 0;
-			break;
-		case 'n':
-			{
-				char *str;
-				interval = strtod(optarg, &str);
-				if (!*optarg || *str)
-					do_usage();
-				if(interval < 0.1)
-					interval = 0.1;
-				if(interval > ~0u/1000000)
-					interval = ~0u/1000000;
-			}
-			break;
-		case 'v':
-			option_version = 1;
-			break;
-		default:
-			do_usage();
-			break;
-		}
-	}
-
-	if (option_version) {
-		fprintf(stderr, "%s\n", PACKAGE_NAME " version " PACKAGE_VERSION);
-		if (!option_help)
-			exit(0);
-	}
-
-	if (option_help) {
-		fprintf(stderr, usage, progname);
-		fputs("  -d, --differences[=cumulative]\thighlight changes between updates\n", stderr);
-		fputs("\t\t(cumulative means highlighting is cumulative)\n", stderr);
-		fputs("  -h, --help\t\t\t\tprint a summary of the options\n", stderr);
-		fputs("  -n, --interval=<seconds>\t\tseconds to wait between updates\n", stderr);
-		fputs("  -v, --version\t\t\t\tprint the version number\n", stderr);
-		fputs("  -t, --no-title\t\t\tturns off showing the header\n", stderr);
-		exit(0);
-	}
-
-	if (optind >= argc)
-		do_usage();
-
-	command = strdup(argv[optind++]);
-	command_length = strlen(command);
-	for (; optind < argc; optind++) {
-		char *endp;
-		int s = strlen(argv[optind]);
-		command = realloc(command, command_length + s + 2);	/* space and \0 */
-		endp = command + command_length;
-		*endp = ' ';
-		memcpy(endp + 1, argv[optind], s);
-		command_length += 1 + s;	/* space then string length */
-		command[command_length] = '\0';
-	}
-
-	get_terminal_size();
-
-	/* Catch keyboard interrupts so we can put tty back in a sane state.  */
-	signal(SIGINT, die);
-	signal(SIGTERM, die);
-	signal(SIGHUP, die);
-	signal(SIGWINCH, winch_handler);
-
-	/* Set up tty for curses use.  */
-	curses_started = 1;
-	initscr();
-	nonl();
-	noecho();
-	cbreak();
-
-	for (;;) {
-		time_t t = time(NULL);
-		char *ts = ctime(&t);
-		int tsl = strlen(ts);
-		char *header;
-		FILE *p;
-		int x, y;
-		int oldeolseen = 1;
-
-		if (screen_size_changed) {
-			get_terminal_size();
-			resizeterm(height, width);
-			clear();
-			/* redrawwin(stdscr); */
-			screen_size_changed = 0;
-			first_screen = 1;
-		}
-
-		if (show_title) {
-			// left justify interval and command,
-			// right justify time, clipping all to fit window width
-			asprintf(&header, "Every %.1fs: %.*s",
-				interval, min(width - 1, command_length), command);
-			mvaddstr(0, 0, header);
-			if (strlen(header) > (size_t) (width - tsl - 1))
-				mvaddstr(0, width - tsl - 4, "...  ");
-			mvaddstr(0, width - tsl + 1, ts);
-			free(header);
-		}
-
-		if (!(p = popen(command, "r"))) {
-			perror("popen");
-			do_exit(2);
-		}
-
-		for (y = show_title; y < height; y++) {
-			int eolseen = 0, tabpending = 0;
-			for (x = 0; x < width; x++) {
-				int c = ' ';
-				int attr = 0;
-
-				if (!eolseen) {
-					/* if there is a tab pending, just spit spaces until the
-					   next stop instead of reading characters */
-					if (!tabpending)
-						do
-							c = getc(p);
-						while (c != EOF && !isprint(c)
-						       && c != '\n'
-						       && c != '\t');
-					if (c == '\n')
-						if (!oldeolseen && x == 0) {
-							x = -1;
-							continue;
-						} else
-							eolseen = 1;
-					else if (c == '\t')
-						tabpending = 1;
-					if (c == EOF || c == '\n' || c == '\t')
-						c = ' ';
-					if (tabpending && (((x + 1) % 8) == 0))
-						tabpending = 0;
-				}
-				move(y, x);
-				if (option_differences) {
-					chtype oldch = inch();
-					char oldc = oldch & A_CHARTEXT;
-					attr = !first_screen
-					    && ((char)c != oldc
-						||
-						(option_differences_cumulative
-						 && (oldch & A_ATTRIBUTES)));
-				}
-				if (attr)
-					standout();
-				addch(c);
-				if (attr)
-					standend();
-			}
-			oldeolseen = eolseen;
-		}
-
-		pclose(p);
-
-		first_screen = 0;
-		refresh();
-		usleep(interval * 1000000);
-	}
-
-	endwin();
-
-	return 0;
-}
diff --git a/proc/wchan.h b/wchan.h
similarity index 100%
rename from proc/wchan.h
rename to wchan.h
diff --git a/proc/whattime.c b/whattime.c
similarity index 100%
rename from proc/whattime.c
rename to whattime.c
diff --git a/proc/whattime.h b/whattime.h
similarity index 100%
rename from proc/whattime.h
rename to whattime.h
